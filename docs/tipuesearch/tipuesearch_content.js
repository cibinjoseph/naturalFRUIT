var tipuesearch = {"pages":[{"title":" naturalFRUIT ","text":"naturalFRUIT A purely Fortran based unit testing framework derived from the original Fortran Unit Test Framework (FRUIT) Documentation available here .\nFor a list of test subroutines visit the Procedures page. Developer Info Cibin Joseph Ph.D. student at IIT Madras, India.","tags":"home","loc":"index.html"},{"title":"naturalfruit.f90 – naturalFRUIT","text":"Files dependent on this one sourcefile~~naturalfruit.f90~~AfferentGraph sourcefile~naturalfruit.f90 naturalfruit.f90 sourcefile~fruit_mpi.f90 fruit_mpi.f90 sourcefile~fruit_mpi.f90->sourcefile~naturalfruit.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fruit_util fruit Source Code naturalfruit.f90 Source Code ! Copyright (c) 2005-2010, 2012-2013, Andrew Hang Chen and contributors, ! All rights reserved. ! Licensed under the 3-clause BSD license. !------------------------ ! FORTRAN unit test utility ! ! Author: Andrew H. Chen meihome @at@ gmail.com !------------------------ ! ! Unit test framework for FORTRAN.  (FoRtran UnIT) ! ! This package is to perform unit test for FORTRAN subroutines ! ! The method used most are: assert_true, assert_equal ! ! Coding convention: !   1) All methods must be exposed by interface.  i.e. interface fruit_initialize !   2) Variable and methods are lower case connected with underscores.  i.e. fruit_initialize, and !      failed_assert_count ! module fruit_util !! display: none !! A utility module for [[fruit]] to use. private public :: equal , to_s , strip interface equal module procedure equalEpsilon module procedure floatEqual module procedure integerEqual module procedure doublePrecisionEqual module procedure stringEqual module procedure logicalEqual end interface interface to_s module procedure to_s_int_ module procedure to_s_real_ module procedure to_s_logical_ module procedure to_s_double_ module procedure to_s_complex_ module procedure to_s_double_complex_ module procedure to_s_string_ end interface interface strip module procedure strip_ module procedure strip_length_ end interface contains function to_s_int_ ( value ) implicit none character ( len = 500 ) :: to_s_int_ integer , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_int_ = adjustl ( trim ( result )) end function to_s_int_ function to_s_real_ ( value ) implicit none character ( len = 500 ) :: to_s_real_ real , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_real_ = adjustl ( trim ( result )) end function to_s_real_ function to_s_double_ ( value ) implicit none character ( len = 500 ) :: to_s_double_ double precision , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_ = adjustl ( trim ( result )) end function to_s_double_ function to_s_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_complex_ complex , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_complex_ = adjustl ( trim ( result )) end function to_s_complex_ function to_s_double_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_double_complex_ complex ( kind = kind ( 1.0D0 )), intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_complex_ = adjustl ( trim ( result )) end function to_s_double_complex_ function to_s_logical_ ( value ) implicit none character ( len = 500 ) :: to_s_logical_ logical , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_logical_ = adjustl ( trim ( result )) end function to_s_logical_ function to_s_string_ ( value ) implicit none character ( len = 500 ) :: to_s_string_ character ( len =* ), intent ( in ) :: value to_s_string_ = value end function to_s_string_ function strip_ ( value ) implicit none character ( len = 500 ) :: strip_ character ( len =* ), intent ( in ) :: value strip_ = trim ( adjustl ( value )) end function strip_ function strip_length_ ( value , length ) implicit none character ( len =* ), intent ( in ) :: value integer , intent ( in ) :: length character ( len = length ) :: strip_length_ strip_length_ = trim ( adjustl ( value )) end function strip_length_ !------------------------ ! test if 2 values are close !------------------------ !logical function equal (number1, number2) !  real,  intent (in) :: number1, number2 ! !  return equalEpsilon (number1, number2, epsilon(number1)) ! !end function equal function equalEpsilon ( number1 , number2 , epsilon ) result ( resultValue ) real , intent ( in ) :: number1 , number2 , epsilon logical :: resultValue resultValue = . false . ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function equalEpsilon function floatEqual ( number1 , number2 ) result ( resultValue ) real , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function floatEqual function doublePrecisionEqual ( number1 , number2 ) result ( resultValue ) double precision , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 !epsilon = epsilon (number1) ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function doublePrecisionEqual function integerEqual ( number1 , number2 ) result ( resultValue ) integer , intent ( in ) :: number1 , number2 logical :: resultValue resultValue = . false . if ( number1 . eq . number2 ) then resultValue = . true . else resultValue = . false . end if end function integerEqual function stringEqual ( str1 , str2 ) result ( resultValue ) character ( * ) , intent ( in ) :: str1 , str2 logical :: resultValue resultValue = . false . if ( str1 . eq . str2 ) then resultValue = . true . end if end function stringEqual function logicalEqual ( l1 , l2 ) result ( resultValue ) logical , intent ( in ) :: l1 , l2 logical :: resultValue resultValue = . false . if ( l1 . eqv . l2 ) then resultValue = . true . end if end function logicalEqual end module fruit_util module fruit use fruit_util implicit none private integer , parameter :: STDOUT_DEFAULT = 6 integer :: stdout = STDOUT_DEFAULT integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK_DEFAULT = 21 integer :: xml_work = XML_WORK_DEFAULT character ( len = * ), parameter :: xml_filename = \"result.xml\" character ( len = * ), parameter :: XML_FN_WORK_DEF = \"result_tmp.xml\" character ( len = 50 ) :: xml_filename_work = XML_FN_WORK_DEF integer , parameter :: MAX_NUM_FAILURES_IN_XML = 10 integer , parameter :: XML_LINE_LENGTH = 2670 ! xml_line_length >= max_num_failures_in_xml * (msg_length + 1) + 50 integer , parameter :: STRLEN_T = 12 integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: MSG_LENGTH = 256 integer , parameter :: MAX_MSG_STACK_SIZE = 2000 integer , parameter :: MSG_ARRAY_INCREMENT = 50 integer , parameter :: MAX_MARKS_PER_LINE = 78 character ( * ), parameter :: DEFAULT_CASE_NAME = '_not_set_' logical , private , parameter :: DEFAULT_CASE_PASSED = . true . !---------- save ---------- integer , private , save :: successful_assert_count = 0 integer , private , save :: failed_assert_count = 0 integer , private , save :: message_index = 1 integer , private , save :: message_index_from = 1 integer , private , save :: current_max = 50 character ( len = MSG_LENGTH ), private , allocatable :: message_array (:) character ( len = MSG_LENGTH ), private , save :: msg = '[unit name not set from set_name]: ' character ( len = MSG_LENGTH ), private , save :: case_name = DEFAULT_CASE_NAME integer , private , save :: successful_case_count = 0 integer , private , save :: failed_case_count = 0 integer , private , save :: testCaseIndex = 1 logical , private , save :: last_passed = . false . logical , private , save :: case_passed = DEFAULT_CASE_PASSED integer , private , save :: case_time_from = 0 integer , private , save :: linechar_count = 0 logical , private , save :: if_show_dots = . true . integer , parameter :: FRUIT_PREFIX_LEN_MAX = 50 character ( len = FRUIT_PREFIX_LEN_MAX ) :: prefix = \"\" !---------- save ---------- type ty_stack !! display: none integer :: successful_assert_count integer :: failed_assert_count integer :: message_index integer :: message_index_from integer :: current_max character ( len = MSG_LENGTH ), pointer :: message_array (:) character ( len = MSG_LENGTH ) :: case_name !  = DEFAULT_CASE_NAME integer :: successful_case_count integer :: failed_case_count integer :: testCaseIndex logical :: last_passed logical :: case_passed = DEFAULT_CASE_PASSED integer :: case_time_from integer :: linechar_count logical :: if_show_dots end type ty_stack type ( ty_stack ), save :: stashed_suite public :: & fruit_initialize public :: & get_last_message , & is_last_passed , & is_case_passed , & add_success , & set_unit_name , get_unit_name , & set_case_name , get_case_name , & failed_assert_action , get_total_count , & get_failed_count , is_all_successful , & run_test_case public :: assert_equal public :: assert_not_equal public :: assert_true public :: stash_test_suite , restore_test_suite public :: FRUIT_PREFIX_LEN_MAX public :: override_xml_work , end_override_xml_work public :: get_assert_and_case_count public :: assert_false interface assert_false !! Test that *var1* is false. module procedure assert_false_ end interface interface assert_equal !! summary: Test that *var1* and *var2* are equal. !! Test that *var1* and *var2* are equal. !! If the values do not compare equal, the test will fail.<br/><br/> !! assert_equal invokes one of the following subroutines according !! to the number or type of arguments. !====== begin of generated interface ====== module procedure assert_eq_logical_ module procedure assert_eq_1d_logical_ module procedure assert_eq_2d_logical_ module procedure assert_eq_string_ module procedure assert_eq_1d_string_ module procedure assert_eq_2d_string_ module procedure assert_eq_int_ module procedure assert_eq_1d_int_ module procedure assert_eq_2d_int_ module procedure assert_eq_real_ module procedure assert_eq_real_in_range_ module procedure assert_eq_1d_real_ module procedure assert_eq_1d_real_in_range_ module procedure assert_eq_2d_real_ module procedure assert_eq_2d_real_in_range_ module procedure assert_eq_double_ module procedure assert_eq_double_in_range_ module procedure assert_eq_1d_double_ module procedure assert_eq_1d_double_in_range_ module procedure assert_eq_2d_double_ module procedure assert_eq_2d_double_in_range_ module procedure assert_eq_complex_ module procedure assert_eq_complex_in_range_ module procedure assert_eq_1d_complex_ module procedure assert_eq_1d_complex_in_range_ module procedure assert_eq_2d_complex_ module procedure assert_eq_2d_complex_in_range_ !====== end of generated inteface ====== end interface interface assert_not_equal !! summary: Test that *var1* and *var2* are not equal. !! Test that *var1* and *var2* are not equal. !! If the values do compare equal, the test will fail.<br/><br/> !! assert_not_equal invokes one of the following subroutines according !! to the number or type of arguments. !====== begin of generated interface ====== module procedure assert_not_equal_logical_ module procedure assert_not_equal_1d_logical_ module procedure assert_not_equal_2d_logical_ module procedure assert_not_equal_string_ module procedure assert_not_equal_1d_string_ module procedure assert_not_equal_2d_string_ module procedure assert_not_equal_int_ module procedure assert_not_equal_1d_int_ module procedure assert_not_equal_2d_int_ module procedure assert_not_equal_real_ module procedure assert_not_equal_real_in_range_ module procedure assert_not_equal_1d_real_ module procedure assert_not_equal_1d_real_in_range_ module procedure assert_not_equal_2d_real_ module procedure assert_not_equal_2d_real_in_range_ module procedure assert_not_equal_double_ module procedure assert_not_equal_double_in_range_ module procedure assert_not_equal_1d_double_ module procedure assert_not_equal_1d_double_in_range_ module procedure assert_not_equal_2d_double_ module procedure assert_not_equal_2d_double_in_range_ module procedure assert_not_equal_complex_ module procedure assert_not_equal_complex_in_range_ module procedure assert_not_equal_1d_complex_ module procedure assert_not_equal_1d_complex_in_range_ module procedure assert_not_equal_2d_complex_ module procedure assert_not_equal_2d_complex_in_range_ !====== end of generated inteface ====== end interface public :: add_fail interface add_fail !! category: driver subroutine !! summary: Print message to screen on assert failure and add to count. !! Print message to screen on assert failure and add to count.<br/><br/> !! add_fail invokes one of the following subroutines according !! to number of arguments. module procedure add_fail_ module procedure add_fail_unit_ end interface interface run_test_case !! category: basket subroutine !! summary: Run a specific test case. !! Run a specific test case.<br/><br/> !! run_test_case invokes one of the following subroutines according !! to number of arguments. module procedure run_test_case_ module procedure run_test_case_named_ end interface public :: fruit_initialize_xml interface fruit_initialize_xml !! category: driver subroutine !! Initialize FRUIT driver environment for output to XML file module procedure fruit_initialize_xml_ end interface public :: fruit_summary interface fruit_summary !! category: driver subroutine !! Summarize FRUIT test results to screen. module procedure fruit_summary_ end interface public :: fruit_summary_xml interface fruit_summary_xml !! category: driver subroutine !! Summarize FRUIT test results in XML format to result.xml file. module procedure fruit_summary_xml_ end interface public :: case_passed_xml interface case_passed_xml !! category: driver subroutine !! Write to XML file a passed case. module procedure case_passed_xml_ end interface public :: case_failed_xml interface case_failed_xml !! category: driver subroutine !! Write to XML file a failed case. module procedure case_failed_xml_ end interface public :: override_stdout interface override_stdout !! category: driver subroutine !! Override stdout to a user-specified file. Terminal by default. module procedure override_stdout_ end interface public :: end_override_stdout interface end_override_stdout !! category: driver subroutine !! Revert override of stdout to default. Terminal by default. module procedure end_override_stdout_ end interface interface override_xml_work !! category: driver subroutine !! Override XML file unit number to a user-specified number. 21 by default. module procedure override_xml_work_ end interface interface end_override_xml_work !! category: driver subroutine !! Revert override of XML file unit number to default. 21 by default. module procedure end_override_xml_work_ end interface public :: get_xml_filename_work interface get_xml_filename_work !! category: driver subroutine !! Get filename of XML file. result.xml by default. module procedure get_xml_filename_work_ end interface public :: set_xml_filename_work interface set_xml_filename_work !! category: driver subroutine !! Set filename of XML file. result.xml by default. module procedure set_xml_filename_work_ end interface public :: get_message_index interface get_message_index !! category: driver subroutine !! Get number of failed assertion messages. module procedure get_message_index_ end interface public :: get_messages interface get_messages !! category: driver subroutine !! Get failed asssertion messages to *msgs*. module procedure get_messages_ end interface public :: get_message_array interface get_message_array !! category: driver subroutine !! Get failed asssertion messages to *msgs*. module procedure get_message_array_ end interface interface set_unit_name !! category: driver subroutine !! Set name of unit/case to *value*. module procedure set_case_name_ end interface interface set_case_name !! category: driver subroutine !! Set name of unit/case to *value*. module procedure set_case_name_ end interface interface get_unit_name !! category: driver subroutine !! Get name of unit/case to *value*. module procedure get_case_name_ end interface interface get_case_name !! category: driver subroutine !! Get name of unit/case to *value*. module procedure get_case_name_ end interface public :: fruit_finalize interface fruit_finalize !! category: driver subroutine !! Finalize FRUIT driver environment. module procedure fruit_finalize_ end interface public :: set_prefix interface set_prefix !! category: driver subroutine !! Set a common prefix for classname. Null by default. module procedure set_prefix_ end interface public :: get_prefix interface get_prefix !! category: driver subroutine !! Get a common prefix for classname. Null by default. module procedure get_prefix_ end interface interface get_assert_and_case_count !! category: driver subroutine !! Get statistics of cases and asserts. module procedure get_assert_and_case_count_ end interface public :: fruit_summary_table interface fruit_summary_table !! category: driver subroutine !! Print statistics of cases and asserts in default format. module procedure fruit_summary_table_ end interface public :: fruit_if_case_failed interface fruit_if_case_failed !! category: driver subroutine !! Return TRUE if any assert in current case has failed. module procedure fruit_if_case_failed_ end interface public :: fruit_hide_dots interface fruit_hide_dots !! category: driver subroutine !! Hide dots signifying test success on screen. Visible by default. module procedure fruit_hide_dots_ end interface public :: fruit_show_dots interface fruit_show_dots !! category: driver subroutine !! Show dots signifying test success on screen. Visible by default. module procedure fruit_show_dots_ end interface contains subroutine fruit_initialize ( rank ) !! category: driver subroutine !! Initialize FRUIT driver environment. integer , intent ( in ), optional :: rank logical :: if_write successful_assert_count = 0 failed_assert_count = 0 message_index = 1 message_index_from = 1 if_write = . true . if ( present ( rank )) then if ( rank /= 0 ) if_write = . false . endif if ( if_write ) then write ( stdout , * ) write ( stdout , * ) \"Test module initialized\" write ( stdout , * ) write ( stdout , * ) \"   . : successful assert,   F : failed assert \" write ( stdout , * ) endif !$omp critical     (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if ( . not . allocated ( message_array ) ) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) end subroutine fruit_initialize subroutine fruit_finalize_ !$omp critical     (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) if ( allocated ( message_array )) then deallocate ( message_array ) endif !$omp end critical (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) end subroutine fruit_finalize_ subroutine fruit_initialize_xml_ ( rank ) integer , optional , intent ( in ) :: rank logical :: rank_zero_or_single rank_zero_or_single = . true . if ( present ( rank )) then if ( rank /= 0 ) then rank_zero_or_single = . false . endif endif if ( rank_zero_or_single ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite \")' , advance = \"no\" ) write ( XML_OPEN , '(      \"errors=\"\"0\"\" \"   )' , advance = \"no\" ) write ( XML_OPEN , '(      \"tests=\"\"1\"\" \"    )' , advance = \"no\" ) write ( XML_OPEN , '(      \"failures=\"\"1\"\" \" )' , advance = \"no\" ) write ( XML_OPEN , '(      \"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) \"name of test suite\" write ( XML_OPEN , '(      \"id=\"\"1\"\">\")' ) write ( XML_OPEN , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & \"dummy_testcase\" , \"dummy_classname\" , \"0\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"      <failure type=\"\"failure\"\" message=\"\"\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"FRUIT did not generate regular content of result.xml.\" write ( XML_OPEN , '(a)' ) \"\"\"/>\" write ( XML_OPEN , '(\"    </testcase>\")' ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif open ( xml_work , FILE = xml_filename_work , action = \"write\" , status = 'replace' ) close ( xml_work ) end subroutine fruit_initialize_xml_ function case_delta_t () character ( len = STRLEN_T ) :: case_delta_t real :: delta_t integer :: case_time_to , time_rate , time_max call system_clock ( case_time_to , time_rate , time_max ) if ( time_rate > 0 ) then delta_t = real ( case_time_to - case_time_from ) / real ( time_rate ) if ( delta_t < 0 ) then delta_t = delta_t + real ( time_max ) / real ( time_rate ) endif else delta_t = 0 endif write ( case_delta_t , '(g12.4)' ) delta_t case_delta_t = adjustl ( case_delta_t ) end function case_delta_t subroutine case_passed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\"/>\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) close ( xml_work ) end subroutine case_passed_xml_ subroutine case_failed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname integer :: i , j character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) write ( xml_work , '(\"      <failure type=\"\"failure\"\" message=\"\"\")' , advance = \"no\" ) do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > MAX_NUM_FAILURES_IN_XML ) then write ( xml_work , '(\"(omit the rest)\")' , advance = \"no\" ) exit endif write ( xml_work , '(a)' , advance = \"no\" ) trim ( strip ( message_array ( i ))) if ( i == message_index - 1 ) then continue else write ( xml_work , '(\"&#xA;\")' , advance = \"no\" ) endif enddo write ( xml_work , '(\"\"\"/>\")' ) write ( xml_work , & & '(\"    </testcase>\")' ) close ( xml_work ) end subroutine case_failed_xml_ subroutine fruit_summary_xml_ character ( len = XML_LINE_LENGTH ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count full_count = int_to_str ( successful_case_count + failed_case_count ) fail_count = int_to_str ( failed_case_count ) open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) open ( xml_work , FILE = xml_filename_work ) do read ( xml_work , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( xml_work ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) end subroutine fruit_summary_xml_ function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str logical function fruit_if_case_failed_ () if ( failed_assert_count == 0 ) then fruit_if_case_failed_ = . false . return endif if ( case_passed ) then fruit_if_case_failed_ = . false . else fruit_if_case_failed_ = . true . endif end function fruit_if_case_failed_ subroutine fruit_show_dots_ if_show_dots = . true . end subroutine fruit_show_dots_ subroutine fruit_hide_dots_ if_show_dots = . false . end subroutine fruit_hide_dots_ ! Run a named test case subroutine run_test_case_named_ ( tc , tc_name ) interface subroutine tc () end subroutine end interface character ( * ), intent ( in ) :: tc_name integer :: initial_failed_assert_count initial_failed_assert_count = failed_assert_count ! Set the name of the unit test call set_case_name ( tc_name ) last_passed = . true . case_passed = . true . linechar_count = 0 ! reset linechar_count for each test case. message_index_from = message_index call system_clock ( case_time_from ) !$OMP BARRIER ! \"case_passed\" is true here. ! \"case_passed\" becomes .false. at the first fail of assertion call tc () !$OMP BARRIER if ( initial_failed_assert_count . eq . failed_assert_count ) then ! If no additional assertions failed during the run of this test case ! then the test case was successful successful_case_count = successful_case_count + 1 else failed_case_count = failed_case_count + 1 end if testCaseIndex = testCaseIndex + 1 ! Reset the name of the unit test back to the default call set_case_name ( DEFAULT_CASE_NAME ) end subroutine run_test_case_named_ ! Run an 'unnamed' test case subroutine run_test_case_ ( tc ) interface subroutine tc () end subroutine end interface call run_test_case_named_ ( tc , '_unnamed_' ) end subroutine run_test_case_ subroutine fruit_summary_ integer :: i write ( stdout , * ) write ( stdout , * ) write ( stdout , * ) '    Start of FRUIT summary: ' write ( stdout , * ) if ( failed_assert_count > 0 ) then write ( stdout , * ) 'Some tests failed!' else write ( stdout , * ) 'SUCCESSFUL!' end if write ( stdout , * ) if ( message_index > 1 ) then write ( stdout , * ) '  -- Failed assertion messages:' do i = 1 , message_index - 1 write ( stdout , \"(A)\" ) '   ' // trim ( strip ( message_array ( i ))) end do write ( stdout , * ) '  -- end of failed assertion messages.' write ( stdout , * ) else write ( stdout , * ) '  No messages ' end if if ( successful_assert_count + failed_assert_count /= 0 ) then call fruit_summary_table_ (& & successful_assert_count , failed_assert_count , & & successful_case_count , failed_case_count & &) end if write ( stdout , * ) '  -- end of FRUIT summary' end subroutine fruit_summary_ subroutine fruit_summary_table_ (& & succ_assert , fail_assert , & & succ_case , fail_case & &) integer , intent ( in ) :: succ_assert , fail_assert integer , intent ( in ) :: succ_case , fail_case write ( stdout , * ) 'Total asserts :   ' , succ_assert + fail_assert write ( stdout , * ) 'Successful    :   ' , succ_assert write ( stdout , * ) 'Failed        :   ' , fail_assert write ( stdout , '(\"Successful rate:   \",f6.2,\"%\")' ) real ( succ_assert ) * 10 0.0 / & real ( succ_assert + fail_assert ) write ( stdout , * ) write ( stdout , * ) 'Successful asserts / total asserts : [ ' ,& succ_assert , '/' , succ_assert + fail_assert , ' ]' write ( stdout , * ) 'Successful cases   / total cases   : [ ' , succ_case , '/' , & succ_case + fail_case , ' ]' end subroutine fruit_summary_table_ subroutine add_fail_ ( message ) character ( * ), intent ( in ), optional :: message call failed_assert_action ( 'none' , 'none' , message , if_is = . true .) end subroutine add_fail_ subroutine add_fail_unit_ ( unitName , message ) character ( * ), intent ( in ) :: unitName character ( * ), intent ( in ) :: message call add_fail_ ( \"[in \" // unitName // \"(fail)]: \" // message ) end subroutine add_fail_unit_ subroutine is_all_successful ( result ) !! category: driver subroutine !! Return true to *result* if any assert has failed till now. logical , intent ( out ) :: result result = ( failed_assert_count . eq . 0 ) end subroutine is_all_successful ! Private, helper routine to wrap lines of success/failed marks subroutine output_mark_ ( chr ) character ( 1 ), intent ( in ) :: chr !  integer, save :: linechar_count = 0 !  Definition of linechar_count is moved to module, !  so that it can be stashed and restored. !$omp critical      (FRUIT_OMP_ADD_OUTPUT_MARK) linechar_count = linechar_count + 1 if ( linechar_count . lt . MAX_MARKS_PER_LINE ) then write ( stdout , \"(A1)\" , ADVANCE = 'NO' ) chr else write ( stdout , \"(A1)\" , ADVANCE = 'YES' ) chr linechar_count = 0 endif !$omp end critical  (FRUIT_OMP_ADD_OUTPUT_MARK) end subroutine output_mark_ subroutine success_mark_ call output_mark_ ( '.' ) end subroutine success_mark_ subroutine failed_mark_ call output_mark_ ( 'F' ) end subroutine failed_mark_ subroutine increase_message_stack_ character ( len = MSG_LENGTH ) :: msg_swap_holder ( current_max ) if ( message_index > MAX_MSG_STACK_SIZE ) then return end if if ( message_index > current_max ) then msg_swap_holder ( 1 : current_max ) = message_array ( 1 : current_max ) deallocate ( message_array ) current_max = current_max + MSG_ARRAY_INCREMENT allocate ( message_array ( current_max )) message_array ( 1 : current_max - MSG_ARRAY_INCREMENT ) & = msg_swap_holder ( 1 : current_max - MSG_ARRAY_INCREMENT ) end if message_array ( message_index ) = msg if ( message_index == MAX_MSG_STACK_SIZE ) then message_array ( message_index ) = \"Max number of messages reached. Further messages suppressed.\" endif message_index = message_index + 1 if ( message_index > MAX_MSG_STACK_SIZE ) then write ( stdout , * ) \"Stop because there are too many error messages to put into stack.\" write ( stdout , * ) \"Try to increase MAX_MSG_STACK_SIZE if you really need so.\" end if end subroutine increase_message_stack_ subroutine get_xml_filename_work_ ( string ) character ( len = * ), intent ( out ) :: string string = trim ( xml_filename_work ) end subroutine get_xml_filename_work_ subroutine set_xml_filename_work_ ( string ) character ( len = * ), intent ( in ) :: string xml_filename_work = trim ( string ) end subroutine set_xml_filename_work_ function get_last_message () !! category: driver subroutine !! Return last message. character ( len = MSG_LENGTH ) :: get_last_message if ( message_index > 1 ) then get_last_message = strip ( message_array ( message_index - 1 ), MSG_LENGTH ) else get_last_message = '' end if end function get_last_message subroutine get_message_index_ ( index ) integer , intent ( out ) :: index index = message_index end subroutine get_message_index_ subroutine get_message_array_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i msgs (:) = \"\" do i = 1 , message_index - 1 msgs ( i ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_message_array_ subroutine get_messages_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i , j msgs (:) = \"\" do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > ubound ( msgs , 1 )) exit msgs ( j ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_messages_ subroutine get_total_count ( count ) !! category: driver subroutine !! Get total number of asserts. integer , intent ( out ) :: count count = successful_assert_count + failed_assert_count end subroutine get_total_count subroutine get_failed_count ( count ) !! category: driver subroutine !! Get number of assert failures. integer , intent ( out ) :: count count = failed_assert_count end subroutine get_failed_count subroutine add_success !! category: driver subroutine !! summary: Print message to screen on assert success and add to count. !! Print message to screen on assert success and add to count. !$omp critical     (FRUIT_OMP_ADD_SUCCESS) successful_assert_count = successful_assert_count + 1 last_passed = . true . !$omp end critical (FRUIT_OMP_ADD_SUCCESS) if ( if_show_dots ) then call success_mark_ endif end subroutine add_success subroutine failed_assert_action ( expected , got , message , if_is ) !! category: driver subroutine !! Print *message* to screen and take necessary actions for assert failure. character ( * ), intent ( in ) :: expected , got character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: if_is !$omp critical     (FRUIT_OMP_ADD_FAIL) if ( present ( if_is )) then call make_error_msg_ ( expected , got , if_is , message ) else call make_error_msg_ ( expected , got , . true ., message ) endif call increase_message_stack_ failed_assert_count = failed_assert_count + 1 last_passed = . false . case_passed = . false . !$omp end critical (FRUIT_OMP_ADD_FAIL) call failed_mark_ end subroutine failed_assert_action subroutine set_case_name_ ( value ) character ( * ), intent ( in ) :: value case_name = strip ( value , MSG_LENGTH ) end subroutine set_case_name_ subroutine get_case_name_ ( value ) character ( * ), intent ( out ) :: value value = strip ( case_name ) end subroutine get_case_name_ subroutine make_error_msg_ ( var1 , var2 , if_is , message ) character ( * ), intent ( in ) :: var1 , var2 logical , intent ( in ) :: if_is character ( * ), intent ( in ), optional :: message msg = '[' // trim ( strip ( case_name )) // ']: ' if ( if_is ) then msg = trim ( msg ) // 'Expected' else msg = trim ( msg ) // 'Expected Not' endif msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var1 )) // '], ' msg = trim ( msg ) // \" \" // 'Got' msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var2 )) // ']' if ( present ( message )) then msg = trim ( msg ) // '; User message: [' // trim ( message ) // ']' endif end subroutine make_error_msg_ function is_last_passed () !! category: driver subroutine !! Return true if last assert is successful in case. logical :: is_last_passed is_last_passed = last_passed end function is_last_passed function is_case_passed () !! category: driver subroutine !! Return true if all asserts are successful in case. logical :: is_case_passed is_case_passed = case_passed end function is_case_passed subroutine override_stdout_ ( write_unit , filename ) integer , intent ( in ) :: write_unit character ( len = * ), intent ( in ) :: filename stdout = write_unit open ( stdout , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_stdout_ subroutine override_xml_work_ ( new_unit , filename ) integer , intent ( in ) :: new_unit character ( len = * ), intent ( in ) :: filename xml_work = new_unit xml_filename_work = filename open ( xml_work , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_xml_work_ subroutine stash_test_suite !! category: driver subroutine !! Stash results of test case for later use. stashed_suite % successful_assert_count = successful_assert_count successful_assert_count = 0 stashed_suite % failed_assert_count = failed_assert_count failed_assert_count = 0 allocate ( stashed_suite % message_array ( current_max )) stashed_suite % message_array ( 1 : message_index ) = & & message_array ( 1 : message_index ) deallocate ( message_array ) allocate ( message_array ( MSG_ARRAY_INCREMENT )) stashed_suite % message_index = message_index message_index = 1 stashed_suite % message_index_from = message_index_from message_index_from = 1 stashed_suite % current_max = current_max current_max = 50 stashed_suite % successful_case_count = successful_case_count successful_case_count = 0 stashed_suite % failed_case_count = failed_case_count failed_case_count = 0 stashed_suite % testCaseIndex = testCaseIndex testCaseIndex = 1 stashed_suite % case_name = case_name case_name = DEFAULT_CASE_NAME stashed_suite % last_passed = last_passed last_passed = . false . stashed_suite % case_passed = case_passed case_passed = DEFAULT_CASE_PASSED stashed_suite % case_time_from = case_time_from case_time_from = 0 stashed_suite % linechar_count = linechar_count linechar_count = 0 stashed_suite % if_show_dots = if_show_dots if_show_dots = . true . end subroutine stash_test_suite subroutine restore_test_suite !! category: driver subroutine !! Restore results of test case for use. successful_assert_count = stashed_suite % successful_assert_count failed_assert_count = stashed_suite % failed_assert_count message_index = stashed_suite % message_index message_index_from = stashed_suite % message_index_from current_max = stashed_suite % current_max deallocate ( message_array ) allocate ( message_array ( current_max )) message_array ( 1 : message_index ) = & & stashed_suite % message_array ( 1 : message_index ) deallocate ( stashed_suite % message_array ) successful_case_count = stashed_suite % successful_case_count failed_case_count = stashed_suite % failed_case_count testCaseIndex = stashed_suite % testCaseIndex case_name = stashed_suite % case_name last_passed = stashed_suite % last_passed case_passed = stashed_suite % case_passed case_time_from = stashed_suite % case_time_from linechar_count = stashed_suite % linechar_count if_show_dots = stashed_suite % if_show_dots end subroutine restore_test_suite subroutine end_override_stdout_ close ( stdout ) stdout = STDOUT_DEFAULT end subroutine end_override_stdout_ subroutine end_override_xml_work_ close ( xml_work ) xml_work = XML_WORK_DEFAULT xml_filename_work = XML_FN_WORK_DEF end subroutine end_override_xml_work_ subroutine set_prefix_ ( str ) character ( len = * ), intent ( in ) :: str character ( len = len_trim ( str )) :: str2 str2 = trim ( adjustl ( str )) if ( len_trim ( str2 ) <= FRUIT_PREFIX_LEN_MAX ) then prefix = str2 else prefix = str2 ( 1 : FRUIT_PREFIX_LEN_MAX ) endif end subroutine set_prefix_ subroutine get_prefix_ ( str ) character ( len = * ), intent ( out ) :: str if ( len ( str ) <= len ( prefix )) then str = trim ( prefix ) else str = prefix endif end subroutine get_prefix_ subroutine get_assert_and_case_count_ ( fail_assert , suc_assert , fail_case , suc_case ) integer , intent ( out ) :: fail_assert , suc_assert , fail_case , suc_case fail_assert = failed_assert_count suc_assert = successful_assert_count fail_case = failed_case_count suc_case = successful_case_count end subroutine get_assert_and_case_count_ !-------------------------------------------------------------------------------- ! all assertions !-------------------------------------------------------------------------------- subroutine assert_true ( var1 , message ) !! Test that *var1* is true. logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message if ( var1 . eqv . . true .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . true .) end if end subroutine assert_true subroutine assert_false_ ( var1 , message ) logical , intent ( in ) :: var1 character ( len = * ), intent ( in ), optional :: message if ( var1 . eqv . . false .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . false .) endif end subroutine assert_false_ !====== begin of generated code ====== !------ 0d_logical ------ subroutine assert_eq_logical_ ( var1 , var2 , message ) !! display: none logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 . neqv . var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_logical_ !------ 1d_logical ------ subroutine assert_eq_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_logical_ !------ 2d_logical ------ subroutine assert_eq_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_logical_ !------ 0d_string ------ subroutine assert_eq_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_string_ !------ 1d_string ------ subroutine assert_eq_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_string_ !------ 2d_string ------ subroutine assert_eq_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_string_ !------ 0d_int ------ subroutine assert_eq_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 /= var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_int_ !------ 1d_int ------ subroutine assert_eq_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_int_ !------ 2d_int ------ subroutine assert_eq_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_int_ !------ 0d_real ------ subroutine assert_eq_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_ !------ 0d_real ------ subroutine assert_eq_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_in_range_ !------ 1d_real ------ subroutine assert_eq_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_ !------ 1d_real ------ subroutine assert_eq_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_in_range_ !------ 2d_real ------ subroutine assert_eq_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_ !------ 2d_real ------ subroutine assert_eq_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_in_range_ !------ 0d_double ------ subroutine assert_eq_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_ !------ 0d_double ------ subroutine assert_eq_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_in_range_ !------ 1d_double ------ subroutine assert_eq_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_ !------ 1d_double ------ subroutine assert_eq_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_in_range_ !------ 2d_double ------ subroutine assert_eq_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_ !------ 2d_double ------ subroutine assert_eq_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_in_range_ !------ 0d_complex ------ subroutine assert_eq_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_ !------ 0d_complex ------ subroutine assert_eq_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_in_range_ !------ 1d_complex ------ subroutine assert_eq_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_ !------ 1d_complex ------ subroutine assert_eq_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_in_range_ !------ 2d_complex ------ subroutine assert_eq_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_ !------ 2d_complex ------ subroutine assert_eq_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_in_range_ !------ 0d_logical ------ subroutine assert_not_equal_logical_ ( var1 , var2 , message ) logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 . neqv . var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_logical_ !------ 1d_logical ------ subroutine assert_not_equal_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_logical_ !------ 2d_logical ------ subroutine assert_not_equal_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_logical_ !------ 0d_string ------ subroutine assert_not_equal_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_string_ !------ 1d_string ------ subroutine assert_not_equal_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_string_ !------ 2d_string ------ subroutine assert_not_equal_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_string_ !------ 0d_int ------ subroutine assert_not_equal_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 /= var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_int_ !------ 1d_int ------ subroutine assert_not_equal_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_int_ !------ 2d_int ------ subroutine assert_not_equal_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_int_ !------ 0d_real ------ subroutine assert_not_equal_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_real_ !------ 0d_real ------ subroutine assert_not_equal_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_real_in_range_ !------ 1d_real ------ subroutine assert_not_equal_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_real_ !------ 1d_real ------ subroutine assert_not_equal_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_real_in_range_ !------ 2d_real ------ subroutine assert_not_equal_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_real_ !------ 2d_real ------ subroutine assert_not_equal_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_real_in_range_ !------ 0d_double ------ subroutine assert_not_equal_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_double_ !------ 0d_double ------ subroutine assert_not_equal_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_double_in_range_ !------ 1d_double ------ subroutine assert_not_equal_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_double_ !------ 1d_double ------ subroutine assert_not_equal_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_double_in_range_ !------ 2d_double ------ subroutine assert_not_equal_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_double_ !------ 2d_double ------ subroutine assert_not_equal_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_double_in_range_ !------ 0d_complex ------ subroutine assert_not_equal_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_complex_ !------ 0d_complex ------ subroutine assert_not_equal_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_complex_in_range_ !------ 1d_complex ------ subroutine assert_not_equal_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_complex_ !------ 1d_complex ------ subroutine assert_not_equal_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_1d_complex_in_range_ !------ 2d_complex ------ subroutine assert_not_equal_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_complex_ !------ 2d_complex ------ subroutine assert_not_equal_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equal_2d_complex_in_range_ !====== end of generated code ====== end module fruit","tags":"","loc":"sourcefile/naturalfruit.f90.html"},{"title":"fruit_mpi.f90 – naturalFRUIT","text":"This file depends on sourcefile~~fruit_mpi.f90~~EfferentGraph sourcefile~fruit_mpi.f90 fruit_mpi.f90 sourcefile~naturalfruit.f90 naturalfruit.f90 sourcefile~fruit_mpi.f90->sourcefile~naturalfruit.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fruit_mpi Source Code fruit_mpi.f90 Source Code module fruit_mpi !! display: none !! !! Documentation under construction use fruit use mpi implicit none private integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK = 21 character ( len = * ), parameter :: xml_filename = \"result.xml\" integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: FN_LENGTH = 50 public :: fruit_initialize_mpi_xml interface fruit_initialize_mpi_xml module procedure fruit_initialize_mpi_xml_ end interface public :: fruit_finalize_mpi interface fruit_finalize_mpi module procedure fruit_finalize_mpi_ end interface public :: fruit_summary_mpi interface fruit_summary_mpi module procedure fruit_summary_mpi_ end interface public :: fruit_summary_mpi_xml interface fruit_summary_mpi_xml module procedure fruit_summary_mpi_xml_ end interface contains subroutine fruit_initialize_mpi_xml_ ( rank ) integer , intent ( in ) :: rank character ( len = FN_LENGTH ) :: xml_filename_work write ( xml_filename_work , '(\"result_tmp_\", i5.5, \".xml\")' ) rank call set_xml_filename_work ( xml_filename_work ) call init_fruit_xml ( rank ) end subroutine fruit_initialize_mpi_xml_ subroutine fruit_finalize_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank if ( size < 0 ) print * , \"size negative\" if ( rank < 0 ) print * , \"rank negative\" call fruit_finalize end subroutine fruit_finalize_mpi_ subroutine fruit_summary_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank integer :: fail_assert_sum integer :: succ_assert_sum integer :: fail_case_sum integer :: succ_case_sum integer :: fail_assert integer :: succ_assert integer :: fail_case integer :: succ_case integer :: message_index integer :: num_msgs integer :: num_msgs_sum integer , allocatable :: num_msgs_rank (:) integer :: ierr integer :: i integer :: imsg integer :: status ( MPI_STATUS_SIZE ) integer , parameter :: MSG_LENGTH_HERE = 256 character ( len = MSG_LENGTH_HERE ), allocatable :: msgs (:) character ( len = MSG_LENGTH_HERE ), allocatable :: msgs_all (:) call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call get_message_index ( message_index ) num_msgs = message_index - 1 allocate ( msgs ( num_msgs )) call get_message_array ( msgs ) allocate ( num_msgs_rank ( size )) call MPI_Allgather (& & num_msgs , 1 , MPI_INTEGER , & & num_msgs_rank , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierr ) num_msgs_sum = sum ( num_msgs_rank (:)) allocate ( msgs_all ( num_msgs_sum )) ! array msgs_all: ! ! | msgs(:) of rank 0  | msgs(:) of rank 1   | msgs(:) of rank 2  | ! |                    |                     |                    | ! | num_msgs_rank(1)   |  num_msgs_rank(2)   | num_msgs_rank(3)   | ! |                    |                     |                    | ! |                    |                     |                    | !                       A                     A                  A !                       |                     |                  | !              sum(num_msgs_rank(1:1))+1      |             num_msgs_sum !                                    sum(num_msgs_rank(1:2))+1 if ( rank == 0 ) then msgs_all ( 1 : num_msgs ) = msgs ( 1 : num_msgs ) do i = 1 , size - 1 imsg = sum ( num_msgs_rank ( 1 : i )) + 1 call MPI_RECV (& & msgs_all ( imsg ), & & num_msgs_rank ( i + 1 ) * MSG_LENGTH_HERE , MPI_CHARACTER , & & i , 7 , MPI_COMM_WORLD , status , ierr ) enddo else call MPI_Send (& & msgs , & & num_msgs * MSG_LENGTH_HERE , MPI_CHARACTER , & & 0 , 7 , MPI_COMM_WORLD , ierr ) endif call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) if ( rank == 0 ) then write ( * , * ) write ( * , * ) write ( * , * ) '    Start of FRUIT summary: ' write ( * , * ) if ( fail_assert_sum > 0 ) then write ( * , * ) 'Some tests failed!' else write ( * , * ) 'SUCCESSFUL!' end if write ( * , * ) write ( * , * ) '  -- Failed assertion messages:' do i = 1 , num_msgs_sum write ( * , \"(A)\" ) '   ' // trim ( msgs_all ( i )) end do write ( * , * ) '  -- end of failed assertion messages.' write ( * , * ) if ( succ_assert_sum + fail_assert_sum /= 0 ) then call fruit_summary_table (& & succ_assert_sum , fail_assert_sum , & & succ_case_sum , fail_case_sum & &) endif write ( * , * ) '  -- end of FRUIT summary' endif end subroutine fruit_summary_mpi_ subroutine fruit_summary_mpi_xml_ ( size , rank ) integer , intent ( in ) :: size , rank character ( len = 1000 ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count character ( len = FN_LENGTH ) :: xml_filename_work character ( len = FN_LENGTH ), allocatable :: xml_filename_work_all (:) integer :: fail_assert , succ_assert , fail_case , succ_case integer :: fail_assert_sum , succ_assert_sum , fail_case_sum , succ_case_sum integer :: i integer :: status ( MPI_STATUS_SIZE ) integer :: ierr call get_xml_filename_work ( xml_filename_work ) allocate ( xml_filename_work_all ( size )) if ( rank /= 0 ) then call MPI_Send ( xml_filename_work , & & FN_LENGTH , MPI_CHARACTER , 0 , 8 , MPI_COMM_WORLD , ierr ) endif if ( rank == 0 ) then xml_filename_work_all ( 1 ) = xml_filename_work do i = 1 + 1 , size call MPI_RECV ( xml_filename_work_all ( i ), & & FN_LENGTH , MPI_CHARACTER , i - 1 , 8 , MPI_COMM_WORLD , status , ierr ) enddo endif call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) full_count = int_to_str ( succ_case_sum + fail_case_sum ) fail_count = int_to_str ( fail_case_sum ) if ( rank == 0 ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) do i = 1 , size open ( XML_WORK , FILE = xml_filename_work_all ( i )) do read ( XML_WORK , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( XML_WORK ) enddo write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif if ( size < 0 ) print * , \"size < 0\" end subroutine fruit_summary_mpi_xml_ function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str end module fruit_mpi","tags":"","loc":"sourcefile/fruit_mpi.f90.html"},{"title":"get_last_message – naturalFRUIT","text":"public function get_last_message() Return last message. Arguments None Return Value character(len=MSG_LENGTH) Contents Source Code get_last_message Source Code function get_last_message () !! category: driver subroutine !! Return last message. character ( len = MSG_LENGTH ) :: get_last_message if ( message_index > 1 ) then get_last_message = strip ( message_array ( message_index - 1 ), MSG_LENGTH ) else get_last_message = '' end if end function get_last_message","tags":"driver subroutine","loc":"proc/get_last_message.html"},{"title":"is_last_passed – naturalFRUIT","text":"public function is_last_passed() Return true if last assert is successful in case. Arguments None Return Value logical Contents Source Code is_last_passed Source Code function is_last_passed () !! category: driver subroutine !! Return true if last assert is successful in case. logical :: is_last_passed is_last_passed = last_passed end function is_last_passed","tags":"driver subroutine","loc":"proc/is_last_passed.html"},{"title":"is_case_passed – naturalFRUIT","text":"public function is_case_passed() Return true if all asserts are successful in case. Arguments None Return Value logical Contents Source Code is_case_passed Source Code function is_case_passed () !! category: driver subroutine !! Return true if all asserts are successful in case. logical :: is_case_passed is_case_passed = case_passed end function is_case_passed","tags":"driver subroutine","loc":"proc/is_case_passed.html"},{"title":"fruit_initialize – naturalFRUIT","text":"public subroutine fruit_initialize(rank) Initialize FRUIT driver environment. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank Contents Source Code fruit_initialize Source Code subroutine fruit_initialize ( rank ) !! category: driver subroutine !! Initialize FRUIT driver environment. integer , intent ( in ), optional :: rank logical :: if_write successful_assert_count = 0 failed_assert_count = 0 message_index = 1 message_index_from = 1 if_write = . true . if ( present ( rank )) then if ( rank /= 0 ) if_write = . false . endif if ( if_write ) then write ( stdout , * ) write ( stdout , * ) \"Test module initialized\" write ( stdout , * ) write ( stdout , * ) \"   . : successful assert,   F : failed assert \" write ( stdout , * ) endif !$omp critical     (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if ( . not . allocated ( message_array ) ) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) end subroutine fruit_initialize","tags":"driver subroutine","loc":"proc/fruit_initialize.html"},{"title":"is_all_successful – naturalFRUIT","text":"public subroutine is_all_successful(result) Return true to result if any assert has failed till now. Arguments Type Intent Optional Attributes Name logical, intent(out) :: result Contents Source Code is_all_successful Source Code subroutine is_all_successful ( result ) !! category: driver subroutine !! Return true to *result* if any assert has failed till now. logical , intent ( out ) :: result result = ( failed_assert_count . eq . 0 ) end subroutine is_all_successful","tags":"driver subroutine","loc":"proc/is_all_successful.html"},{"title":"get_total_count – naturalFRUIT","text":"public subroutine get_total_count(count) Get total number of asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Contents Source Code get_total_count Source Code subroutine get_total_count ( count ) !! category: driver subroutine !! Get total number of asserts. integer , intent ( out ) :: count count = successful_assert_count + failed_assert_count end subroutine get_total_count","tags":"driver subroutine","loc":"proc/get_total_count.html"},{"title":"get_failed_count – naturalFRUIT","text":"public subroutine get_failed_count(count) Get number of assert failures. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Contents Source Code get_failed_count Source Code subroutine get_failed_count ( count ) !! category: driver subroutine !! Get number of assert failures. integer , intent ( out ) :: count count = failed_assert_count end subroutine get_failed_count","tags":"driver subroutine","loc":"proc/get_failed_count.html"},{"title":"add_success – naturalFRUIT","text":"public subroutine add_success() Print message to screen on assert success and add to count. Arguments None Called by proc~~add_success~~CalledByGraph proc~add_success add_success proc~assert_true assert_true proc~assert_true->proc~add_success Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add_success Source Code subroutine add_success !! category: driver subroutine !! summary: Print message to screen on assert success and add to count. !! Print message to screen on assert success and add to count. !$omp critical     (FRUIT_OMP_ADD_SUCCESS) successful_assert_count = successful_assert_count + 1 last_passed = . true . !$omp end critical (FRUIT_OMP_ADD_SUCCESS) if ( if_show_dots ) then call success_mark_ endif end subroutine add_success","tags":"driver subroutine","loc":"proc/add_success.html"},{"title":"failed_assert_action – naturalFRUIT","text":"public subroutine failed_assert_action(expected, got, message, if_is) Print message to screen and take necessary actions for assert failure. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is Contents Source Code failed_assert_action Source Code subroutine failed_assert_action ( expected , got , message , if_is ) !! category: driver subroutine !! Print *message* to screen and take necessary actions for assert failure. character ( * ), intent ( in ) :: expected , got character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: if_is !$omp critical     (FRUIT_OMP_ADD_FAIL) if ( present ( if_is )) then call make_error_msg_ ( expected , got , if_is , message ) else call make_error_msg_ ( expected , got , . true ., message ) endif call increase_message_stack_ failed_assert_count = failed_assert_count + 1 last_passed = . false . case_passed = . false . !$omp end critical (FRUIT_OMP_ADD_FAIL) call failed_mark_ end subroutine failed_assert_action","tags":"driver subroutine","loc":"proc/failed_assert_action.html"},{"title":"stash_test_suite – naturalFRUIT","text":"public subroutine stash_test_suite() Stash results of test case for later use. Arguments None Contents Source Code stash_test_suite Source Code subroutine stash_test_suite !! category: driver subroutine !! Stash results of test case for later use. stashed_suite % successful_assert_count = successful_assert_count successful_assert_count = 0 stashed_suite % failed_assert_count = failed_assert_count failed_assert_count = 0 allocate ( stashed_suite % message_array ( current_max )) stashed_suite % message_array ( 1 : message_index ) = & & message_array ( 1 : message_index ) deallocate ( message_array ) allocate ( message_array ( MSG_ARRAY_INCREMENT )) stashed_suite % message_index = message_index message_index = 1 stashed_suite % message_index_from = message_index_from message_index_from = 1 stashed_suite % current_max = current_max current_max = 50 stashed_suite % successful_case_count = successful_case_count successful_case_count = 0 stashed_suite % failed_case_count = failed_case_count failed_case_count = 0 stashed_suite % testCaseIndex = testCaseIndex testCaseIndex = 1 stashed_suite % case_name = case_name case_name = DEFAULT_CASE_NAME stashed_suite % last_passed = last_passed last_passed = . false . stashed_suite % case_passed = case_passed case_passed = DEFAULT_CASE_PASSED stashed_suite % case_time_from = case_time_from case_time_from = 0 stashed_suite % linechar_count = linechar_count linechar_count = 0 stashed_suite % if_show_dots = if_show_dots if_show_dots = . true . end subroutine stash_test_suite","tags":"driver subroutine","loc":"proc/stash_test_suite.html"},{"title":"restore_test_suite – naturalFRUIT","text":"public subroutine restore_test_suite() Restore results of test case for use. Arguments None Contents Source Code restore_test_suite Source Code subroutine restore_test_suite !! category: driver subroutine !! Restore results of test case for use. successful_assert_count = stashed_suite % successful_assert_count failed_assert_count = stashed_suite % failed_assert_count message_index = stashed_suite % message_index message_index_from = stashed_suite % message_index_from current_max = stashed_suite % current_max deallocate ( message_array ) allocate ( message_array ( current_max )) message_array ( 1 : message_index ) = & & stashed_suite % message_array ( 1 : message_index ) deallocate ( stashed_suite % message_array ) successful_case_count = stashed_suite % successful_case_count failed_case_count = stashed_suite % failed_case_count testCaseIndex = stashed_suite % testCaseIndex case_name = stashed_suite % case_name last_passed = stashed_suite % last_passed case_passed = stashed_suite % case_passed case_time_from = stashed_suite % case_time_from linechar_count = stashed_suite % linechar_count if_show_dots = stashed_suite % if_show_dots end subroutine restore_test_suite","tags":"driver subroutine","loc":"proc/restore_test_suite.html"},{"title":"assert_true – naturalFRUIT","text":"public subroutine assert_true(var1, message) Test that var1 is true. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message Calls proc~~assert_true~~CallsGraph proc~assert_true assert_true proc~add_success add_success proc~assert_true->proc~add_success Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_true Source Code subroutine assert_true ( var1 , message ) !! Test that *var1* is true. logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message if ( var1 . eqv . . true .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . true .) end if end subroutine assert_true","tags":"","loc":"proc/assert_true.html"},{"title":"assert_false – naturalFRUIT","text":"public interface assert_false Test that var1 is false. Contents Module Procedures assert_false_ Module Procedures private subroutine assert_false_(var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_false.html"},{"title":"assert_equal – naturalFRUIT","text":"public interface assert_equal Test that var1 and var2 are equal. \n If the values do not compare equal, the test will fail. assert_equal invokes one of the following subroutines according \n to the number or type of arguments. Contents Module Procedures assert_eq_logical_ assert_eq_1d_logical_ assert_eq_2d_logical_ assert_eq_string_ assert_eq_1d_string_ assert_eq_2d_string_ assert_eq_int_ assert_eq_1d_int_ assert_eq_2d_int_ assert_eq_real_ assert_eq_real_in_range_ assert_eq_1d_real_ assert_eq_1d_real_in_range_ assert_eq_2d_real_ assert_eq_2d_real_in_range_ assert_eq_double_ assert_eq_double_in_range_ assert_eq_1d_double_ assert_eq_1d_double_in_range_ assert_eq_2d_double_ assert_eq_2d_double_in_range_ assert_eq_complex_ assert_eq_complex_in_range_ assert_eq_1d_complex_ assert_eq_1d_complex_in_range_ assert_eq_2d_complex_ assert_eq_2d_complex_in_range_ Module Procedures private subroutine assert_eq_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_equal.html"},{"title":"assert_not_equal – naturalFRUIT","text":"public interface assert_not_equal Test that var1 and var2 are not equal. \n If the values do compare equal, the test will fail. assert_not_equal invokes one of the following subroutines according \n to the number or type of arguments. Contents Module Procedures assert_not_equal_logical_ assert_not_equal_1d_logical_ assert_not_equal_2d_logical_ assert_not_equal_string_ assert_not_equal_1d_string_ assert_not_equal_2d_string_ assert_not_equal_int_ assert_not_equal_1d_int_ assert_not_equal_2d_int_ assert_not_equal_real_ assert_not_equal_real_in_range_ assert_not_equal_1d_real_ assert_not_equal_1d_real_in_range_ assert_not_equal_2d_real_ assert_not_equal_2d_real_in_range_ assert_not_equal_double_ assert_not_equal_double_in_range_ assert_not_equal_1d_double_ assert_not_equal_1d_double_in_range_ assert_not_equal_2d_double_ assert_not_equal_2d_double_in_range_ assert_not_equal_complex_ assert_not_equal_complex_in_range_ assert_not_equal_1d_complex_ assert_not_equal_1d_complex_in_range_ assert_not_equal_2d_complex_ assert_not_equal_2d_complex_in_range_ Module Procedures private subroutine assert_not_equal_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_not_equal.html"},{"title":"add_fail – naturalFRUIT","text":"public interface add_fail Print message to screen on assert failure and add to count. add_fail invokes one of the following subroutines according \n to number of arguments. Contents Module Procedures add_fail_ add_fail_unit_ Module Procedures private subroutine add_fail_(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_(unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message","tags":"driver subroutine","loc":"interface/add_fail.html"},{"title":"run_test_case – naturalFRUIT","text":"public interface run_test_case Run a specific test case. run_test_case invokes one of the following subroutines according \n to number of arguments. Contents Module Procedures run_test_case_ run_test_case_named_ Module Procedures private subroutine run_test_case_(tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_(tc, tc_name) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name","tags":"basket subroutine","loc":"interface/run_test_case.html"},{"title":"fruit_initialize_xml – naturalFRUIT","text":"public interface fruit_initialize_xml Initialize FRUIT driver environment for output to XML file Contents Module Procedures fruit_initialize_xml_ Module Procedures private subroutine fruit_initialize_xml_(rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank","tags":"driver subroutine","loc":"interface/fruit_initialize_xml.html"},{"title":"fruit_summary – naturalFRUIT","text":"public interface fruit_summary Summarize FRUIT test results to screen. Contents Module Procedures fruit_summary_ Module Procedures private subroutine fruit_summary_() Arguments None","tags":"driver subroutine","loc":"interface/fruit_summary.html"},{"title":"fruit_summary_xml – naturalFRUIT","text":"public interface fruit_summary_xml Summarize FRUIT test results in XML format to result.xml file. Contents Module Procedures fruit_summary_xml_ Module Procedures private subroutine fruit_summary_xml_() Arguments None","tags":"driver subroutine","loc":"interface/fruit_summary_xml.html"},{"title":"case_passed_xml – naturalFRUIT","text":"public interface case_passed_xml Write to XML file a passed case. Contents Module Procedures case_passed_xml_ Module Procedures private subroutine case_passed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname","tags":"driver subroutine","loc":"interface/case_passed_xml.html"},{"title":"case_failed_xml – naturalFRUIT","text":"public interface case_failed_xml Write to XML file a failed case. Contents Module Procedures case_failed_xml_ Module Procedures private subroutine case_failed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname","tags":"driver subroutine","loc":"interface/case_failed_xml.html"},{"title":"override_stdout – naturalFRUIT","text":"public interface override_stdout Override stdout to a user-specified file. Terminal by default. Contents Module Procedures override_stdout_ Module Procedures private subroutine override_stdout_(write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename","tags":"driver subroutine","loc":"interface/override_stdout.html"},{"title":"end_override_stdout – naturalFRUIT","text":"public interface end_override_stdout Revert override of stdout to default. Terminal by default. Contents Module Procedures end_override_stdout_ Module Procedures private subroutine end_override_stdout_() Arguments None","tags":"driver subroutine","loc":"interface/end_override_stdout.html"},{"title":"override_xml_work – naturalFRUIT","text":"public interface override_xml_work Override XML file unit number to a user-specified number. 21 by default. Contents Module Procedures override_xml_work_ Module Procedures private subroutine override_xml_work_(new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename","tags":"driver subroutine","loc":"interface/override_xml_work.html"},{"title":"end_override_xml_work – naturalFRUIT","text":"public interface end_override_xml_work Revert override of XML file unit number to default. 21 by default. Contents Module Procedures end_override_xml_work_ Module Procedures private subroutine end_override_xml_work_() Arguments None","tags":"driver subroutine","loc":"interface/end_override_xml_work.html"},{"title":"get_xml_filename_work – naturalFRUIT","text":"public interface get_xml_filename_work Get filename of XML file. result.xml by default. Contents Module Procedures get_xml_filename_work_ Module Procedures private subroutine get_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string","tags":"driver subroutine","loc":"interface/get_xml_filename_work.html"},{"title":"set_xml_filename_work – naturalFRUIT","text":"public interface set_xml_filename_work Set filename of XML file. result.xml by default. Contents Module Procedures set_xml_filename_work_ Module Procedures private subroutine set_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string","tags":"driver subroutine","loc":"interface/set_xml_filename_work.html"},{"title":"get_message_index – naturalFRUIT","text":"public interface get_message_index Get number of failed assertion messages. Contents Module Procedures get_message_index_ Module Procedures private subroutine get_message_index_(index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index","tags":"driver subroutine","loc":"interface/get_message_index.html"},{"title":"get_messages – naturalFRUIT","text":"public interface get_messages Get failed asssertion messages to msgs . Contents Module Procedures get_messages_ Module Procedures private subroutine get_messages_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:)","tags":"driver subroutine","loc":"interface/get_messages.html"},{"title":"get_message_array – naturalFRUIT","text":"public interface get_message_array Get failed asssertion messages to msgs . Contents Module Procedures get_message_array_ Module Procedures private subroutine get_message_array_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:)","tags":"driver subroutine","loc":"interface/get_message_array.html"},{"title":"set_unit_name – naturalFRUIT","text":"public interface set_unit_name Set name of unit/case to value . Contents Module Procedures set_case_name_ Module Procedures private subroutine set_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value","tags":"driver subroutine","loc":"interface/set_unit_name.html"},{"title":"set_case_name – naturalFRUIT","text":"public interface set_case_name Set name of unit/case to value . Contents Module Procedures set_case_name_ Module Procedures private subroutine set_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value","tags":"driver subroutine","loc":"interface/set_case_name.html"},{"title":"get_unit_name – naturalFRUIT","text":"public interface get_unit_name Get name of unit/case to value . Contents Module Procedures get_case_name_ Module Procedures private subroutine get_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value","tags":"driver subroutine","loc":"interface/get_unit_name.html"},{"title":"get_case_name – naturalFRUIT","text":"public interface get_case_name Get name of unit/case to value . Contents Module Procedures get_case_name_ Module Procedures private subroutine get_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value","tags":"driver subroutine","loc":"interface/get_case_name.html"},{"title":"fruit_finalize – naturalFRUIT","text":"public interface fruit_finalize Finalize FRUIT driver environment. Contents Module Procedures fruit_finalize_ Module Procedures private subroutine fruit_finalize_() Arguments None","tags":"driver subroutine","loc":"interface/fruit_finalize.html"},{"title":"set_prefix – naturalFRUIT","text":"public interface set_prefix Set a common prefix for classname. Null by default. Contents Module Procedures set_prefix_ Module Procedures private subroutine set_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"driver subroutine","loc":"interface/set_prefix.html"},{"title":"get_prefix – naturalFRUIT","text":"public interface get_prefix Get a common prefix for classname. Null by default. Contents Module Procedures get_prefix_ Module Procedures private subroutine get_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str","tags":"driver subroutine","loc":"interface/get_prefix.html"},{"title":"get_assert_and_case_count – naturalFRUIT","text":"public interface get_assert_and_case_count Get statistics of cases and asserts. Contents Module Procedures get_assert_and_case_count_ Module Procedures private subroutine get_assert_and_case_count_(fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case","tags":"driver subroutine","loc":"interface/get_assert_and_case_count.html"},{"title":"fruit_summary_table – naturalFRUIT","text":"public interface fruit_summary_table Print statistics of cases and asserts in default format. Contents Module Procedures fruit_summary_table_ Module Procedures private subroutine fruit_summary_table_(succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case","tags":"driver subroutine","loc":"interface/fruit_summary_table.html"},{"title":"fruit_if_case_failed – naturalFRUIT","text":"public interface fruit_if_case_failed Return TRUE if any assert in current case has failed. Contents Module Procedures fruit_if_case_failed_ Module Procedures private function fruit_if_case_failed_() Arguments None Return Value logical","tags":"driver subroutine","loc":"interface/fruit_if_case_failed.html"},{"title":"fruit_hide_dots – naturalFRUIT","text":"public interface fruit_hide_dots Hide dots signifying test success on screen. Visible by default. Contents Module Procedures fruit_hide_dots_ Module Procedures private subroutine fruit_hide_dots_() Arguments None","tags":"driver subroutine","loc":"interface/fruit_hide_dots.html"},{"title":"fruit_show_dots – naturalFRUIT","text":"public interface fruit_show_dots Show dots signifying test success on screen. Visible by default. Contents Module Procedures fruit_show_dots_ Module Procedures private subroutine fruit_show_dots_() Arguments None","tags":"driver subroutine","loc":"interface/fruit_show_dots.html"},{"title":"fruit_util – naturalFRUIT","text":"A utility module for fruit to use. Used by module~~fruit_util~~UsedByGraph module~fruit_util fruit_util module~fruit fruit module~fruit->module~fruit_util module~fruit_mpi fruit_mpi module~fruit_mpi->module~fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/fruit_util.html"},{"title":"fruit – naturalFRUIT","text":"Uses fruit_util module~~fruit~~UsesGraph module~fruit fruit module~fruit_util fruit_util module~fruit->module~fruit_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fruit~~UsedByGraph module~fruit fruit module~fruit_mpi fruit_mpi module~fruit_mpi->module~fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables FRUIT_PREFIX_LEN_MAX Interfaces assert_false assert_equal assert_not_equal add_fail run_test_case fruit_initialize_xml fruit_summary fruit_summary_xml case_passed_xml case_failed_xml override_stdout end_override_stdout override_xml_work end_override_xml_work get_xml_filename_work set_xml_filename_work get_message_index get_messages get_message_array set_unit_name set_case_name get_unit_name get_case_name fruit_finalize set_prefix get_prefix get_assert_and_case_count fruit_summary_table fruit_if_case_failed fruit_hide_dots fruit_show_dots Functions get_last_message is_last_passed is_case_passed Subroutines fruit_initialize is_all_successful get_total_count get_failed_count add_success failed_assert_action stash_test_suite restore_test_suite assert_true Variables Type Visibility Attributes Name Initial integer, public, parameter :: FRUIT_PREFIX_LEN_MAX = 50 Interfaces public interface assert_false Test that var1 is false. private subroutine assert_false_(var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message public interface assert_equal Test that var1 and var2 are equal. Read more… private subroutine assert_eq_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface assert_not_equal Test that var1 and var2 are not equal. Read more… private subroutine assert_not_equal_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equal_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equal_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equal_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface add_fail Print message to screen on assert failure and add to count. Read more… private subroutine add_fail_(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_(unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message public interface run_test_case Run a specific test case. Read more… private subroutine run_test_case_(tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_(tc, tc_name) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name public interface fruit_initialize_xml Initialize FRUIT driver environment for output to XML file private subroutine fruit_initialize_xml_(rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank public interface fruit_summary Summarize FRUIT test results to screen. private subroutine fruit_summary_() Arguments None public interface fruit_summary_xml Summarize FRUIT test results in XML format to result.xml file. private subroutine fruit_summary_xml_() Arguments None public interface case_passed_xml Write to XML file a passed case. private subroutine case_passed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public interface case_failed_xml Write to XML file a failed case. private subroutine case_failed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public interface override_stdout Override stdout to a user-specified file. Terminal by default. private subroutine override_stdout_(write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename public interface end_override_stdout Revert override of stdout to default. Terminal by default. private subroutine end_override_stdout_() Arguments None public interface override_xml_work Override XML file unit number to a user-specified number. 21 by default. private subroutine override_xml_work_(new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename public interface end_override_xml_work Revert override of XML file unit number to default. 21 by default. private subroutine end_override_xml_work_() Arguments None public interface get_xml_filename_work Get filename of XML file. result.xml by default. private subroutine get_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string public interface set_xml_filename_work Set filename of XML file. result.xml by default. private subroutine set_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public interface get_message_index Get number of failed assertion messages. private subroutine get_message_index_(index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index public interface get_messages Get failed asssertion messages to msgs . private subroutine get_messages_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public interface get_message_array Get failed asssertion messages to msgs . private subroutine get_message_array_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public interface set_unit_name Set name of unit/case to value . private subroutine set_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value public interface set_case_name Set name of unit/case to value . private subroutine set_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value public interface get_unit_name Get name of unit/case to value . private subroutine get_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value public interface get_case_name Get name of unit/case to value . private subroutine get_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value public interface fruit_finalize Finalize FRUIT driver environment. private subroutine fruit_finalize_() Arguments None public interface set_prefix Set a common prefix for classname. Null by default. private subroutine set_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str public interface get_prefix Get a common prefix for classname. Null by default. private subroutine get_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str public interface get_assert_and_case_count Get statistics of cases and asserts. private subroutine get_assert_and_case_count_(fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case public interface fruit_summary_table Print statistics of cases and asserts in default format. private subroutine fruit_summary_table_(succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case public interface fruit_if_case_failed Return TRUE if any assert in current case has failed. private function fruit_if_case_failed_() Arguments None Return Value logical public interface fruit_hide_dots Hide dots signifying test success on screen. Visible by default. private subroutine fruit_hide_dots_() Arguments None public interface fruit_show_dots Show dots signifying test success on screen. Visible by default. private subroutine fruit_show_dots_() Arguments None Functions public function get_last_message () Category driver subroutine Return last message. Arguments None Return Value character(len=MSG_LENGTH) public function is_last_passed () Category driver subroutine Return true if last assert is successful in case. Arguments None Return Value logical public function is_case_passed () Category driver subroutine Return true if all asserts are successful in case. Arguments None Return Value logical Subroutines public subroutine fruit_initialize (rank) Category driver subroutine Initialize FRUIT driver environment. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank public subroutine is_all_successful (result) Category driver subroutine Return true to result if any assert has failed till now. Arguments Type Intent Optional Attributes Name logical, intent(out) :: result public subroutine get_total_count (count) Category driver subroutine Get total number of asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine get_failed_count (count) Category driver subroutine Get number of assert failures. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine add_success () Category driver subroutine Print message to screen on assert success and add to count. Arguments None public subroutine failed_assert_action (expected, got, message, if_is) Category driver subroutine Print message to screen and take necessary actions for assert failure. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is public subroutine stash_test_suite () Category driver subroutine Stash results of test case for later use. Arguments None public subroutine restore_test_suite () Category driver subroutine Restore results of test case for use. Arguments None public subroutine assert_true (var1, message) Test that var1 is true. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message","tags":"","loc":"module/fruit.html"},{"title":"fruit_mpi – naturalFRUIT","text":"Documentation under construction Uses fruit mpi module~~fruit_mpi~~UsesGraph module~fruit_mpi fruit_mpi mpi mpi module~fruit_mpi->mpi module~fruit fruit module~fruit_mpi->module~fruit module~fruit_util fruit_util module~fruit->module~fruit_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/fruit_mpi.html"},{"title":"Documentation – naturalFRUIT","text":"naturalFRUIT naturalFruit is a unit testing framework developed for Fortran programs maintained in pure Fortran. It is derived from the original Fortran Unit Test Framework (FRUIT) . The major objectives that naturalFRUIT aims to achieve are: 1. Independance from other programming languages : The philosophy behind maintaining naturalFruit as a separate project is to ensure that a Fortran programmer shouldn't need to learn a whole new programming language for the sake of testing Fortran code. 2. Documentation : Clear and updated documentation and tutorials based on the auto-generated FORD framework. 3. Improvements : Constant improvements in phase with the latest Fortran versions. Warning Documentation, tutorials and source code are under active development","tags":"","loc":"page//index.html"},{"title":"Deprecated Procedures – naturalFRUIT","text":"The following procedures have been deprecated or replaced with other procedures to maintain consistency and/or accuracy. Note Table under construction Consistency Replaced by Notes addFail add_fail Consistency addSuccess add_success Consistency assert_equals assert_equal Consistency assertEquals assert_equal Consistency assert_not_equals assert_not_equal Consistency assertNotEquals assert_not_equal Consistency assertTrue assert_true Consistency getFailedCount get_failed_count Consistency getTestSummary fruit_summary Consistency getTotalCount get_total_count Consistency isAllSuccessful is_all_successful Consistency init_fruit fruit_initialize Consistency initializeFruit fruit_initialize Consistency runTestCase run_test_case Consistency","tags":"","loc":"page/deprecated/index.html"}]}