var tipuesearch = {"pages":[{"title":" naturalFRUIT ","text":"naturalFRUIT A purely Fortran based project derived from the original Fortran Unit Test Framework (FRUIT) Documentation available here . Developer Info Cibin Joseph Ph.D. student at IIT Madras, India.","tags":"home","loc":"index.html"},{"title":"fruit_mpi.f90 – naturalFRUIT","text":"This file depends on sourcefile~~fruit_mpi.f90~~EfferentGraph sourcefile~fruit_mpi.f90 fruit_mpi.f90 sourcefile~fruit.f90 fruit.f90 sourcefile~fruit_mpi.f90->sourcefile~fruit.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fruit_mpi Source Code fruit_mpi.f90 Source Code module fruit_mpi use fruit use mpi implicit none private integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK = 21 character ( len = * ), parameter :: xml_filename = \"result.xml\" integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: FN_LENGTH = 50 public :: fruit_init_mpi_xml interface fruit_init_mpi_xml module procedure fruit_init_mpi_xml_ end interface public :: fruit_finalize_mpi interface fruit_finalize_mpi module procedure fruit_finalize_mpi_ end interface public :: fruit_summary_mpi interface fruit_summary_mpi module procedure fruit_summary_mpi_ end interface public :: fruit_summary_mpi_xml interface fruit_summary_mpi_xml module procedure fruit_summary_mpi_xml_ end interface contains subroutine fruit_init_mpi_xml_ ( rank ) integer , intent ( in ) :: rank character ( len = FN_LENGTH ) :: xml_filename_work write ( xml_filename_work , '(\"result_tmp_\", i5.5, \".xml\")' ) rank call set_xml_filename_work ( xml_filename_work ) call init_fruit_xml ( rank ) end subroutine fruit_init_mpi_xml_ subroutine fruit_finalize_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank if ( size < 0 ) print * , \"size negative\" if ( rank < 0 ) print * , \"rank negative\" call fruit_finalize end subroutine fruit_finalize_mpi_ subroutine fruit_summary_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank integer :: fail_assert_sum integer :: succ_assert_sum integer :: fail_case_sum integer :: succ_case_sum integer :: fail_assert integer :: succ_assert integer :: fail_case integer :: succ_case integer :: message_index integer :: num_msgs integer :: num_msgs_sum integer , allocatable :: num_msgs_rank (:) integer :: ierr integer :: i integer :: imsg integer :: status ( MPI_STATUS_SIZE ) integer , parameter :: MSG_LENGTH_HERE = 256 character ( len = MSG_LENGTH_HERE ), allocatable :: msgs (:) character ( len = MSG_LENGTH_HERE ), allocatable :: msgs_all (:) call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call get_message_index ( message_index ) num_msgs = message_index - 1 allocate ( msgs ( num_msgs )) call get_message_array ( msgs ) allocate ( num_msgs_rank ( size )) call MPI_Allgather (& & num_msgs , 1 , MPI_INTEGER , & & num_msgs_rank , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierr ) num_msgs_sum = sum ( num_msgs_rank (:)) allocate ( msgs_all ( num_msgs_sum )) ! array msgs_all: ! ! | msgs(:) of rank 0  | msgs(:) of rank 1   | msgs(:) of rank 2  | ! |                    |                     |                    | ! | num_msgs_rank(1)   |  num_msgs_rank(2)   | num_msgs_rank(3)   | ! |                    |                     |                    | ! |                    |                     |                    | !                       A                     A                  A !                       |                     |                  | !              sum(num_msgs_rank(1:1))+1      |             num_msgs_sum !                                    sum(num_msgs_rank(1:2))+1 if ( rank == 0 ) then msgs_all ( 1 : num_msgs ) = msgs ( 1 : num_msgs ) do i = 1 , size - 1 imsg = sum ( num_msgs_rank ( 1 : i )) + 1 call MPI_RECV (& & msgs_all ( imsg ), & & num_msgs_rank ( i + 1 ) * MSG_LENGTH_HERE , MPI_CHARACTER , & & i , 7 , MPI_COMM_WORLD , status , ierr ) enddo else call MPI_Send (& & msgs , & & num_msgs * MSG_LENGTH_HERE , MPI_CHARACTER , & & 0 , 7 , MPI_COMM_WORLD , ierr ) endif call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) if ( rank == 0 ) then write ( * , * ) write ( * , * ) write ( * , * ) '    Start of FRUIT summary: ' write ( * , * ) if ( fail_assert_sum > 0 ) then write ( * , * ) 'Some tests failed!' else write ( * , * ) 'SUCCESSFUL!' end if write ( * , * ) write ( * , * ) '  -- Failed assertion messages:' do i = 1 , num_msgs_sum write ( * , \"(A)\" ) '   ' // trim ( msgs_all ( i )) end do write ( * , * ) '  -- end of failed assertion messages.' write ( * , * ) if ( succ_assert_sum + fail_assert_sum /= 0 ) then call fruit_summary_table (& & succ_assert_sum , fail_assert_sum , & & succ_case_sum , fail_case_sum & &) endif write ( * , * ) '  -- end of FRUIT summary' endif end subroutine fruit_summary_mpi_ subroutine fruit_summary_mpi_xml_ ( size , rank ) integer , intent ( in ) :: size , rank character ( len = 1000 ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count character ( len = FN_LENGTH ) :: xml_filename_work character ( len = FN_LENGTH ), allocatable :: xml_filename_work_all (:) integer :: fail_assert , succ_assert , fail_case , succ_case integer :: fail_assert_sum , succ_assert_sum , fail_case_sum , succ_case_sum integer :: i integer :: status ( MPI_STATUS_SIZE ) integer :: ierr call get_xml_filename_work ( xml_filename_work ) allocate ( xml_filename_work_all ( size )) if ( rank /= 0 ) then call MPI_Send ( xml_filename_work , & & FN_LENGTH , MPI_CHARACTER , 0 , 8 , MPI_COMM_WORLD , ierr ) endif if ( rank == 0 ) then xml_filename_work_all ( 1 ) = xml_filename_work do i = 1 + 1 , size call MPI_RECV ( xml_filename_work_all ( i ), & & FN_LENGTH , MPI_CHARACTER , i - 1 , 8 , MPI_COMM_WORLD , status , ierr ) enddo endif call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) full_count = int_to_str ( succ_case_sum + fail_case_sum ) fail_count = int_to_str ( fail_case_sum ) if ( rank == 0 ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) do i = 1 , size open ( XML_WORK , FILE = xml_filename_work_all ( i )) do read ( XML_WORK , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( XML_WORK ) enddo write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif if ( size < 0 ) print * , \"size < 0\" end subroutine fruit_summary_mpi_xml_ function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str end module fruit_mpi","tags":"","loc":"sourcefile/fruit_mpi.f90.html"},{"title":"fruit.f90 – naturalFRUIT","text":"Files dependent on this one sourcefile~~fruit.f90~~AfferentGraph sourcefile~fruit.f90 fruit.f90 sourcefile~fruit_mpi.f90 fruit_mpi.f90 sourcefile~fruit_mpi.f90->sourcefile~fruit.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fruit_util fruit Source Code fruit.f90 Source Code ! Copyright (c) 2005-2010, 2012-2013, Andrew Hang Chen and contributors, ! All rights reserved. ! Licensed under the 3-clause BSD license. !------------------------ ! FORTRAN unit test utility ! ! Author: Andrew H. Chen meihome @at@ gmail.com !------------------------ ! ! Unit test framework for FORTRAN.  (FoRtran UnIT) ! ! This package is to perform unit test for FORTRAN subroutines ! ! The method used most are: assert_true, assert_equals ! ! Coding convention: !   1) All methods must be exposed by interface.  i.e. interface init_fruit !   2) Variable and methods are lower case connected with underscores.  i.e. init_fruit, and !      failed_assert_count ! module fruit_util private public :: equals , to_s , strip interface equals module procedure equalEpsilon module procedure floatEqual module procedure integerEqual module procedure doublePrecisionEqual module procedure stringEqual module procedure logicalEqual end interface interface to_s module procedure to_s_int_ module procedure to_s_real_ module procedure to_s_logical_ module procedure to_s_double_ module procedure to_s_complex_ module procedure to_s_double_complex_ module procedure to_s_string_ end interface interface strip module procedure strip_ module procedure strip_length_ end interface contains function to_s_int_ ( value ) implicit none character ( len = 500 ) :: to_s_int_ integer , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_int_ = adjustl ( trim ( result )) end function to_s_int_ function to_s_real_ ( value ) implicit none character ( len = 500 ) :: to_s_real_ real , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_real_ = adjustl ( trim ( result )) end function to_s_real_ function to_s_double_ ( value ) implicit none character ( len = 500 ) :: to_s_double_ double precision , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_ = adjustl ( trim ( result )) end function to_s_double_ function to_s_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_complex_ complex , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_complex_ = adjustl ( trim ( result )) end function to_s_complex_ function to_s_double_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_double_complex_ complex ( kind = kind ( 1.0D0 )), intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_complex_ = adjustl ( trim ( result )) end function to_s_double_complex_ function to_s_logical_ ( value ) implicit none character ( len = 500 ) :: to_s_logical_ logical , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_logical_ = adjustl ( trim ( result )) end function to_s_logical_ function to_s_string_ ( value ) implicit none character ( len = 500 ) :: to_s_string_ character ( len =* ), intent ( in ) :: value to_s_string_ = value end function to_s_string_ function strip_ ( value ) implicit none character ( len = 500 ) :: strip_ character ( len =* ), intent ( in ) :: value strip_ = trim ( adjustl ( value )) end function strip_ function strip_length_ ( value , length ) implicit none character ( len =* ), intent ( in ) :: value integer , intent ( in ) :: length character ( len = length ) :: strip_length_ strip_length_ = trim ( adjustl ( value )) end function strip_length_ !------------------------ ! test if 2 values are close !------------------------ !logical function equals (number1, number2) !  real,  intent (in) :: number1, number2 ! !  return equalEpsilon (number1, number2, epsilon(number1)) ! !end function equals function equalEpsilon ( number1 , number2 , epsilon ) result ( resultValue ) real , intent ( in ) :: number1 , number2 , epsilon logical :: resultValue resultValue = . false . ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function equalEpsilon function floatEqual ( number1 , number2 ) result ( resultValue ) real , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function floatEqual function doublePrecisionEqual ( number1 , number2 ) result ( resultValue ) double precision , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 !epsilon = epsilon (number1) ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function doublePrecisionEqual function integerEqual ( number1 , number2 ) result ( resultValue ) integer , intent ( in ) :: number1 , number2 logical :: resultValue resultValue = . false . if ( number1 . eq . number2 ) then resultValue = . true . else resultValue = . false . end if end function integerEqual function stringEqual ( str1 , str2 ) result ( resultValue ) character ( * ) , intent ( in ) :: str1 , str2 logical :: resultValue resultValue = . false . if ( str1 . eq . str2 ) then resultValue = . true . end if end function stringEqual function logicalEqual ( l1 , l2 ) result ( resultValue ) logical , intent ( in ) :: l1 , l2 logical :: resultValue resultValue = . false . if ( l1 . eqv . l2 ) then resultValue = . true . end if end function logicalEqual end module fruit_util module fruit use fruit_util implicit none private integer , parameter :: STDOUT_DEFAULT = 6 integer :: stdout = STDOUT_DEFAULT integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK_DEFAULT = 21 integer :: xml_work = XML_WORK_DEFAULT character ( len = * ), parameter :: xml_filename = \"result.xml\" character ( len = * ), parameter :: XML_FN_WORK_DEF = \"result_tmp.xml\" character ( len = 50 ) :: xml_filename_work = XML_FN_WORK_DEF integer , parameter :: MAX_NUM_FAILURES_IN_XML = 10 integer , parameter :: XML_LINE_LENGTH = 2670 !! xml_line_length >= max_num_failures_in_xml * (msg_length + 1) + 50 integer , parameter :: STRLEN_T = 12 integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: MSG_LENGTH = 256 integer , parameter :: MAX_MSG_STACK_SIZE = 2000 integer , parameter :: MSG_ARRAY_INCREMENT = 50 integer , parameter :: MAX_MARKS_PER_LINE = 78 character ( * ), parameter :: DEFAULT_CASE_NAME = '_not_set_' logical , private , parameter :: DEFAULT_CASE_PASSED = . true . !---------- save ---------- integer , private , save :: successful_assert_count = 0 integer , private , save :: failed_assert_count = 0 integer , private , save :: message_index = 1 integer , private , save :: message_index_from = 1 integer , private , save :: current_max = 50 character ( len = MSG_LENGTH ), private , allocatable :: message_array (:) character ( len = MSG_LENGTH ), private , save :: msg = '[unit name not set from set_name]: ' character ( len = MSG_LENGTH ), private , save :: case_name = DEFAULT_CASE_NAME integer , private , save :: successful_case_count = 0 integer , private , save :: failed_case_count = 0 integer , private , save :: testCaseIndex = 1 logical , private , save :: last_passed = . false . logical , private , save :: case_passed = DEFAULT_CASE_PASSED integer , private , save :: case_time_from = 0 integer , private , save :: linechar_count = 0 logical , private , save :: if_show_dots = . true . integer , parameter :: FRUIT_PREFIX_LEN_MAX = 50 character ( len = FRUIT_PREFIX_LEN_MAX ) :: prefix = \"\" !---------- save ---------- type ty_stack integer :: successful_assert_count integer :: failed_assert_count integer :: message_index integer :: message_index_from integer :: current_max character ( len = MSG_LENGTH ), pointer :: message_array (:) character ( len = MSG_LENGTH ) :: case_name !  = DEFAULT_CASE_NAME integer :: successful_case_count integer :: failed_case_count integer :: testCaseIndex logical :: last_passed logical :: case_passed = DEFAULT_CASE_PASSED integer :: case_time_from integer :: linechar_count logical :: if_show_dots end type ty_stack type ( ty_stack ), save :: stashed_suite public :: & init_fruit public :: & get_last_message , & is_last_passed , & is_case_passed , & add_success , addSuccess , & set_unit_name , get_unit_name , & set_case_name , get_case_name , & failed_assert_action , get_total_count , getTotalCount , & get_failed_count , getFailedCount , is_all_successful , isAllSuccessful , & run_test_case , runTestCase public :: assert_equals , assertEquals public :: assert_not_equals , assertNotEquals public :: assert_true , assertTrue public :: stash_test_suite , restore_test_suite public :: FRUIT_PREFIX_LEN_MAX public :: override_xml_work , end_override_xml_work public :: get_assert_and_case_count public :: initializeFruit interface initializeFruit module procedure obsolete_initializeFruit_ end interface public :: getTestSummary interface getTestSummary module procedure obsolete_getTestSummary_ end interface interface assertTrue module procedure obsolete_assert_true_logical_ end interface public :: assert_false interface assert_false module procedure assert_false_ end interface interface assert_equals !====== begin of generated interface ====== module procedure assert_eq_logical_ module procedure assert_eq_1d_logical_ module procedure assert_eq_2d_logical_ module procedure assert_eq_string_ module procedure assert_eq_1d_string_ module procedure assert_eq_2d_string_ module procedure assert_eq_int_ module procedure assert_eq_1d_int_ module procedure assert_eq_2d_int_ module procedure assert_eq_real_ module procedure assert_eq_real_in_range_ module procedure assert_eq_1d_real_ module procedure assert_eq_1d_real_in_range_ module procedure assert_eq_2d_real_ module procedure assert_eq_2d_real_in_range_ module procedure assert_eq_double_ module procedure assert_eq_double_in_range_ module procedure assert_eq_1d_double_ module procedure assert_eq_1d_double_in_range_ module procedure assert_eq_2d_double_ module procedure assert_eq_2d_double_in_range_ module procedure assert_eq_complex_ module procedure assert_eq_complex_in_range_ module procedure assert_eq_1d_complex_ module procedure assert_eq_1d_complex_in_range_ module procedure assert_eq_2d_complex_ module procedure assert_eq_2d_complex_in_range_ !====== end of generated inteface ====== end interface interface assertEquals !====== begin of generated interface ====== module procedure assert_eq_logical_ module procedure assert_eq_1d_logical_ module procedure assert_eq_2d_logical_ module procedure assert_eq_string_ module procedure assert_eq_1d_string_ module procedure assert_eq_2d_string_ module procedure assert_eq_int_ module procedure assert_eq_1d_int_ module procedure assert_eq_2d_int_ module procedure assert_eq_real_ module procedure assert_eq_real_in_range_ module procedure assert_eq_1d_real_ module procedure assert_eq_1d_real_in_range_ module procedure assert_eq_2d_real_ module procedure assert_eq_2d_real_in_range_ module procedure assert_eq_double_ module procedure assert_eq_double_in_range_ module procedure assert_eq_1d_double_ module procedure assert_eq_1d_double_in_range_ module procedure assert_eq_2d_double_ module procedure assert_eq_2d_double_in_range_ module procedure assert_eq_complex_ module procedure assert_eq_complex_in_range_ module procedure assert_eq_1d_complex_ module procedure assert_eq_1d_complex_in_range_ module procedure assert_eq_2d_complex_ module procedure assert_eq_2d_complex_in_range_ !====== end of generated inteface ====== end interface interface assert_not_equals !====== begin of generated interface ====== module procedure assert_not_equals_logical_ module procedure assert_not_equals_1d_logical_ module procedure assert_not_equals_2d_logical_ module procedure assert_not_equals_string_ module procedure assert_not_equals_1d_string_ module procedure assert_not_equals_2d_string_ module procedure assert_not_equals_int_ module procedure assert_not_equals_1d_int_ module procedure assert_not_equals_2d_int_ module procedure assert_not_equals_real_ module procedure assert_not_equals_real_in_range_ module procedure assert_not_equals_1d_real_ module procedure assert_not_equals_1d_real_in_range_ module procedure assert_not_equals_2d_real_ module procedure assert_not_equals_2d_real_in_range_ module procedure assert_not_equals_double_ module procedure assert_not_equals_double_in_range_ module procedure assert_not_equals_1d_double_ module procedure assert_not_equals_1d_double_in_range_ module procedure assert_not_equals_2d_double_ module procedure assert_not_equals_2d_double_in_range_ module procedure assert_not_equals_complex_ module procedure assert_not_equals_complex_in_range_ module procedure assert_not_equals_1d_complex_ module procedure assert_not_equals_1d_complex_in_range_ module procedure assert_not_equals_2d_complex_ module procedure assert_not_equals_2d_complex_in_range_ !====== end of generated inteface ====== end interface interface assertNotEquals !====== begin of generated interface ====== module procedure assert_not_equals_logical_ module procedure assert_not_equals_1d_logical_ module procedure assert_not_equals_2d_logical_ module procedure assert_not_equals_string_ module procedure assert_not_equals_1d_string_ module procedure assert_not_equals_2d_string_ module procedure assert_not_equals_int_ module procedure assert_not_equals_1d_int_ module procedure assert_not_equals_2d_int_ module procedure assert_not_equals_real_ module procedure assert_not_equals_real_in_range_ module procedure assert_not_equals_1d_real_ module procedure assert_not_equals_1d_real_in_range_ module procedure assert_not_equals_2d_real_ module procedure assert_not_equals_2d_real_in_range_ module procedure assert_not_equals_double_ module procedure assert_not_equals_double_in_range_ module procedure assert_not_equals_1d_double_ module procedure assert_not_equals_1d_double_in_range_ module procedure assert_not_equals_2d_double_ module procedure assert_not_equals_2d_double_in_range_ module procedure assert_not_equals_complex_ module procedure assert_not_equals_complex_in_range_ module procedure assert_not_equals_1d_complex_ module procedure assert_not_equals_1d_complex_in_range_ module procedure assert_not_equals_2d_complex_ module procedure assert_not_equals_2d_complex_in_range_ !====== end of generated inteface ====== end interface interface addSuccess module procedure obsolete_addSuccess_ end interface public :: add_fail interface add_fail module procedure add_fail_ module procedure add_fail_unit_ end interface public :: addFail interface addFail module procedure add_fail_ module procedure add_fail_unit_ end interface interface getTotalCount module procedure obsolete_getTotalCount_ end interface interface getFailedCount module procedure obsolete_getFailedCount_ end interface interface isAllSuccessful module procedure obsolete_isAllSuccessful_ end interface interface run_test_case module procedure run_test_case_ module procedure run_test_case_named_ end interface interface runTestCase module procedure run_test_case_ module procedure run_test_case_named_ end interface public :: init_fruit_xml interface init_fruit_xml module procedure init_fruit_xml_ end interface public :: fruit_summary interface fruit_summary module procedure fruit_summary_ end interface public :: fruit_summary_xml interface fruit_summary_xml module procedure fruit_summary_xml_ end interface public :: case_passed_xml interface case_passed_xml module procedure case_passed_xml_ end interface public :: case_failed_xml interface case_failed_xml module procedure case_failed_xml_ end interface public :: override_stdout interface override_stdout module procedure override_stdout_ end interface public :: end_override_stdout interface end_override_stdout module procedure end_override_stdout_ end interface interface override_xml_work module procedure override_xml_work_ end interface interface end_override_xml_work module procedure end_override_xml_work_ end interface public :: get_xml_filename_work interface get_xml_filename_work module procedure get_xml_filename_work_ end interface public :: set_xml_filename_work interface set_xml_filename_work module procedure set_xml_filename_work_ end interface public :: get_message_index interface get_message_index module procedure get_message_index_ end interface public :: get_messages interface get_messages module procedure get_messages_ end interface public :: get_message_array interface get_message_array module procedure get_message_array_ end interface interface set_unit_name module procedure set_case_name_ end interface interface set_case_name module procedure set_case_name_ end interface interface get_unit_name module procedure get_case_name_ end interface interface get_case_name module procedure get_case_name_ end interface public :: fruit_finalize interface fruit_finalize module procedure fruit_finalize_ end interface public :: set_prefix interface set_prefix module procedure set_prefix_ end interface public :: get_prefix interface get_prefix module procedure get_prefix_ end interface interface get_assert_and_case_count module procedure get_assert_and_case_count_ end interface public :: fruit_summary_table interface fruit_summary_table module procedure fruit_summary_table_ end interface public :: fruit_if_case_failed interface fruit_if_case_failed module procedure fruit_if_case_failed_ end interface public :: fruit_hide_dots interface fruit_hide_dots module procedure fruit_hide_dots_ end interface public :: fruit_show_dots interface fruit_show_dots module procedure fruit_show_dots_ end interface contains subroutine init_fruit ( rank ) integer , intent ( in ), optional :: rank logical :: if_write successful_assert_count = 0 failed_assert_count = 0 message_index = 1 message_index_from = 1 if_write = . true . if ( present ( rank )) then if ( rank /= 0 ) if_write = . false . endif if ( if_write ) then write ( stdout , * ) write ( stdout , * ) \"Test module initialized\" write ( stdout , * ) write ( stdout , * ) \"   . : successful assert,   F : failed assert \" write ( stdout , * ) endif !$omp critical     (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if ( . not . allocated ( message_array ) ) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) end subroutine init_fruit subroutine fruit_finalize_ !$omp critical     (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) if ( allocated ( message_array )) then deallocate ( message_array ) endif !$omp end critical (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) end subroutine fruit_finalize_ subroutine init_fruit_xml_ ( rank ) integer , optional , intent ( in ) :: rank logical :: rank_zero_or_single rank_zero_or_single = . true . if ( present ( rank )) then if ( rank /= 0 ) then rank_zero_or_single = . false . endif endif if ( rank_zero_or_single ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite \")' , advance = \"no\" ) write ( XML_OPEN , '(      \"errors=\"\"0\"\" \"   )' , advance = \"no\" ) write ( XML_OPEN , '(      \"tests=\"\"1\"\" \"    )' , advance = \"no\" ) write ( XML_OPEN , '(      \"failures=\"\"1\"\" \" )' , advance = \"no\" ) write ( XML_OPEN , '(      \"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) \"name of test suite\" write ( XML_OPEN , '(      \"id=\"\"1\"\">\")' ) write ( XML_OPEN , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & \"dummy_testcase\" , \"dummy_classname\" , \"0\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"      <failure type=\"\"failure\"\" message=\"\"\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"FRUIT did not generate regular content of result.xml.\" write ( XML_OPEN , '(a)' ) \"\"\"/>\" write ( XML_OPEN , '(\"    </testcase>\")' ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif open ( xml_work , FILE = xml_filename_work , action = \"write\" , status = 'replace' ) close ( xml_work ) end subroutine init_fruit_xml_ function case_delta_t () character ( len = STRLEN_T ) :: case_delta_t real :: delta_t integer :: case_time_to , time_rate , time_max call system_clock ( case_time_to , time_rate , time_max ) if ( time_rate > 0 ) then delta_t = real ( case_time_to - case_time_from ) / real ( time_rate ) if ( delta_t < 0 ) then delta_t = delta_t + real ( time_max ) / real ( time_rate ) endif else delta_t = 0 endif write ( case_delta_t , '(g12.4)' ) delta_t case_delta_t = adjustl ( case_delta_t ) end function case_delta_t subroutine case_passed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\"/>\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) close ( xml_work ) end subroutine case_passed_xml_ subroutine case_failed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname integer :: i , j character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) write ( xml_work , '(\"      <failure type=\"\"failure\"\" message=\"\"\")' , advance = \"no\" ) do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > MAX_NUM_FAILURES_IN_XML ) then write ( xml_work , '(\"(omit the rest)\")' , advance = \"no\" ) exit endif write ( xml_work , '(a)' , advance = \"no\" ) trim ( strip ( message_array ( i ))) if ( i == message_index - 1 ) then continue else write ( xml_work , '(\"&#xA;\")' , advance = \"no\" ) endif enddo write ( xml_work , '(\"\"\"/>\")' ) write ( xml_work , & & '(\"    </testcase>\")' ) close ( xml_work ) end subroutine case_failed_xml_ subroutine fruit_summary_xml_ character ( len = XML_LINE_LENGTH ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count full_count = int_to_str ( successful_case_count + failed_case_count ) fail_count = int_to_str ( failed_case_count ) open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) open ( xml_work , FILE = xml_filename_work ) do read ( xml_work , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( xml_work ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) end subroutine fruit_summary_xml_ function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str subroutine obsolete_initializeFruit_ call obsolete_ ( \"initializeFruit is OBSOLETE.  replaced by init_fruit\" ) call init_fruit end subroutine obsolete_initializeFruit_ subroutine obsolete_getTestSummary_ call obsolete_ ( \"getTestSummary is OBSOLETE.  replaced by fruit_summary\" ) call fruit_summary_ end subroutine obsolete_getTestSummary_ logical function fruit_if_case_failed_ () if ( failed_assert_count == 0 ) then fruit_if_case_failed_ = . false . return endif if ( case_passed ) then fruit_if_case_failed_ = . false . else fruit_if_case_failed_ = . true . endif end function fruit_if_case_failed_ subroutine fruit_show_dots_ if_show_dots = . true . end subroutine fruit_show_dots_ subroutine fruit_hide_dots_ if_show_dots = . false . end subroutine fruit_hide_dots_ ! Run a named test case subroutine run_test_case_named_ ( tc , tc_name ) interface subroutine tc () end subroutine end interface character ( * ), intent ( in ) :: tc_name integer :: initial_failed_assert_count initial_failed_assert_count = failed_assert_count ! Set the name of the unit test call set_case_name ( tc_name ) last_passed = . true . case_passed = . true . linechar_count = 0 !! reset linechar_count for each test case. message_index_from = message_index call system_clock ( case_time_from ) !$OMP BARRIER !!! \"case_passed\" is true here. !!! \"case_passed\" becomes .false. at the first fail of assertion call tc () !$OMP BARRIER if ( initial_failed_assert_count . eq . failed_assert_count ) then ! If no additional assertions failed during the run of this test case ! then the test case was successful successful_case_count = successful_case_count + 1 else failed_case_count = failed_case_count + 1 end if testCaseIndex = testCaseIndex + 1 ! Reset the name of the unit test back to the default call set_case_name ( DEFAULT_CASE_NAME ) end subroutine run_test_case_named_ ! Run an 'unnamed' test case subroutine run_test_case_ ( tc ) interface subroutine tc () end subroutine end interface call run_test_case_named_ ( tc , '_unnamed_' ) end subroutine run_test_case_ subroutine fruit_summary_ integer :: i write ( stdout , * ) write ( stdout , * ) write ( stdout , * ) '    Start of FRUIT summary: ' write ( stdout , * ) if ( failed_assert_count > 0 ) then write ( stdout , * ) 'Some tests failed!' else write ( stdout , * ) 'SUCCESSFUL!' end if write ( stdout , * ) if ( message_index > 1 ) then write ( stdout , * ) '  -- Failed assertion messages:' do i = 1 , message_index - 1 write ( stdout , \"(A)\" ) '   ' // trim ( strip ( message_array ( i ))) end do write ( stdout , * ) '  -- end of failed assertion messages.' write ( stdout , * ) else write ( stdout , * ) '  No messages ' end if if ( successful_assert_count + failed_assert_count /= 0 ) then call fruit_summary_table_ (& & successful_assert_count , failed_assert_count , & & successful_case_count , failed_case_count & &) end if write ( stdout , * ) '  -- end of FRUIT summary' end subroutine fruit_summary_ subroutine fruit_summary_table_ (& & succ_assert , fail_assert , & & succ_case , fail_case & &) integer , intent ( in ) :: succ_assert , fail_assert integer , intent ( in ) :: succ_case , fail_case write ( stdout , * ) 'Total asserts :   ' , succ_assert + fail_assert write ( stdout , * ) 'Successful    :   ' , succ_assert write ( stdout , * ) 'Failed        :   ' , fail_assert write ( stdout , '(\"Successful rate:   \",f6.2,\"%\")' ) real ( succ_assert ) * 10 0.0 / & real ( succ_assert + fail_assert ) write ( stdout , * ) write ( stdout , * ) 'Successful asserts / total asserts : [ ' ,& succ_assert , '/' , succ_assert + fail_assert , ' ]' write ( stdout , * ) 'Successful cases   / total cases   : [ ' , succ_case , '/' , & succ_case + fail_case , ' ]' end subroutine fruit_summary_table_ subroutine obsolete_addSuccess_ call obsolete_ ( \"addSuccess is OBSOLETE.  replaced by add_success\" ) call add_success end subroutine obsolete_addSuccess_ subroutine add_fail_ ( message ) character ( * ), intent ( in ), optional :: message call failed_assert_action ( 'none' , 'none' , message , if_is = . true .) end subroutine add_fail_ subroutine add_fail_unit_ ( unitName , message ) character ( * ), intent ( in ) :: unitName character ( * ), intent ( in ) :: message call add_fail_ ( \"[in \" // unitName // \"(fail)]: \" // message ) end subroutine add_fail_unit_ subroutine obsolete_isAllSuccessful_ ( result ) logical , intent ( out ) :: result call obsolete_ ( 'subroutine isAllSuccessful is changed to function is_all_successful.' ) result = ( failed_assert_count . eq . 0 ) end subroutine obsolete_isAllSuccessful_ subroutine is_all_successful ( result ) logical , intent ( out ) :: result result = ( failed_assert_count . eq . 0 ) end subroutine is_all_successful ! Private, helper routine to wrap lines of success/failed marks subroutine output_mark_ ( chr ) character ( 1 ), intent ( in ) :: chr !!  integer, save :: linechar_count = 0 !!  Definition of linechar_count is moved to module, !!  so that it can be stashed and restored. !$omp critical      (FRUIT_OMP_ADD_OUTPUT_MARK) linechar_count = linechar_count + 1 if ( linechar_count . lt . MAX_MARKS_PER_LINE ) then write ( stdout , \"(A1)\" , ADVANCE = 'NO' ) chr else write ( stdout , \"(A1)\" , ADVANCE = 'YES' ) chr linechar_count = 0 endif !$omp end critical  (FRUIT_OMP_ADD_OUTPUT_MARK) end subroutine output_mark_ subroutine success_mark_ call output_mark_ ( '.' ) end subroutine success_mark_ subroutine failed_mark_ call output_mark_ ( 'F' ) end subroutine failed_mark_ subroutine increase_message_stack_ character ( len = MSG_LENGTH ) :: msg_swap_holder ( current_max ) if ( message_index > MAX_MSG_STACK_SIZE ) then return end if if ( message_index > current_max ) then msg_swap_holder ( 1 : current_max ) = message_array ( 1 : current_max ) deallocate ( message_array ) current_max = current_max + MSG_ARRAY_INCREMENT allocate ( message_array ( current_max )) message_array ( 1 : current_max - MSG_ARRAY_INCREMENT ) & = msg_swap_holder ( 1 : current_max - MSG_ARRAY_INCREMENT ) end if message_array ( message_index ) = msg if ( message_index == MAX_MSG_STACK_SIZE ) then message_array ( message_index ) = \"Max number of messages reached. Further messages suppressed.\" endif message_index = message_index + 1 if ( message_index > MAX_MSG_STACK_SIZE ) then write ( stdout , * ) \"Stop because there are too many error messages to put into stack.\" write ( stdout , * ) \"Try to increase MAX_MSG_STACK_SIZE if you really need so.\" end if end subroutine increase_message_stack_ subroutine get_xml_filename_work_ ( string ) character ( len = * ), intent ( out ) :: string string = trim ( xml_filename_work ) end subroutine get_xml_filename_work_ subroutine set_xml_filename_work_ ( string ) character ( len = * ), intent ( in ) :: string xml_filename_work = trim ( string ) end subroutine set_xml_filename_work_ function get_last_message () character ( len = MSG_LENGTH ) :: get_last_message if ( message_index > 1 ) then get_last_message = strip ( message_array ( message_index - 1 ), MSG_LENGTH ) else get_last_message = '' end if end function get_last_message subroutine get_message_index_ ( index ) integer , intent ( out ) :: index index = message_index end subroutine get_message_index_ subroutine get_message_array_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i msgs (:) = \"\" do i = 1 , message_index - 1 msgs ( i ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_message_array_ subroutine get_messages_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i , j msgs (:) = \"\" do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > ubound ( msgs , 1 )) exit msgs ( j ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_messages_ subroutine obsolete_getTotalCount_ ( count ) integer , intent ( out ) :: count call obsolete_ ( ' getTotalCount subroutine is replaced by function get_total_count' ) call get_total_count ( count ) end subroutine obsolete_getTotalCount_ subroutine get_total_count ( count ) integer , intent ( out ) :: count count = successful_assert_count + failed_assert_count end subroutine get_total_count subroutine obsolete_getFailedCount_ ( count ) integer , intent ( out ) :: count call obsolete_ ( ' getFailedCount subroutine is replaced by function get_failed_count' ) call get_failed_count ( count ) end subroutine obsolete_getFailedCount_ subroutine get_failed_count ( count ) integer , intent ( out ) :: count count = failed_assert_count end subroutine get_failed_count subroutine obsolete_ ( message ) character ( * ), intent ( in ), optional :: message write ( stdout , * ) write ( stdout , * ) \"<<<<<<<<<<<<<<<<<<<<<<<<<< WARNING from FRUIT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" write ( stdout , * ) message write ( stdout , * ) write ( stdout , * ) \" old calls will be replaced in the next release in Jan 2009\" write ( stdout , * ) \" Naming convention for all the method calls are changed to: first_name from\" write ( stdout , * ) \" firstName.  Subroutines that will be deleted: assertEquals, assertNotEquals,\" write ( stdout , * ) \" assertTrue, addSuccessful, addFail, etc.\" write ( stdout , * ) \"<<<<<<<<<<<<<<<<<<<<<<<<<< WARNING from FRUIT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" write ( stdout , * ) end subroutine obsolete_ subroutine add_success !$omp critical     (FRUIT_OMP_ADD_SUCCESS) successful_assert_count = successful_assert_count + 1 last_passed = . true . !$omp end critical (FRUIT_OMP_ADD_SUCCESS) if ( if_show_dots ) then call success_mark_ endif end subroutine add_success subroutine failed_assert_action ( expected , got , message , if_is ) character ( * ), intent ( in ) :: expected , got character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: if_is !$omp critical     (FRUIT_OMP_ADD_FAIL) if ( present ( if_is )) then call make_error_msg_ ( expected , got , if_is , message ) else call make_error_msg_ ( expected , got , . true ., message ) endif call increase_message_stack_ failed_assert_count = failed_assert_count + 1 last_passed = . false . case_passed = . false . !$omp end critical (FRUIT_OMP_ADD_FAIL) call failed_mark_ end subroutine failed_assert_action subroutine set_case_name_ ( value ) character ( * ), intent ( in ) :: value case_name = strip ( value , MSG_LENGTH ) end subroutine set_case_name_ subroutine get_case_name_ ( value ) character ( * ), intent ( out ) :: value value = strip ( case_name ) end subroutine get_case_name_ subroutine make_error_msg_ ( var1 , var2 , if_is , message ) character ( * ), intent ( in ) :: var1 , var2 logical , intent ( in ) :: if_is character ( * ), intent ( in ), optional :: message msg = '[' // trim ( strip ( case_name )) // ']: ' if ( if_is ) then msg = trim ( msg ) // 'Expected' else msg = trim ( msg ) // 'Expected Not' endif msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var1 )) // '], ' msg = trim ( msg ) // \" \" // 'Got' msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var2 )) // ']' if ( present ( message )) then msg = trim ( msg ) // '; User message: [' // trim ( message ) // ']' endif end subroutine make_error_msg_ function is_last_passed () logical :: is_last_passed is_last_passed = last_passed end function is_last_passed function is_case_passed () logical :: is_case_passed is_case_passed = case_passed end function is_case_passed subroutine override_stdout_ ( write_unit , filename ) integer , intent ( in ) :: write_unit character ( len = * ), intent ( in ) :: filename stdout = write_unit open ( stdout , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_stdout_ subroutine override_xml_work_ ( new_unit , filename ) integer , intent ( in ) :: new_unit character ( len = * ), intent ( in ) :: filename xml_work = new_unit xml_filename_work = filename open ( xml_work , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_xml_work_ subroutine stash_test_suite stashed_suite % successful_assert_count = successful_assert_count successful_assert_count = 0 stashed_suite % failed_assert_count = failed_assert_count failed_assert_count = 0 allocate ( stashed_suite % message_array ( current_max )) stashed_suite % message_array ( 1 : message_index ) = & & message_array ( 1 : message_index ) deallocate ( message_array ) allocate ( message_array ( MSG_ARRAY_INCREMENT )) stashed_suite % message_index = message_index message_index = 1 stashed_suite % message_index_from = message_index_from message_index_from = 1 stashed_suite % current_max = current_max current_max = 50 stashed_suite % successful_case_count = successful_case_count successful_case_count = 0 stashed_suite % failed_case_count = failed_case_count failed_case_count = 0 stashed_suite % testCaseIndex = testCaseIndex testCaseIndex = 1 stashed_suite % case_name = case_name case_name = DEFAULT_CASE_NAME stashed_suite % last_passed = last_passed last_passed = . false . stashed_suite % case_passed = case_passed case_passed = DEFAULT_CASE_PASSED stashed_suite % case_time_from = case_time_from case_time_from = 0 stashed_suite % linechar_count = linechar_count linechar_count = 0 stashed_suite % if_show_dots = if_show_dots if_show_dots = . true . end subroutine stash_test_suite subroutine restore_test_suite successful_assert_count = stashed_suite % successful_assert_count failed_assert_count = stashed_suite % failed_assert_count message_index = stashed_suite % message_index message_index_from = stashed_suite % message_index_from current_max = stashed_suite % current_max deallocate ( message_array ) allocate ( message_array ( current_max )) message_array ( 1 : message_index ) = & & stashed_suite % message_array ( 1 : message_index ) deallocate ( stashed_suite % message_array ) successful_case_count = stashed_suite % successful_case_count failed_case_count = stashed_suite % failed_case_count testCaseIndex = stashed_suite % testCaseIndex case_name = stashed_suite % case_name last_passed = stashed_suite % last_passed case_passed = stashed_suite % case_passed case_time_from = stashed_suite % case_time_from linechar_count = stashed_suite % linechar_count if_show_dots = stashed_suite % if_show_dots end subroutine restore_test_suite subroutine end_override_stdout_ close ( stdout ) stdout = STDOUT_DEFAULT end subroutine end_override_stdout_ subroutine end_override_xml_work_ close ( xml_work ) xml_work = XML_WORK_DEFAULT xml_filename_work = XML_FN_WORK_DEF end subroutine end_override_xml_work_ subroutine set_prefix_ ( str ) character ( len = * ), intent ( in ) :: str character ( len = len_trim ( str )) :: str2 str2 = trim ( adjustl ( str )) if ( len_trim ( str2 ) <= FRUIT_PREFIX_LEN_MAX ) then prefix = str2 else prefix = str2 ( 1 : FRUIT_PREFIX_LEN_MAX ) endif end subroutine set_prefix_ subroutine get_prefix_ ( str ) character ( len = * ), intent ( out ) :: str if ( len ( str ) <= len ( prefix )) then str = trim ( prefix ) else str = prefix endif end subroutine get_prefix_ subroutine get_assert_and_case_count_ ( fail_assert , suc_assert , fail_case , suc_case ) integer , intent ( out ) :: fail_assert , suc_assert , fail_case , suc_case fail_assert = failed_assert_count suc_assert = successful_assert_count fail_case = failed_case_count suc_case = successful_case_count end subroutine get_assert_and_case_count_ !-------------------------------------------------------------------------------- ! all assertions !-------------------------------------------------------------------------------- subroutine obsolete_assert_true_logical_ ( var1 , message ) logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message call obsolete_ ( 'assertTrue subroutine is replaced by function assert_true' ) call assert_true ( var1 , message ) end subroutine obsolete_assert_true_logical_ subroutine assert_true ( var1 , message ) logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message if ( var1 . eqv . . true .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . true .) end if end subroutine assert_true subroutine assert_false_ ( var1 , message ) logical , intent ( in ) :: var1 character ( len = * ), intent ( in ), optional :: message if ( var1 . eqv . . false .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . false .) endif end subroutine assert_false_ !====== begin of generated code ====== !------ 0d_logical ------ subroutine assert_eq_logical_ ( var1 , var2 , message ) logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 . neqv . var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_logical_ !------ 1d_logical ------ subroutine assert_eq_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_logical_ !------ 2d_logical ------ subroutine assert_eq_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_logical_ !------ 0d_string ------ subroutine assert_eq_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_string_ !------ 1d_string ------ subroutine assert_eq_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_string_ !------ 2d_string ------ subroutine assert_eq_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_string_ !------ 0d_int ------ subroutine assert_eq_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 /= var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_int_ !------ 1d_int ------ subroutine assert_eq_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_int_ !------ 2d_int ------ subroutine assert_eq_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_int_ !------ 0d_real ------ subroutine assert_eq_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_ !------ 0d_real ------ subroutine assert_eq_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_in_range_ !------ 1d_real ------ subroutine assert_eq_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_ !------ 1d_real ------ subroutine assert_eq_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_in_range_ !------ 2d_real ------ subroutine assert_eq_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_ !------ 2d_real ------ subroutine assert_eq_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_in_range_ !------ 0d_double ------ subroutine assert_eq_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_ !------ 0d_double ------ subroutine assert_eq_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_in_range_ !------ 1d_double ------ subroutine assert_eq_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_ !------ 1d_double ------ subroutine assert_eq_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_in_range_ !------ 2d_double ------ subroutine assert_eq_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_ !------ 2d_double ------ subroutine assert_eq_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_in_range_ !------ 0d_complex ------ subroutine assert_eq_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_ !------ 0d_complex ------ subroutine assert_eq_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_in_range_ !------ 1d_complex ------ subroutine assert_eq_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_ !------ 1d_complex ------ subroutine assert_eq_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_in_range_ !------ 2d_complex ------ subroutine assert_eq_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_ !------ 2d_complex ------ subroutine assert_eq_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_in_range_ !------ 0d_logical ------ subroutine assert_not_equals_logical_ ( var1 , var2 , message ) logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 . neqv . var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_logical_ !------ 1d_logical ------ subroutine assert_not_equals_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_logical_ !------ 2d_logical ------ subroutine assert_not_equals_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_logical_ !------ 0d_string ------ subroutine assert_not_equals_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_string_ !------ 1d_string ------ subroutine assert_not_equals_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_string_ !------ 2d_string ------ subroutine assert_not_equals_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_string_ !------ 0d_int ------ subroutine assert_not_equals_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 /= var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_int_ !------ 1d_int ------ subroutine assert_not_equals_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_int_ !------ 2d_int ------ subroutine assert_not_equals_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_int_ !------ 0d_real ------ subroutine assert_not_equals_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_real_ !------ 0d_real ------ subroutine assert_not_equals_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_real_in_range_ !------ 1d_real ------ subroutine assert_not_equals_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_real_ !------ 1d_real ------ subroutine assert_not_equals_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_real_in_range_ !------ 2d_real ------ subroutine assert_not_equals_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_real_ !------ 2d_real ------ subroutine assert_not_equals_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_real_in_range_ !------ 0d_double ------ subroutine assert_not_equals_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_double_ !------ 0d_double ------ subroutine assert_not_equals_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_double_in_range_ !------ 1d_double ------ subroutine assert_not_equals_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_double_ !------ 1d_double ------ subroutine assert_not_equals_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_double_in_range_ !------ 2d_double ------ subroutine assert_not_equals_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_double_ !------ 2d_double ------ subroutine assert_not_equals_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_double_in_range_ !------ 0d_complex ------ subroutine assert_not_equals_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_complex_ !------ 0d_complex ------ subroutine assert_not_equals_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_complex_in_range_ !------ 1d_complex ------ subroutine assert_not_equals_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_complex_ !------ 1d_complex ------ subroutine assert_not_equals_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_complex_in_range_ !------ 2d_complex ------ subroutine assert_not_equals_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_complex_ !------ 2d_complex ------ subroutine assert_not_equals_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_complex_in_range_ !====== end of generated code ====== end module fruit","tags":"","loc":"sourcefile/fruit.f90.html"},{"title":"ty_stack – naturalFRUIT ","text":"type, private :: ty_stack Contents Variables successful_assert_count failed_assert_count message_index message_index_from current_max message_array case_name successful_case_count failed_case_count testCaseIndex last_passed case_passed case_time_from linechar_count if_show_dots Source Code ty_stack Components Type Visibility Attributes Name Initial integer, public :: successful_assert_count integer, public :: failed_assert_count integer, public :: message_index integer, public :: message_index_from integer, public :: current_max character(len=MSG_LENGTH), public, pointer :: message_array (:) character(len=MSG_LENGTH), public :: case_name integer, public :: successful_case_count integer, public :: failed_case_count integer, public :: testCaseIndex logical, public :: last_passed logical, public :: case_passed = DEFAULT_CASE_PASSED integer, public :: case_time_from integer, public :: linechar_count logical, public :: if_show_dots Source Code type ty_stack integer :: successful_assert_count integer :: failed_assert_count integer :: message_index integer :: message_index_from integer :: current_max character ( len = MSG_LENGTH ), pointer :: message_array (:) character ( len = MSG_LENGTH ) :: case_name !  = DEFAULT_CASE_NAME integer :: successful_case_count integer :: failed_case_count integer :: testCaseIndex logical :: last_passed logical :: case_passed = DEFAULT_CASE_PASSED integer :: case_time_from integer :: linechar_count logical :: if_show_dots end type ty_stack","tags":"","loc":"type/ty_stack.html"},{"title":"int_to_str – naturalFRUIT","text":"private function int_to_str(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=NUMBER_LENGTH) Called by proc~~int_to_str~~CalledByGraph proc~int_to_str int_to_str proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ proc~fruit_summary_mpi_xml_->proc~int_to_str interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code int_to_str Source Code function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str","tags":"","loc":"proc/int_to_str.html"},{"title":"fruit_init_mpi_xml_ – naturalFRUIT","text":"private subroutine fruit_init_mpi_xml_(rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank Calls proc~~fruit_init_mpi_xml_~~CallsGraph proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ interface~set_xml_filename_work set_xml_filename_work proc~fruit_init_mpi_xml_->interface~set_xml_filename_work interface~init_fruit_xml init_fruit_xml proc~fruit_init_mpi_xml_->interface~init_fruit_xml proc~set_xml_filename_work_ set_xml_filename_work_ interface~set_xml_filename_work->proc~set_xml_filename_work_ proc~init_fruit_xml_ init_fruit_xml_ interface~init_fruit_xml->proc~init_fruit_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_init_mpi_xml_~~CalledByGraph proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ interface~fruit_init_mpi_xml fruit_init_mpi_xml interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_init_mpi_xml_ Source Code subroutine fruit_init_mpi_xml_ ( rank ) integer , intent ( in ) :: rank character ( len = FN_LENGTH ) :: xml_filename_work write ( xml_filename_work , '(\"result_tmp_\", i5.5, \".xml\")' ) rank call set_xml_filename_work ( xml_filename_work ) call init_fruit_xml ( rank ) end subroutine fruit_init_mpi_xml_","tags":"","loc":"proc/fruit_init_mpi_xml_.html"},{"title":"fruit_finalize_mpi_ – naturalFRUIT","text":"private subroutine fruit_finalize_mpi_(size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank Calls proc~~fruit_finalize_mpi_~~CallsGraph proc~fruit_finalize_mpi_ fruit_finalize_mpi_ interface~fruit_finalize fruit_finalize proc~fruit_finalize_mpi_->interface~fruit_finalize proc~fruit_finalize_ fruit_finalize_ interface~fruit_finalize->proc~fruit_finalize_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_finalize_mpi_~~CalledByGraph proc~fruit_finalize_mpi_ fruit_finalize_mpi_ interface~fruit_finalize_mpi fruit_finalize_mpi interface~fruit_finalize_mpi->proc~fruit_finalize_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_finalize_mpi_ Source Code subroutine fruit_finalize_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank if ( size < 0 ) print * , \"size negative\" if ( rank < 0 ) print * , \"rank negative\" call fruit_finalize end subroutine fruit_finalize_mpi_","tags":"","loc":"proc/fruit_finalize_mpi_.html"},{"title":"fruit_summary_mpi_ – naturalFRUIT","text":"private subroutine fruit_summary_mpi_(size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank Calls proc~~fruit_summary_mpi_~~CallsGraph proc~fruit_summary_mpi_ fruit_summary_mpi_ mpi_reduce mpi_reduce proc~fruit_summary_mpi_->mpi_reduce interface~get_assert_and_case_count get_assert_and_case_count proc~fruit_summary_mpi_->interface~get_assert_and_case_count interface~get_message_array get_message_array proc~fruit_summary_mpi_->interface~get_message_array mpi_allgather mpi_allgather proc~fruit_summary_mpi_->mpi_allgather mpi_send mpi_send proc~fruit_summary_mpi_->mpi_send interface~fruit_summary_table fruit_summary_table proc~fruit_summary_mpi_->interface~fruit_summary_table interface~get_message_index get_message_index proc~fruit_summary_mpi_->interface~get_message_index proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count->proc~get_assert_and_case_count_ proc~get_message_array_ get_message_array_ interface~get_message_array->proc~get_message_array_ proc~fruit_summary_table_ fruit_summary_table_ interface~fruit_summary_table->proc~fruit_summary_table_ proc~get_message_index_ get_message_index_ interface~get_message_index->proc~get_message_index_ interface~strip strip proc~get_message_array_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var panprocfruit_summary_mpi_CallsGraph = svgPanZoom('#procfruit_summary_mpi_CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_summary_mpi_~~CalledByGraph proc~fruit_summary_mpi_ fruit_summary_mpi_ interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_summary_mpi_ Source Code subroutine fruit_summary_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank integer :: fail_assert_sum integer :: succ_assert_sum integer :: fail_case_sum integer :: succ_case_sum integer :: fail_assert integer :: succ_assert integer :: fail_case integer :: succ_case integer :: message_index integer :: num_msgs integer :: num_msgs_sum integer , allocatable :: num_msgs_rank (:) integer :: ierr integer :: i integer :: imsg integer :: status ( MPI_STATUS_SIZE ) integer , parameter :: MSG_LENGTH_HERE = 256 character ( len = MSG_LENGTH_HERE ), allocatable :: msgs (:) character ( len = MSG_LENGTH_HERE ), allocatable :: msgs_all (:) call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call get_message_index ( message_index ) num_msgs = message_index - 1 allocate ( msgs ( num_msgs )) call get_message_array ( msgs ) allocate ( num_msgs_rank ( size )) call MPI_Allgather (& & num_msgs , 1 , MPI_INTEGER , & & num_msgs_rank , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierr ) num_msgs_sum = sum ( num_msgs_rank (:)) allocate ( msgs_all ( num_msgs_sum )) ! array msgs_all: ! ! | msgs(:) of rank 0  | msgs(:) of rank 1   | msgs(:) of rank 2  | ! |                    |                     |                    | ! | num_msgs_rank(1)   |  num_msgs_rank(2)   | num_msgs_rank(3)   | ! |                    |                     |                    | ! |                    |                     |                    | !                       A                     A                  A !                       |                     |                  | !              sum(num_msgs_rank(1:1))+1      |             num_msgs_sum !                                    sum(num_msgs_rank(1:2))+1 if ( rank == 0 ) then msgs_all ( 1 : num_msgs ) = msgs ( 1 : num_msgs ) do i = 1 , size - 1 imsg = sum ( num_msgs_rank ( 1 : i )) + 1 call MPI_RECV (& & msgs_all ( imsg ), & & num_msgs_rank ( i + 1 ) * MSG_LENGTH_HERE , MPI_CHARACTER , & & i , 7 , MPI_COMM_WORLD , status , ierr ) enddo else call MPI_Send (& & msgs , & & num_msgs * MSG_LENGTH_HERE , MPI_CHARACTER , & & 0 , 7 , MPI_COMM_WORLD , ierr ) endif call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) if ( rank == 0 ) then write ( * , * ) write ( * , * ) write ( * , * ) '    Start of FRUIT summary: ' write ( * , * ) if ( fail_assert_sum > 0 ) then write ( * , * ) 'Some tests failed!' else write ( * , * ) 'SUCCESSFUL!' end if write ( * , * ) write ( * , * ) '  -- Failed assertion messages:' do i = 1 , num_msgs_sum write ( * , \"(A)\" ) '   ' // trim ( msgs_all ( i )) end do write ( * , * ) '  -- end of failed assertion messages.' write ( * , * ) if ( succ_assert_sum + fail_assert_sum /= 0 ) then call fruit_summary_table (& & succ_assert_sum , fail_assert_sum , & & succ_case_sum , fail_case_sum & &) endif write ( * , * ) '  -- end of FRUIT summary' endif end subroutine fruit_summary_mpi_","tags":"","loc":"proc/fruit_summary_mpi_.html"},{"title":"fruit_summary_mpi_xml_ – naturalFRUIT","text":"private subroutine fruit_summary_mpi_xml_(size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank Calls proc~~fruit_summary_mpi_xml_~~CallsGraph proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ mpi_reduce mpi_reduce proc~fruit_summary_mpi_xml_->mpi_reduce interface~get_assert_and_case_count get_assert_and_case_count proc~fruit_summary_mpi_xml_->interface~get_assert_and_case_count mpi_send mpi_send proc~fruit_summary_mpi_xml_->mpi_send interface~get_xml_filename_work get_xml_filename_work proc~fruit_summary_mpi_xml_->interface~get_xml_filename_work proc~int_to_str int_to_str proc~fruit_summary_mpi_xml_->proc~int_to_str proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count->proc~get_assert_and_case_count_ proc~get_xml_filename_work_ get_xml_filename_work_ interface~get_xml_filename_work->proc~get_xml_filename_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_summary_mpi_xml_~~CalledByGraph proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_summary_mpi_xml_ Source Code subroutine fruit_summary_mpi_xml_ ( size , rank ) integer , intent ( in ) :: size , rank character ( len = 1000 ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count character ( len = FN_LENGTH ) :: xml_filename_work character ( len = FN_LENGTH ), allocatable :: xml_filename_work_all (:) integer :: fail_assert , succ_assert , fail_case , succ_case integer :: fail_assert_sum , succ_assert_sum , fail_case_sum , succ_case_sum integer :: i integer :: status ( MPI_STATUS_SIZE ) integer :: ierr call get_xml_filename_work ( xml_filename_work ) allocate ( xml_filename_work_all ( size )) if ( rank /= 0 ) then call MPI_Send ( xml_filename_work , & & FN_LENGTH , MPI_CHARACTER , 0 , 8 , MPI_COMM_WORLD , ierr ) endif if ( rank == 0 ) then xml_filename_work_all ( 1 ) = xml_filename_work do i = 1 + 1 , size call MPI_RECV ( xml_filename_work_all ( i ), & & FN_LENGTH , MPI_CHARACTER , i - 1 , 8 , MPI_COMM_WORLD , status , ierr ) enddo endif call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) full_count = int_to_str ( succ_case_sum + fail_case_sum ) fail_count = int_to_str ( fail_case_sum ) if ( rank == 0 ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) do i = 1 , size open ( XML_WORK , FILE = xml_filename_work_all ( i )) do read ( XML_WORK , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( XML_WORK ) enddo write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif if ( size < 0 ) print * , \"size < 0\" end subroutine fruit_summary_mpi_xml_","tags":"","loc":"proc/fruit_summary_mpi_xml_.html"},{"title":"fruit_init_mpi_xml – naturalFRUIT","text":"public interface fruit_init_mpi_xml Calls interface~~fruit_init_mpi_xml~~CallsGraph interface~fruit_init_mpi_xml fruit_init_mpi_xml proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ interface~set_xml_filename_work set_xml_filename_work proc~fruit_init_mpi_xml_->interface~set_xml_filename_work interface~init_fruit_xml init_fruit_xml proc~fruit_init_mpi_xml_->interface~init_fruit_xml proc~set_xml_filename_work_ set_xml_filename_work_ interface~set_xml_filename_work->proc~set_xml_filename_work_ proc~init_fruit_xml_ init_fruit_xml_ interface~init_fruit_xml->proc~init_fruit_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_init_mpi_xml_ Module Procedures private subroutine fruit_init_mpi_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank","tags":"","loc":"interface/fruit_init_mpi_xml.html"},{"title":"fruit_finalize_mpi – naturalFRUIT","text":"public interface fruit_finalize_mpi Calls interface~~fruit_finalize_mpi~~CallsGraph interface~fruit_finalize_mpi fruit_finalize_mpi proc~fruit_finalize_mpi_ fruit_finalize_mpi_ interface~fruit_finalize_mpi->proc~fruit_finalize_mpi_ interface~fruit_finalize fruit_finalize proc~fruit_finalize_mpi_->interface~fruit_finalize proc~fruit_finalize_ fruit_finalize_ interface~fruit_finalize->proc~fruit_finalize_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_finalize_mpi_ Module Procedures private subroutine fruit_finalize_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank","tags":"","loc":"interface/fruit_finalize_mpi.html"},{"title":"fruit_summary_mpi – naturalFRUIT","text":"public interface fruit_summary_mpi Calls interface~~fruit_summary_mpi~~CallsGraph interface~fruit_summary_mpi fruit_summary_mpi proc~fruit_summary_mpi_ fruit_summary_mpi_ interface~fruit_summary_mpi->proc~fruit_summary_mpi_ mpi_reduce mpi_reduce proc~fruit_summary_mpi_->mpi_reduce interface~get_assert_and_case_count get_assert_and_case_count proc~fruit_summary_mpi_->interface~get_assert_and_case_count interface~get_message_array get_message_array proc~fruit_summary_mpi_->interface~get_message_array mpi_allgather mpi_allgather proc~fruit_summary_mpi_->mpi_allgather mpi_send mpi_send proc~fruit_summary_mpi_->mpi_send interface~fruit_summary_table fruit_summary_table proc~fruit_summary_mpi_->interface~fruit_summary_table interface~get_message_index get_message_index proc~fruit_summary_mpi_->interface~get_message_index proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count->proc~get_assert_and_case_count_ proc~get_message_array_ get_message_array_ interface~get_message_array->proc~get_message_array_ proc~fruit_summary_table_ fruit_summary_table_ interface~fruit_summary_table->proc~fruit_summary_table_ proc~get_message_index_ get_message_index_ interface~get_message_index->proc~get_message_index_ interface~strip strip proc~get_message_array_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfacefruit_summary_mpiCallsGraph = svgPanZoom('#interfacefruit_summary_mpiCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_summary_mpi_ Module Procedures private subroutine fruit_summary_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank","tags":"","loc":"interface/fruit_summary_mpi.html"},{"title":"fruit_summary_mpi_xml – naturalFRUIT","text":"public interface fruit_summary_mpi_xml Calls interface~~fruit_summary_mpi_xml~~CallsGraph interface~fruit_summary_mpi_xml fruit_summary_mpi_xml proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ mpi_reduce mpi_reduce proc~fruit_summary_mpi_xml_->mpi_reduce interface~get_assert_and_case_count get_assert_and_case_count proc~fruit_summary_mpi_xml_->interface~get_assert_and_case_count mpi_send mpi_send proc~fruit_summary_mpi_xml_->mpi_send interface~get_xml_filename_work get_xml_filename_work proc~fruit_summary_mpi_xml_->interface~get_xml_filename_work proc~int_to_str int_to_str proc~fruit_summary_mpi_xml_->proc~int_to_str proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count->proc~get_assert_and_case_count_ proc~get_xml_filename_work_ get_xml_filename_work_ interface~get_xml_filename_work->proc~get_xml_filename_work_ var paninterfacefruit_summary_mpi_xmlCallsGraph = svgPanZoom('#interfacefruit_summary_mpi_xmlCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_summary_mpi_xml_ Module Procedures private subroutine fruit_summary_mpi_xml_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank","tags":"","loc":"interface/fruit_summary_mpi_xml.html"},{"title":"to_s_int_ – naturalFRUIT","text":"private function to_s_int_(value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=500) Called by proc~~to_s_int_~~CalledByGraph proc~to_s_int_ to_s_int_ interface~to_s to_s interface~to_s->proc~to_s_int_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_int_CalledByGraph = svgPanZoom('#procto_s_int_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_int_ Source Code function to_s_int_ ( value ) implicit none character ( len = 500 ) :: to_s_int_ integer , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_int_ = adjustl ( trim ( result )) end function to_s_int_","tags":"","loc":"proc/to_s_int_.html"},{"title":"to_s_real_ – naturalFRUIT","text":"private function to_s_real_(value) Arguments Type Intent Optional Attributes Name real, intent(in) :: value Return Value character(len=500) Called by proc~~to_s_real_~~CalledByGraph proc~to_s_real_ to_s_real_ interface~to_s to_s interface~to_s->proc~to_s_real_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_real_CalledByGraph = svgPanZoom('#procto_s_real_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_real_ Source Code function to_s_real_ ( value ) implicit none character ( len = 500 ) :: to_s_real_ real , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_real_ = adjustl ( trim ( result )) end function to_s_real_","tags":"","loc":"proc/to_s_real_.html"},{"title":"to_s_double_ – naturalFRUIT","text":"private function to_s_double_(value) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value Return Value character(len=500) Called by proc~~to_s_double_~~CalledByGraph proc~to_s_double_ to_s_double_ interface~to_s to_s interface~to_s->proc~to_s_double_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_double_CalledByGraph = svgPanZoom('#procto_s_double_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_double_ Source Code function to_s_double_ ( value ) implicit none character ( len = 500 ) :: to_s_double_ double precision , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_ = adjustl ( trim ( result )) end function to_s_double_","tags":"","loc":"proc/to_s_double_.html"},{"title":"to_s_complex_ – naturalFRUIT","text":"private function to_s_complex_(value) Arguments Type Intent Optional Attributes Name complex, intent(in) :: value Return Value character(len=500) Called by proc~~to_s_complex_~~CalledByGraph proc~to_s_complex_ to_s_complex_ interface~to_s to_s interface~to_s->proc~to_s_complex_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_complex_CalledByGraph = svgPanZoom('#procto_s_complex_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_complex_ Source Code function to_s_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_complex_ complex , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_complex_ = adjustl ( trim ( result )) end function to_s_complex_","tags":"","loc":"proc/to_s_complex_.html"},{"title":"to_s_double_complex_ – naturalFRUIT","text":"private function to_s_double_complex_(value) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: value Return Value character(len=500) Called by proc~~to_s_double_complex_~~CalledByGraph proc~to_s_double_complex_ to_s_double_complex_ interface~to_s to_s interface~to_s->proc~to_s_double_complex_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_double_complex_CalledByGraph = svgPanZoom('#procto_s_double_complex_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_double_complex_ Source Code function to_s_double_complex_ ( value ) implicit none character ( len = 500 ) :: to_s_double_complex_ complex ( kind = kind ( 1.0D0 )), intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_complex_ = adjustl ( trim ( result )) end function to_s_double_complex_","tags":"","loc":"proc/to_s_double_complex_.html"},{"title":"to_s_logical_ – naturalFRUIT","text":"private function to_s_logical_(value) Arguments Type Intent Optional Attributes Name logical, intent(in) :: value Return Value character(len=500) Called by proc~~to_s_logical_~~CalledByGraph proc~to_s_logical_ to_s_logical_ interface~to_s to_s interface~to_s->proc~to_s_logical_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_logical_CalledByGraph = svgPanZoom('#procto_s_logical_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_logical_ Source Code function to_s_logical_ ( value ) implicit none character ( len = 500 ) :: to_s_logical_ logical , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_logical_ = adjustl ( trim ( result )) end function to_s_logical_","tags":"","loc":"proc/to_s_logical_.html"},{"title":"to_s_string_ – naturalFRUIT","text":"private function to_s_string_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) Called by proc~~to_s_string_~~CalledByGraph proc~to_s_string_ to_s_string_ interface~to_s to_s interface~to_s->proc~to_s_string_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocto_s_string_CalledByGraph = svgPanZoom('#procto_s_string_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code to_s_string_ Source Code function to_s_string_ ( value ) implicit none character ( len = 500 ) :: to_s_string_ character ( len =* ), intent ( in ) :: value to_s_string_ = value end function to_s_string_","tags":"","loc":"proc/to_s_string_.html"},{"title":"strip_ – naturalFRUIT","text":"private function strip_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) Called by proc~~strip_~~CalledByGraph proc~strip_ strip_ interface~strip strip interface~strip->proc~strip_ proc~get_case_name_ get_case_name_ proc~get_case_name_->interface~strip proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~strip proc~set_case_name_ set_case_name_ proc~set_case_name_->interface~strip proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~strip proc~case_failed_xml_ case_failed_xml_ proc~case_failed_xml_->interface~strip proc~get_messages_ get_messages_ proc~get_messages_->interface~strip proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~strip proc~fruit_summary_ fruit_summary_ proc~fruit_summary_->interface~strip proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~strip proc~get_message_array_ get_message_array_ proc~get_message_array_->interface~strip proc~make_error_msg_ make_error_msg_ proc~make_error_msg_->interface~strip proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~strip proc~get_last_message get_last_message proc~get_last_message->interface~strip proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~strip interface~set_unit_name set_unit_name interface~set_unit_name->proc~set_case_name_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_2d_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_2d_string_ interface~case_failed_xml case_failed_xml interface~case_failed_xml->proc~case_failed_xml_ proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ interface~get_case_name get_case_name interface~get_case_name->proc~get_case_name_ interface~fruit_summary fruit_summary interface~fruit_summary->proc~fruit_summary_ interface~get_message_array get_message_array interface~get_message_array->proc~get_message_array_ interface~set_case_name set_case_name interface~set_case_name->proc~set_case_name_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~get_messages get_messages interface~get_messages->proc~get_messages_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~make_error_msg_ interface~get_unit_name get_unit_name interface~get_unit_name->proc~get_case_name_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_named_->interface~set_case_name proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_array interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ proc~run_test_case_ run_test_case_ interface~run_test_case->proc~run_test_case_ interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ proc~run_test_case_->proc~run_test_case_named_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ var panprocstrip_CalledByGraph = svgPanZoom('#procstrip_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strip_ Source Code function strip_ ( value ) implicit none character ( len = 500 ) :: strip_ character ( len =* ), intent ( in ) :: value strip_ = trim ( adjustl ( value )) end function strip_","tags":"","loc":"proc/strip_.html"},{"title":"strip_length_ – naturalFRUIT","text":"private function strip_length_(value, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value integer, intent(in) :: length Return Value character(len=length) Called by proc~~strip_length_~~CalledByGraph proc~strip_length_ strip_length_ interface~strip strip interface~strip->proc~strip_length_ proc~get_case_name_ get_case_name_ proc~get_case_name_->interface~strip proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~strip proc~set_case_name_ set_case_name_ proc~set_case_name_->interface~strip proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~strip proc~case_failed_xml_ case_failed_xml_ proc~case_failed_xml_->interface~strip proc~get_messages_ get_messages_ proc~get_messages_->interface~strip proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~strip proc~fruit_summary_ fruit_summary_ proc~fruit_summary_->interface~strip proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~strip proc~get_message_array_ get_message_array_ proc~get_message_array_->interface~strip proc~make_error_msg_ make_error_msg_ proc~make_error_msg_->interface~strip proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~strip proc~get_last_message get_last_message proc~get_last_message->interface~strip proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~strip interface~set_unit_name set_unit_name interface~set_unit_name->proc~set_case_name_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_2d_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_2d_string_ interface~case_failed_xml case_failed_xml interface~case_failed_xml->proc~case_failed_xml_ proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ interface~get_case_name get_case_name interface~get_case_name->proc~get_case_name_ interface~fruit_summary fruit_summary interface~fruit_summary->proc~fruit_summary_ interface~get_message_array get_message_array interface~get_message_array->proc~get_message_array_ interface~set_case_name set_case_name interface~set_case_name->proc~set_case_name_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~get_messages get_messages interface~get_messages->proc~get_messages_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~make_error_msg_ interface~get_unit_name get_unit_name interface~get_unit_name->proc~get_case_name_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_named_->interface~set_case_name proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_array interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ proc~run_test_case_ run_test_case_ interface~run_test_case->proc~run_test_case_ interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ proc~run_test_case_->proc~run_test_case_named_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ var panprocstrip_length_CalledByGraph = svgPanZoom('#procstrip_length_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code strip_length_ Source Code function strip_length_ ( value , length ) implicit none character ( len =* ), intent ( in ) :: value integer , intent ( in ) :: length character ( len = length ) :: strip_length_ strip_length_ = trim ( adjustl ( value )) end function strip_length_","tags":"","loc":"proc/strip_length_.html"},{"title":"equalEpsilon – naturalFRUIT","text":"private function equalEpsilon(number1, number2, epsilon) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 real, intent(in) :: epsilon Return Value logical Called by proc~~equalepsilon~~CalledByGraph proc~equalepsilon equalEpsilon interface~equals equals interface~equals->proc~equalepsilon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code equalEpsilon Source Code function equalEpsilon ( number1 , number2 , epsilon ) result ( resultValue ) real , intent ( in ) :: number1 , number2 , epsilon logical :: resultValue resultValue = . false . ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function equalEpsilon","tags":"","loc":"proc/equalepsilon.html"},{"title":"floatEqual – naturalFRUIT","text":"private function floatEqual(number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 Return Value logical Called by proc~~floatequal~~CalledByGraph proc~floatequal floatEqual interface~equals equals interface~equals->proc~floatequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code floatEqual Source Code function floatEqual ( number1 , number2 ) result ( resultValue ) real , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function floatEqual","tags":"","loc":"proc/floatequal.html"},{"title":"doublePrecisionEqual – naturalFRUIT","text":"private function doublePrecisionEqual(number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: number1 double precision, intent(in) :: number2 Return Value logical Called by proc~~doubleprecisionequal~~CalledByGraph proc~doubleprecisionequal doublePrecisionEqual interface~equals equals interface~equals->proc~doubleprecisionequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code doublePrecisionEqual Source Code function doublePrecisionEqual ( number1 , number2 ) result ( resultValue ) double precision , intent ( in ) :: number1 , number2 real :: epsilon logical :: resultValue resultValue = . false . epsilon = 1E-6 !epsilon = epsilon (number1) ! test very small number1 if ( abs ( number1 ) < epsilon . and . abs ( number1 - number2 ) < epsilon ) then resultValue = . true . else if (( abs (( number1 - number2 )) / number1 ) < epsilon ) then resultValue = . true . else resultValue = . false . end if end if end function doublePrecisionEqual","tags":"","loc":"proc/doubleprecisionequal.html"},{"title":"integerEqual – naturalFRUIT","text":"private function integerEqual(number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number1 integer, intent(in) :: number2 Return Value logical Called by proc~~integerequal~~CalledByGraph proc~integerequal integerEqual interface~equals equals interface~equals->proc~integerequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code integerEqual Source Code function integerEqual ( number1 , number2 ) result ( resultValue ) integer , intent ( in ) :: number1 , number2 logical :: resultValue resultValue = . false . if ( number1 . eq . number2 ) then resultValue = . true . else resultValue = . false . end if end function integerEqual","tags":"","loc":"proc/integerequal.html"},{"title":"stringEqual – naturalFRUIT","text":"private function stringEqual(str1, str2) result(resultValue) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical Called by proc~~stringequal~~CalledByGraph proc~stringequal stringEqual interface~equals equals interface~equals->proc~stringequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code stringEqual Source Code function stringEqual ( str1 , str2 ) result ( resultValue ) character ( * ) , intent ( in ) :: str1 , str2 logical :: resultValue resultValue = . false . if ( str1 . eq . str2 ) then resultValue = . true . end if end function stringEqual","tags":"","loc":"proc/stringequal.html"},{"title":"logicalEqual – naturalFRUIT","text":"private function logicalEqual(l1, l2) result(resultValue) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l1 logical, intent(in) :: l2 Return Value logical Called by proc~~logicalequal~~CalledByGraph proc~logicalequal logicalEqual interface~equals equals interface~equals->proc~logicalequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code logicalEqual Source Code function logicalEqual ( l1 , l2 ) result ( resultValue ) logical , intent ( in ) :: l1 , l2 logical :: resultValue resultValue = . false . if ( l1 . eqv . l2 ) then resultValue = . true . end if end function logicalEqual","tags":"","loc":"proc/logicalequal.html"},{"title":"equals – naturalFRUIT","text":"public interface equals Calls interface~~equals~~CallsGraph interface~equals equals proc~doubleprecisionequal doublePrecisionEqual interface~equals->proc~doubleprecisionequal proc~stringequal stringEqual interface~equals->proc~stringequal proc~integerequal integerEqual interface~equals->proc~integerequal proc~logicalequal logicalEqual interface~equals->proc~logicalequal proc~equalepsilon equalEpsilon interface~equals->proc~equalepsilon proc~floatequal floatEqual interface~equals->proc~floatequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures equalEpsilon floatEqual integerEqual doublePrecisionEqual stringEqual logicalEqual Module Procedures private function equalEpsilon (number1, number2, epsilon) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 real, intent(in) :: epsilon Return Value logical private function floatEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 Return Value logical private function integerEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number1 integer, intent(in) :: number2 Return Value logical private function doublePrecisionEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: number1 double precision, intent(in) :: number2 Return Value logical private function stringEqual (str1, str2) result(resultValue) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private function logicalEqual (l1, l2) result(resultValue) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l1 logical, intent(in) :: l2 Return Value logical","tags":"","loc":"interface/equals.html"},{"title":"to_s – naturalFRUIT","text":"public interface to_s Calls interface~~to_s~~CallsGraph interface~to_s to_s proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~to_s~~CalledByGraph interface~to_s to_s proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->interface~to_s proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->interface~to_s proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->interface~to_s proc~assert_false_ assert_false_ proc~assert_false_->interface~to_s proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~to_s proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->interface~to_s proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->interface~to_s proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->interface~to_s proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->interface~to_s proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~to_s proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~to_s proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->interface~to_s proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~to_s proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->interface~to_s proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->interface~to_s proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->interface~to_s proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->interface~to_s proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->interface~to_s proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->interface~to_s proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->interface~to_s proc~assert_true assert_true proc~assert_true->interface~to_s proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->interface~to_s interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures to_s_int_ to_s_real_ to_s_logical_ to_s_double_ to_s_complex_ to_s_double_complex_ to_s_string_ Module Procedures private function to_s_int_ (value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=500) private function to_s_real_ (value) Arguments Type Intent Optional Attributes Name real, intent(in) :: value Return Value character(len=500) private function to_s_logical_ (value) Arguments Type Intent Optional Attributes Name logical, intent(in) :: value Return Value character(len=500) private function to_s_double_ (value) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value Return Value character(len=500) private function to_s_complex_ (value) Arguments Type Intent Optional Attributes Name complex, intent(in) :: value Return Value character(len=500) private function to_s_double_complex_ (value) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: value Return Value character(len=500) private function to_s_string_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500)","tags":"","loc":"interface/to_s.html"},{"title":"strip – naturalFRUIT","text":"public interface strip Calls interface~~strip~~CallsGraph interface~strip strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~strip~~CalledByGraph interface~strip strip proc~get_case_name_ get_case_name_ proc~get_case_name_->interface~strip proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->interface~strip proc~set_case_name_ set_case_name_ proc~set_case_name_->interface~strip proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->interface~strip proc~case_failed_xml_ case_failed_xml_ proc~case_failed_xml_->interface~strip proc~get_messages_ get_messages_ proc~get_messages_->interface~strip proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->interface~strip proc~fruit_summary_ fruit_summary_ proc~fruit_summary_->interface~strip proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->interface~strip proc~get_message_array_ get_message_array_ proc~get_message_array_->interface~strip proc~make_error_msg_ make_error_msg_ proc~make_error_msg_->interface~strip proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->interface~strip proc~get_last_message get_last_message proc~get_last_message->interface~strip proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->interface~strip interface~set_unit_name set_unit_name interface~set_unit_name->proc~set_case_name_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_2d_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_2d_string_ interface~case_failed_xml case_failed_xml interface~case_failed_xml->proc~case_failed_xml_ proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ interface~get_case_name get_case_name interface~get_case_name->proc~get_case_name_ interface~fruit_summary fruit_summary interface~fruit_summary->proc~fruit_summary_ interface~get_message_array get_message_array interface~get_message_array->proc~get_message_array_ interface~set_case_name set_case_name interface~set_case_name->proc~set_case_name_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~get_messages get_messages interface~get_messages->proc~get_messages_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~make_error_msg_ interface~get_unit_name get_unit_name interface~get_unit_name->proc~get_case_name_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_named_->interface~set_case_name proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_array interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ proc~run_test_case_ run_test_case_ interface~run_test_case->proc~run_test_case_ interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ proc~run_test_case_->proc~run_test_case_named_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ var paninterfacestripCalledByGraph = svgPanZoom('#interfacestripCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures strip_ strip_length_ Module Procedures private function strip_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) private function strip_length_ (value, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value integer, intent(in) :: length Return Value character(len=length)","tags":"","loc":"interface/strip.html"},{"title":"case_delta_t – naturalFRUIT","text":"private function case_delta_t() Arguments None Return Value character(len=STRLEN_T) Called by proc~~case_delta_t~~CalledByGraph proc~case_delta_t case_delta_t proc~case_passed_xml_ case_passed_xml_ proc~case_passed_xml_->proc~case_delta_t proc~case_failed_xml_ case_failed_xml_ proc~case_failed_xml_->proc~case_delta_t interface~case_failed_xml case_failed_xml interface~case_failed_xml->proc~case_failed_xml_ interface~case_passed_xml case_passed_xml interface~case_passed_xml->proc~case_passed_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code case_delta_t Source Code function case_delta_t () character ( len = STRLEN_T ) :: case_delta_t real :: delta_t integer :: case_time_to , time_rate , time_max call system_clock ( case_time_to , time_rate , time_max ) if ( time_rate > 0 ) then delta_t = real ( case_time_to - case_time_from ) / real ( time_rate ) if ( delta_t < 0 ) then delta_t = delta_t + real ( time_max ) / real ( time_rate ) endif else delta_t = 0 endif write ( case_delta_t , '(g12.4)' ) delta_t case_delta_t = adjustl ( case_delta_t ) end function case_delta_t","tags":"","loc":"proc/case_delta_t.html"},{"title":"int_to_str – naturalFRUIT","text":"private function int_to_str(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=NUMBER_LENGTH) Called by proc~~int_to_str~2~~CalledByGraph proc~int_to_str~2 int_to_str proc~fruit_summary_xml_ fruit_summary_xml_ proc~fruit_summary_xml_->proc~int_to_str~2 interface~fruit_summary_xml fruit_summary_xml interface~fruit_summary_xml->proc~fruit_summary_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code int_to_str Source Code function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str","tags":"","loc":"proc/int_to_str~2.html"},{"title":"fruit_if_case_failed_ – naturalFRUIT","text":"private function fruit_if_case_failed_() Arguments None Return Value logical Called by proc~~fruit_if_case_failed_~~CalledByGraph proc~fruit_if_case_failed_ fruit_if_case_failed_ interface~fruit_if_case_failed fruit_if_case_failed interface~fruit_if_case_failed->proc~fruit_if_case_failed_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_if_case_failed_ Source Code logical function fruit_if_case_failed_ () if ( failed_assert_count == 0 ) then fruit_if_case_failed_ = . false . return endif if ( case_passed ) then fruit_if_case_failed_ = . false . else fruit_if_case_failed_ = . true . endif end function fruit_if_case_failed_","tags":"","loc":"proc/fruit_if_case_failed_.html"},{"title":"get_last_message – naturalFRUIT","text":"public function get_last_message() Arguments None Return Value character(len=MSG_LENGTH) Calls proc~~get_last_message~~CallsGraph proc~get_last_message get_last_message interface~strip strip proc~get_last_message->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_last_message Source Code function get_last_message () character ( len = MSG_LENGTH ) :: get_last_message if ( message_index > 1 ) then get_last_message = strip ( message_array ( message_index - 1 ), MSG_LENGTH ) else get_last_message = '' end if end function get_last_message","tags":"","loc":"proc/get_last_message.html"},{"title":"is_last_passed – naturalFRUIT","text":"public function is_last_passed() Arguments None Return Value logical Contents Source Code is_last_passed Source Code function is_last_passed () logical :: is_last_passed is_last_passed = last_passed end function is_last_passed","tags":"","loc":"proc/is_last_passed.html"},{"title":"is_case_passed – naturalFRUIT","text":"public function is_case_passed() Arguments None Return Value logical Contents Source Code is_case_passed Source Code function is_case_passed () logical :: is_case_passed is_case_passed = case_passed end function is_case_passed","tags":"","loc":"proc/is_case_passed.html"},{"title":"init_fruit – naturalFRUIT","text":"public subroutine init_fruit(rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank Called by proc~~init_fruit~~CalledByGraph proc~init_fruit init_fruit proc~obsolete_initializefruit_ obsolete_initializeFruit_ proc~obsolete_initializefruit_->proc~init_fruit interface~initializefruit initializeFruit interface~initializefruit->proc~obsolete_initializefruit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code init_fruit Source Code subroutine init_fruit ( rank ) integer , intent ( in ), optional :: rank logical :: if_write successful_assert_count = 0 failed_assert_count = 0 message_index = 1 message_index_from = 1 if_write = . true . if ( present ( rank )) then if ( rank /= 0 ) if_write = . false . endif if ( if_write ) then write ( stdout , * ) write ( stdout , * ) \"Test module initialized\" write ( stdout , * ) write ( stdout , * ) \"   . : successful assert,   F : failed assert \" write ( stdout , * ) endif !$omp critical     (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if ( . not . allocated ( message_array ) ) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) end subroutine init_fruit","tags":"","loc":"proc/init_fruit.html"},{"title":"fruit_finalize_ – naturalFRUIT","text":"private subroutine fruit_finalize_() Arguments None Called by proc~~fruit_finalize_~~CalledByGraph proc~fruit_finalize_ fruit_finalize_ interface~fruit_finalize fruit_finalize interface~fruit_finalize->proc~fruit_finalize_ proc~fruit_finalize_mpi_ fruit_finalize_mpi_ proc~fruit_finalize_mpi_->interface~fruit_finalize interface~fruit_finalize_mpi fruit_finalize_mpi interface~fruit_finalize_mpi->proc~fruit_finalize_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_finalize_ Source Code subroutine fruit_finalize_ !$omp critical     (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) if ( allocated ( message_array )) then deallocate ( message_array ) endif !$omp end critical (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) end subroutine fruit_finalize_","tags":"","loc":"proc/fruit_finalize_.html"},{"title":"init_fruit_xml_ – naturalFRUIT","text":"private subroutine init_fruit_xml_(rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank Called by proc~~init_fruit_xml_~~CalledByGraph proc~init_fruit_xml_ init_fruit_xml_ interface~init_fruit_xml init_fruit_xml interface~init_fruit_xml->proc~init_fruit_xml_ proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ proc~fruit_init_mpi_xml_->interface~init_fruit_xml interface~fruit_init_mpi_xml fruit_init_mpi_xml interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code init_fruit_xml_ Source Code subroutine init_fruit_xml_ ( rank ) integer , optional , intent ( in ) :: rank logical :: rank_zero_or_single rank_zero_or_single = . true . if ( present ( rank )) then if ( rank /= 0 ) then rank_zero_or_single = . false . endif endif if ( rank_zero_or_single ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite \")' , advance = \"no\" ) write ( XML_OPEN , '(      \"errors=\"\"0\"\" \"   )' , advance = \"no\" ) write ( XML_OPEN , '(      \"tests=\"\"1\"\" \"    )' , advance = \"no\" ) write ( XML_OPEN , '(      \"failures=\"\"1\"\" \" )' , advance = \"no\" ) write ( XML_OPEN , '(      \"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) \"name of test suite\" write ( XML_OPEN , '(      \"id=\"\"1\"\">\")' ) write ( XML_OPEN , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & \"dummy_testcase\" , \"dummy_classname\" , \"0\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"      <failure type=\"\"failure\"\" message=\"\"\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"FRUIT did not generate regular content of result.xml.\" write ( XML_OPEN , '(a)' ) \"\"\"/>\" write ( XML_OPEN , '(\"    </testcase>\")' ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif open ( xml_work , FILE = xml_filename_work , action = \"write\" , status = 'replace' ) close ( xml_work ) end subroutine init_fruit_xml_","tags":"","loc":"proc/init_fruit_xml_.html"},{"title":"case_passed_xml_ – naturalFRUIT","text":"private subroutine case_passed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname Calls proc~~case_passed_xml_~~CallsGraph proc~case_passed_xml_ case_passed_xml_ proc~case_delta_t case_delta_t proc~case_passed_xml_->proc~case_delta_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_passed_xml_~~CalledByGraph proc~case_passed_xml_ case_passed_xml_ interface~case_passed_xml case_passed_xml interface~case_passed_xml->proc~case_passed_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code case_passed_xml_ Source Code subroutine case_passed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\"/>\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) close ( xml_work ) end subroutine case_passed_xml_","tags":"","loc":"proc/case_passed_xml_.html"},{"title":"case_failed_xml_ – naturalFRUIT","text":"private subroutine case_failed_xml_(tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname Calls proc~~case_failed_xml_~~CallsGraph proc~case_failed_xml_ case_failed_xml_ proc~case_delta_t case_delta_t proc~case_failed_xml_->proc~case_delta_t interface~strip strip proc~case_failed_xml_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_failed_xml_~~CalledByGraph proc~case_failed_xml_ case_failed_xml_ interface~case_failed_xml case_failed_xml interface~case_failed_xml->proc~case_failed_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code case_failed_xml_ Source Code subroutine case_failed_xml_ ( tc_name , classname ) character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname integer :: i , j character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) write ( xml_work , '(\"      <failure type=\"\"failure\"\" message=\"\"\")' , advance = \"no\" ) do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > MAX_NUM_FAILURES_IN_XML ) then write ( xml_work , '(\"(omit the rest)\")' , advance = \"no\" ) exit endif write ( xml_work , '(a)' , advance = \"no\" ) trim ( strip ( message_array ( i ))) if ( i == message_index - 1 ) then continue else write ( xml_work , '(\"&#xA;\")' , advance = \"no\" ) endif enddo write ( xml_work , '(\"\"\"/>\")' ) write ( xml_work , & & '(\"    </testcase>\")' ) close ( xml_work ) end subroutine case_failed_xml_","tags":"","loc":"proc/case_failed_xml_.html"},{"title":"fruit_summary_xml_ – naturalFRUIT","text":"private subroutine fruit_summary_xml_() Arguments None Calls proc~~fruit_summary_xml_~~CallsGraph proc~fruit_summary_xml_ fruit_summary_xml_ proc~int_to_str~2 int_to_str proc~fruit_summary_xml_->proc~int_to_str~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_summary_xml_~~CalledByGraph proc~fruit_summary_xml_ fruit_summary_xml_ interface~fruit_summary_xml fruit_summary_xml interface~fruit_summary_xml->proc~fruit_summary_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_summary_xml_ Source Code subroutine fruit_summary_xml_ character ( len = XML_LINE_LENGTH ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count full_count = int_to_str ( successful_case_count + failed_case_count ) fail_count = int_to_str ( failed_case_count ) open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) open ( xml_work , FILE = xml_filename_work ) do read ( xml_work , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( xml_work ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) end subroutine fruit_summary_xml_","tags":"","loc":"proc/fruit_summary_xml_.html"},{"title":"obsolete_initializeFruit_ – naturalFRUIT","text":"private subroutine obsolete_initializeFruit_() Arguments None Calls proc~~obsolete_initializefruit_~~CallsGraph proc~obsolete_initializefruit_ obsolete_initializeFruit_ proc~obsolete_ obsolete_ proc~obsolete_initializefruit_->proc~obsolete_ proc~init_fruit init_fruit proc~obsolete_initializefruit_->proc~init_fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_initializefruit_~~CalledByGraph proc~obsolete_initializefruit_ obsolete_initializeFruit_ interface~initializefruit initializeFruit interface~initializefruit->proc~obsolete_initializefruit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_initializeFruit_ Source Code subroutine obsolete_initializeFruit_ call obsolete_ ( \"initializeFruit is OBSOLETE.  replaced by init_fruit\" ) call init_fruit end subroutine obsolete_initializeFruit_","tags":"","loc":"proc/obsolete_initializefruit_.html"},{"title":"obsolete_getTestSummary_ – naturalFRUIT","text":"private subroutine obsolete_getTestSummary_() Arguments None Calls proc~~obsolete_gettestsummary_~~CallsGraph proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~fruit_summary_ fruit_summary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ proc~obsolete_ obsolete_ proc~obsolete_gettestsummary_->proc~obsolete_ proc~fruit_summary_table_ fruit_summary_table_ proc~fruit_summary_->proc~fruit_summary_table_ interface~strip strip proc~fruit_summary_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_gettestsummary_~~CalledByGraph proc~obsolete_gettestsummary_ obsolete_getTestSummary_ interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_getTestSummary_ Source Code subroutine obsolete_getTestSummary_ call obsolete_ ( \"getTestSummary is OBSOLETE.  replaced by fruit_summary\" ) call fruit_summary_ end subroutine obsolete_getTestSummary_","tags":"","loc":"proc/obsolete_gettestsummary_.html"},{"title":"fruit_show_dots_ – naturalFRUIT","text":"private subroutine fruit_show_dots_() Arguments None Called by proc~~fruit_show_dots_~~CalledByGraph proc~fruit_show_dots_ fruit_show_dots_ interface~fruit_show_dots fruit_show_dots interface~fruit_show_dots->proc~fruit_show_dots_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_show_dots_ Source Code subroutine fruit_show_dots_ if_show_dots = . true . end subroutine fruit_show_dots_","tags":"","loc":"proc/fruit_show_dots_.html"},{"title":"fruit_hide_dots_ – naturalFRUIT","text":"private subroutine fruit_hide_dots_() Arguments None Called by proc~~fruit_hide_dots_~~CalledByGraph proc~fruit_hide_dots_ fruit_hide_dots_ interface~fruit_hide_dots fruit_hide_dots interface~fruit_hide_dots->proc~fruit_hide_dots_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_hide_dots_ Source Code subroutine fruit_hide_dots_ if_show_dots = . false . end subroutine fruit_hide_dots_","tags":"","loc":"proc/fruit_hide_dots_.html"},{"title":"run_test_case_named_ – naturalFRUIT","text":"private subroutine run_test_case_named_(tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name Calls proc~~run_test_case_named_~~CallsGraph proc~run_test_case_named_ run_test_case_named_ interface~set_case_name set_case_name proc~run_test_case_named_->interface~set_case_name proc~set_case_name_ set_case_name_ interface~set_case_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~run_test_case_named_~~CalledByGraph proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_ run_test_case_ proc~run_test_case_->proc~run_test_case_named_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ interface~run_test_case->proc~run_test_case_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code run_test_case_named_ Source Code subroutine run_test_case_named_ ( tc , tc_name ) interface subroutine tc () end subroutine end interface character ( * ), intent ( in ) :: tc_name integer :: initial_failed_assert_count initial_failed_assert_count = failed_assert_count ! Set the name of the unit test call set_case_name ( tc_name ) last_passed = . true . case_passed = . true . linechar_count = 0 !! reset linechar_count for each test case. message_index_from = message_index call system_clock ( case_time_from ) !$OMP BARRIER !!! \"case_passed\" is true here. !!! \"case_passed\" becomes .false. at the first fail of assertion call tc () !$OMP BARRIER if ( initial_failed_assert_count . eq . failed_assert_count ) then ! If no additional assertions failed during the run of this test case ! then the test case was successful successful_case_count = successful_case_count + 1 else failed_case_count = failed_case_count + 1 end if testCaseIndex = testCaseIndex + 1 ! Reset the name of the unit test back to the default call set_case_name ( DEFAULT_CASE_NAME ) end subroutine run_test_case_named_","tags":"","loc":"proc/run_test_case_named_.html"},{"title":"run_test_case_ – naturalFRUIT","text":"private subroutine run_test_case_(tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None Calls proc~~run_test_case_~~CallsGraph proc~run_test_case_ run_test_case_ proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_->proc~run_test_case_named_ interface~set_case_name set_case_name proc~run_test_case_named_->interface~set_case_name proc~set_case_name_ set_case_name_ interface~set_case_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var panprocrun_test_case_CallsGraph = svgPanZoom('#procrun_test_case_CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~run_test_case_~~CalledByGraph proc~run_test_case_ run_test_case_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code run_test_case_ Source Code subroutine run_test_case_ ( tc ) interface subroutine tc () end subroutine end interface call run_test_case_named_ ( tc , '_unnamed_' ) end subroutine run_test_case_","tags":"","loc":"proc/run_test_case_.html"},{"title":"fruit_summary_ – naturalFRUIT","text":"private subroutine fruit_summary_() Arguments None Calls proc~~fruit_summary_~~CallsGraph proc~fruit_summary_ fruit_summary_ proc~fruit_summary_table_ fruit_summary_table_ proc~fruit_summary_->proc~fruit_summary_table_ interface~strip strip proc~fruit_summary_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fruit_summary_~~CalledByGraph proc~fruit_summary_ fruit_summary_ interface~fruit_summary fruit_summary interface~fruit_summary->proc~fruit_summary_ proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_summary_ Source Code subroutine fruit_summary_ integer :: i write ( stdout , * ) write ( stdout , * ) write ( stdout , * ) '    Start of FRUIT summary: ' write ( stdout , * ) if ( failed_assert_count > 0 ) then write ( stdout , * ) 'Some tests failed!' else write ( stdout , * ) 'SUCCESSFUL!' end if write ( stdout , * ) if ( message_index > 1 ) then write ( stdout , * ) '  -- Failed assertion messages:' do i = 1 , message_index - 1 write ( stdout , \"(A)\" ) '   ' // trim ( strip ( message_array ( i ))) end do write ( stdout , * ) '  -- end of failed assertion messages.' write ( stdout , * ) else write ( stdout , * ) '  No messages ' end if if ( successful_assert_count + failed_assert_count /= 0 ) then call fruit_summary_table_ (& & successful_assert_count , failed_assert_count , & & successful_case_count , failed_case_count & &) end if write ( stdout , * ) '  -- end of FRUIT summary' end subroutine fruit_summary_","tags":"","loc":"proc/fruit_summary_.html"},{"title":"fruit_summary_table_ – naturalFRUIT","text":"private subroutine fruit_summary_table_(succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case Called by proc~~fruit_summary_table_~~CalledByGraph proc~fruit_summary_table_ fruit_summary_table_ proc~fruit_summary_ fruit_summary_ proc~fruit_summary_->proc~fruit_summary_table_ interface~fruit_summary_table fruit_summary_table interface~fruit_summary_table->proc~fruit_summary_table_ interface~fruit_summary fruit_summary interface~fruit_summary->proc~fruit_summary_ proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~fruit_summary_table proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fruit_summary_table_ Source Code subroutine fruit_summary_table_ (& & succ_assert , fail_assert , & & succ_case , fail_case & &) integer , intent ( in ) :: succ_assert , fail_assert integer , intent ( in ) :: succ_case , fail_case write ( stdout , * ) 'Total asserts :   ' , succ_assert + fail_assert write ( stdout , * ) 'Successful    :   ' , succ_assert write ( stdout , * ) 'Failed        :   ' , fail_assert write ( stdout , '(\"Successful rate:   \",f6.2,\"%\")' ) real ( succ_assert ) * 10 0.0 / & real ( succ_assert + fail_assert ) write ( stdout , * ) write ( stdout , * ) 'Successful asserts / total asserts : [ ' ,& succ_assert , '/' , succ_assert + fail_assert , ' ]' write ( stdout , * ) 'Successful cases   / total cases   : [ ' , succ_case , '/' , & succ_case + fail_case , ' ]' end subroutine fruit_summary_table_","tags":"","loc":"proc/fruit_summary_table_.html"},{"title":"obsolete_addSuccess_ – naturalFRUIT","text":"private subroutine obsolete_addSuccess_() Arguments None Calls proc~~obsolete_addsuccess_~~CallsGraph proc~obsolete_addsuccess_ obsolete_addSuccess_ proc~obsolete_ obsolete_ proc~obsolete_addsuccess_->proc~obsolete_ proc~add_success add_success proc~obsolete_addsuccess_->proc~add_success proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_addsuccess_~~CalledByGraph proc~obsolete_addsuccess_ obsolete_addSuccess_ interface~addsuccess addSuccess interface~addsuccess->proc~obsolete_addsuccess_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_addSuccess_ Source Code subroutine obsolete_addSuccess_ call obsolete_ ( \"addSuccess is OBSOLETE.  replaced by add_success\" ) call add_success end subroutine obsolete_addSuccess_","tags":"","loc":"proc/obsolete_addsuccess_.html"},{"title":"add_fail_ – naturalFRUIT","text":"private subroutine add_fail_(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Calls proc~~add_fail_~~CallsGraph proc~add_fail_ add_fail_ proc~failed_assert_action failed_assert_action proc~add_fail_->proc~failed_assert_action proc~failed_mark_ failed_mark_ proc~failed_assert_action->proc~failed_mark_ proc~make_error_msg_ make_error_msg_ proc~failed_assert_action->proc~make_error_msg_ proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action->proc~increase_message_stack_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_fail_~~CalledByGraph proc~add_fail_ add_fail_ proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add_fail_ Source Code subroutine add_fail_ ( message ) character ( * ), intent ( in ), optional :: message call failed_assert_action ( 'none' , 'none' , message , if_is = . true .) end subroutine add_fail_","tags":"","loc":"proc/add_fail_.html"},{"title":"add_fail_unit_ – naturalFRUIT","text":"private subroutine add_fail_unit_(unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message Calls proc~~add_fail_unit_~~CallsGraph proc~add_fail_unit_ add_fail_unit_ proc~add_fail_ add_fail_ proc~add_fail_unit_->proc~add_fail_ proc~failed_assert_action failed_assert_action proc~add_fail_->proc~failed_assert_action proc~failed_mark_ failed_mark_ proc~failed_assert_action->proc~failed_mark_ proc~make_error_msg_ make_error_msg_ proc~failed_assert_action->proc~make_error_msg_ proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action->proc~increase_message_stack_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var panprocadd_fail_unit_CallsGraph = svgPanZoom('#procadd_fail_unit_CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_fail_unit_~~CalledByGraph proc~add_fail_unit_ add_fail_unit_ interface~addfail addFail interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add_fail_unit_ Source Code subroutine add_fail_unit_ ( unitName , message ) character ( * ), intent ( in ) :: unitName character ( * ), intent ( in ) :: message call add_fail_ ( \"[in \" // unitName // \"(fail)]: \" // message ) end subroutine add_fail_unit_","tags":"","loc":"proc/add_fail_unit_.html"},{"title":"obsolete_isAllSuccessful_ – naturalFRUIT","text":"private subroutine obsolete_isAllSuccessful_(result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result Calls proc~~obsolete_isallsuccessful_~~CallsGraph proc~obsolete_isallsuccessful_ obsolete_isAllSuccessful_ proc~obsolete_ obsolete_ proc~obsolete_isallsuccessful_->proc~obsolete_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_isallsuccessful_~~CalledByGraph proc~obsolete_isallsuccessful_ obsolete_isAllSuccessful_ interface~isallsuccessful isAllSuccessful interface~isallsuccessful->proc~obsolete_isallsuccessful_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_isAllSuccessful_ Source Code subroutine obsolete_isAllSuccessful_ ( result ) logical , intent ( out ) :: result call obsolete_ ( 'subroutine isAllSuccessful is changed to function is_all_successful.' ) result = ( failed_assert_count . eq . 0 ) end subroutine obsolete_isAllSuccessful_","tags":"","loc":"proc/obsolete_isallsuccessful_.html"},{"title":"is_all_successful – naturalFRUIT","text":"public subroutine is_all_successful(result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result Contents Source Code is_all_successful Source Code subroutine is_all_successful ( result ) logical , intent ( out ) :: result result = ( failed_assert_count . eq . 0 ) end subroutine is_all_successful","tags":"","loc":"proc/is_all_successful.html"},{"title":"output_mark_ – naturalFRUIT","text":"private subroutine output_mark_(chr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chr integer, save :: linechar_count = 0\n  Definition of linechar_count is moved to module,\n  so that it can be stashed and restored. Called by proc~~output_mark_~~CalledByGraph proc~output_mark_ output_mark_ proc~failed_mark_ failed_mark_ proc~failed_mark_->proc~output_mark_ proc~success_mark_ success_mark_ proc~success_mark_->proc~output_mark_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~failed_mark_ proc~add_success add_success proc~add_success->proc~success_mark_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->proc~add_success proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->proc~add_success proc~obsolete_addsuccess_ obsolete_addSuccess_ proc~obsolete_addsuccess_->proc~add_success proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->proc~add_success proc~assert_false_ assert_false_ proc~assert_false_->proc~add_success proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->proc~add_success proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->proc~add_success proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->proc~add_success proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->proc~add_success proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->proc~add_success proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->proc~add_success proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->proc~add_success proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->proc~add_success proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->proc~add_success proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->proc~add_success proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->proc~add_success proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->proc~add_success proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->proc~add_success proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->proc~add_success proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->proc~add_success proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->proc~add_success proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->proc~add_success proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->proc~add_success proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->proc~add_success proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->proc~add_success proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->proc~add_success proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->proc~add_success proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->proc~add_success proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->proc~add_success proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->proc~add_success proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->proc~add_success proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->proc~add_success proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->proc~add_success proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->proc~add_success proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->proc~add_success proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->proc~add_success proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->proc~add_success proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->proc~add_success proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->proc~add_success proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->proc~add_success proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->proc~add_success proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->proc~add_success proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->proc~add_success proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->proc~add_success proc~assert_true assert_true proc~assert_true->proc~add_success proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->proc~add_success proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->proc~add_success proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->proc~add_success proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->proc~add_success proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~addsuccess addSuccess interface~addsuccess->proc~obsolete_addsuccess_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocoutput_mark_CalledByGraph = svgPanZoom('#procoutput_mark_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code output_mark_ Source Code subroutine output_mark_ ( chr ) character ( 1 ), intent ( in ) :: chr !!  integer, save :: linechar_count = 0 !!  Definition of linechar_count is moved to module, !!  so that it can be stashed and restored. !$omp critical      (FRUIT_OMP_ADD_OUTPUT_MARK) linechar_count = linechar_count + 1 if ( linechar_count . lt . MAX_MARKS_PER_LINE ) then write ( stdout , \"(A1)\" , ADVANCE = 'NO' ) chr else write ( stdout , \"(A1)\" , ADVANCE = 'YES' ) chr linechar_count = 0 endif !$omp end critical  (FRUIT_OMP_ADD_OUTPUT_MARK) end subroutine output_mark_","tags":"","loc":"proc/output_mark_.html"},{"title":"success_mark_ – naturalFRUIT","text":"private subroutine success_mark_() Arguments None Calls proc~~success_mark_~~CallsGraph proc~success_mark_ success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~success_mark_~~CalledByGraph proc~success_mark_ success_mark_ proc~add_success add_success proc~add_success->proc~success_mark_ proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->proc~add_success proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->proc~add_success proc~obsolete_addsuccess_ obsolete_addSuccess_ proc~obsolete_addsuccess_->proc~add_success proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->proc~add_success proc~assert_false_ assert_false_ proc~assert_false_->proc~add_success proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->proc~add_success proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->proc~add_success proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->proc~add_success proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->proc~add_success proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->proc~add_success proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->proc~add_success proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->proc~add_success proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->proc~add_success proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->proc~add_success proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->proc~add_success proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->proc~add_success proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->proc~add_success proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->proc~add_success proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->proc~add_success proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->proc~add_success proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->proc~add_success proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->proc~add_success proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->proc~add_success proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->proc~add_success proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->proc~add_success proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->proc~add_success proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->proc~add_success proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->proc~add_success proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->proc~add_success proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->proc~add_success proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->proc~add_success proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->proc~add_success proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->proc~add_success proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->proc~add_success proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->proc~add_success proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->proc~add_success proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->proc~add_success proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->proc~add_success proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->proc~add_success proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->proc~add_success proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->proc~add_success proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->proc~add_success proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->proc~add_success proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->proc~add_success proc~assert_true assert_true proc~assert_true->proc~add_success proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->proc~add_success proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->proc~add_success proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->proc~add_success proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->proc~add_success interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ interface~addsuccess addSuccess interface~addsuccess->proc~obsolete_addsuccess_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ var panprocsuccess_mark_CalledByGraph = svgPanZoom('#procsuccess_mark_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code success_mark_ Source Code subroutine success_mark_ call output_mark_ ( '.' ) end subroutine success_mark_","tags":"","loc":"proc/success_mark_.html"},{"title":"failed_mark_ – naturalFRUIT","text":"private subroutine failed_mark_() Arguments None Calls proc~~failed_mark_~~CallsGraph proc~failed_mark_ failed_mark_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~failed_mark_~~CalledByGraph proc~failed_mark_ failed_mark_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~failed_mark_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code failed_mark_ Source Code subroutine failed_mark_ call output_mark_ ( 'F' ) end subroutine failed_mark_","tags":"","loc":"proc/failed_mark_.html"},{"title":"increase_message_stack_ – naturalFRUIT","text":"private subroutine increase_message_stack_() Arguments None Called by proc~~increase_message_stack_~~CalledByGraph proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~increase_message_stack_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code increase_message_stack_ Source Code subroutine increase_message_stack_ character ( len = MSG_LENGTH ) :: msg_swap_holder ( current_max ) if ( message_index > MAX_MSG_STACK_SIZE ) then return end if if ( message_index > current_max ) then msg_swap_holder ( 1 : current_max ) = message_array ( 1 : current_max ) deallocate ( message_array ) current_max = current_max + MSG_ARRAY_INCREMENT allocate ( message_array ( current_max )) message_array ( 1 : current_max - MSG_ARRAY_INCREMENT ) & = msg_swap_holder ( 1 : current_max - MSG_ARRAY_INCREMENT ) end if message_array ( message_index ) = msg if ( message_index == MAX_MSG_STACK_SIZE ) then message_array ( message_index ) = \"Max number of messages reached. Further messages suppressed.\" endif message_index = message_index + 1 if ( message_index > MAX_MSG_STACK_SIZE ) then write ( stdout , * ) \"Stop because there are too many error messages to put into stack.\" write ( stdout , * ) \"Try to increase MAX_MSG_STACK_SIZE if you really need so.\" end if end subroutine increase_message_stack_","tags":"","loc":"proc/increase_message_stack_.html"},{"title":"get_xml_filename_work_ – naturalFRUIT","text":"private subroutine get_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string Called by proc~~get_xml_filename_work_~~CalledByGraph proc~get_xml_filename_work_ get_xml_filename_work_ interface~get_xml_filename_work get_xml_filename_work interface~get_xml_filename_work->proc~get_xml_filename_work_ proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ proc~fruit_summary_mpi_xml_->interface~get_xml_filename_work interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_xml_filename_work_ Source Code subroutine get_xml_filename_work_ ( string ) character ( len = * ), intent ( out ) :: string string = trim ( xml_filename_work ) end subroutine get_xml_filename_work_","tags":"","loc":"proc/get_xml_filename_work_.html"},{"title":"set_xml_filename_work_ – naturalFRUIT","text":"private subroutine set_xml_filename_work_(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Called by proc~~set_xml_filename_work_~~CalledByGraph proc~set_xml_filename_work_ set_xml_filename_work_ interface~set_xml_filename_work set_xml_filename_work interface~set_xml_filename_work->proc~set_xml_filename_work_ proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ proc~fruit_init_mpi_xml_->interface~set_xml_filename_work interface~fruit_init_mpi_xml fruit_init_mpi_xml interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_xml_filename_work_ Source Code subroutine set_xml_filename_work_ ( string ) character ( len = * ), intent ( in ) :: string xml_filename_work = trim ( string ) end subroutine set_xml_filename_work_","tags":"","loc":"proc/set_xml_filename_work_.html"},{"title":"get_message_index_ – naturalFRUIT","text":"private subroutine get_message_index_(index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index Called by proc~~get_message_index_~~CalledByGraph proc~get_message_index_ get_message_index_ interface~get_message_index get_message_index interface~get_message_index->proc~get_message_index_ proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_index interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_message_index_ Source Code subroutine get_message_index_ ( index ) integer , intent ( out ) :: index index = message_index end subroutine get_message_index_","tags":"","loc":"proc/get_message_index_.html"},{"title":"get_message_array_ – naturalFRUIT","text":"private subroutine get_message_array_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) Calls proc~~get_message_array_~~CallsGraph proc~get_message_array_ get_message_array_ interface~strip strip proc~get_message_array_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_message_array_~~CalledByGraph proc~get_message_array_ get_message_array_ interface~get_message_array get_message_array interface~get_message_array->proc~get_message_array_ proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_array interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_message_array_ Source Code subroutine get_message_array_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i msgs (:) = \"\" do i = 1 , message_index - 1 msgs ( i ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_message_array_","tags":"","loc":"proc/get_message_array_.html"},{"title":"get_messages_ – naturalFRUIT","text":"private subroutine get_messages_(msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) Calls proc~~get_messages_~~CallsGraph proc~get_messages_ get_messages_ interface~strip strip proc~get_messages_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_messages_~~CalledByGraph proc~get_messages_ get_messages_ interface~get_messages get_messages interface~get_messages->proc~get_messages_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_messages_ Source Code subroutine get_messages_ ( msgs ) character ( len = * ), intent ( out ) :: msgs (:) integer :: i , j msgs (:) = \"\" do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > ubound ( msgs , 1 )) exit msgs ( j ) = trim ( strip ( message_array ( i ))) enddo end subroutine get_messages_","tags":"","loc":"proc/get_messages_.html"},{"title":"obsolete_getTotalCount_ – naturalFRUIT","text":"private subroutine obsolete_getTotalCount_(count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Calls proc~~obsolete_gettotalcount_~~CallsGraph proc~obsolete_gettotalcount_ obsolete_getTotalCount_ proc~obsolete_ obsolete_ proc~obsolete_gettotalcount_->proc~obsolete_ proc~get_total_count get_total_count proc~obsolete_gettotalcount_->proc~get_total_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_gettotalcount_~~CalledByGraph proc~obsolete_gettotalcount_ obsolete_getTotalCount_ interface~gettotalcount getTotalCount interface~gettotalcount->proc~obsolete_gettotalcount_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_getTotalCount_ Source Code subroutine obsolete_getTotalCount_ ( count ) integer , intent ( out ) :: count call obsolete_ ( ' getTotalCount subroutine is replaced by function get_total_count' ) call get_total_count ( count ) end subroutine obsolete_getTotalCount_","tags":"","loc":"proc/obsolete_gettotalcount_.html"},{"title":"get_total_count – naturalFRUIT","text":"public subroutine get_total_count(count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Called by proc~~get_total_count~~CalledByGraph proc~get_total_count get_total_count proc~obsolete_gettotalcount_ obsolete_getTotalCount_ proc~obsolete_gettotalcount_->proc~get_total_count interface~gettotalcount getTotalCount interface~gettotalcount->proc~obsolete_gettotalcount_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_total_count Source Code subroutine get_total_count ( count ) integer , intent ( out ) :: count count = successful_assert_count + failed_assert_count end subroutine get_total_count","tags":"","loc":"proc/get_total_count.html"},{"title":"obsolete_getFailedCount_ – naturalFRUIT","text":"private subroutine obsolete_getFailedCount_(count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Calls proc~~obsolete_getfailedcount_~~CallsGraph proc~obsolete_getfailedcount_ obsolete_getFailedCount_ proc~obsolete_ obsolete_ proc~obsolete_getfailedcount_->proc~obsolete_ proc~get_failed_count get_failed_count proc~obsolete_getfailedcount_->proc~get_failed_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_getfailedcount_~~CalledByGraph proc~obsolete_getfailedcount_ obsolete_getFailedCount_ interface~getfailedcount getFailedCount interface~getfailedcount->proc~obsolete_getfailedcount_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_getFailedCount_ Source Code subroutine obsolete_getFailedCount_ ( count ) integer , intent ( out ) :: count call obsolete_ ( ' getFailedCount subroutine is replaced by function get_failed_count' ) call get_failed_count ( count ) end subroutine obsolete_getFailedCount_","tags":"","loc":"proc/obsolete_getfailedcount_.html"},{"title":"get_failed_count – naturalFRUIT","text":"public subroutine get_failed_count(count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Called by proc~~get_failed_count~~CalledByGraph proc~get_failed_count get_failed_count proc~obsolete_getfailedcount_ obsolete_getFailedCount_ proc~obsolete_getfailedcount_->proc~get_failed_count interface~getfailedcount getFailedCount interface~getfailedcount->proc~obsolete_getfailedcount_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_failed_count Source Code subroutine get_failed_count ( count ) integer , intent ( out ) :: count count = failed_assert_count end subroutine get_failed_count","tags":"","loc":"proc/get_failed_count.html"},{"title":"obsolete_ – naturalFRUIT","text":"private subroutine obsolete_(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Called by proc~~obsolete_~~CalledByGraph proc~obsolete_ obsolete_ proc~obsolete_gettotalcount_ obsolete_getTotalCount_ proc~obsolete_gettotalcount_->proc~obsolete_ proc~obsolete_addsuccess_ obsolete_addSuccess_ proc~obsolete_addsuccess_->proc~obsolete_ proc~obsolete_gettestsummary_ obsolete_getTestSummary_ proc~obsolete_gettestsummary_->proc~obsolete_ proc~obsolete_getfailedcount_ obsolete_getFailedCount_ proc~obsolete_getfailedcount_->proc~obsolete_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~obsolete_ proc~obsolete_isallsuccessful_ obsolete_isAllSuccessful_ proc~obsolete_isallsuccessful_->proc~obsolete_ proc~obsolete_initializefruit_ obsolete_initializeFruit_ proc~obsolete_initializefruit_->proc~obsolete_ interface~gettestsummary getTestSummary interface~gettestsummary->proc~obsolete_gettestsummary_ interface~initializefruit initializeFruit interface~initializefruit->proc~obsolete_initializefruit_ interface~addsuccess addSuccess interface~addsuccess->proc~obsolete_addsuccess_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ interface~getfailedcount getFailedCount interface~getfailedcount->proc~obsolete_getfailedcount_ interface~isallsuccessful isAllSuccessful interface~isallsuccessful->proc~obsolete_isallsuccessful_ interface~gettotalcount getTotalCount interface~gettotalcount->proc~obsolete_gettotalcount_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_ Source Code subroutine obsolete_ ( message ) character ( * ), intent ( in ), optional :: message write ( stdout , * ) write ( stdout , * ) \"<<<<<<<<<<<<<<<<<<<<<<<<<< WARNING from FRUIT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" write ( stdout , * ) message write ( stdout , * ) write ( stdout , * ) \" old calls will be replaced in the next release in Jan 2009\" write ( stdout , * ) \" Naming convention for all the method calls are changed to: first_name from\" write ( stdout , * ) \" firstName.  Subroutines that will be deleted: assertEquals, assertNotEquals,\" write ( stdout , * ) \" assertTrue, addSuccessful, addFail, etc.\" write ( stdout , * ) \"<<<<<<<<<<<<<<<<<<<<<<<<<< WARNING from FRUIT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\" write ( stdout , * ) end subroutine obsolete_","tags":"","loc":"proc/obsolete_.html"},{"title":"add_success – naturalFRUIT","text":"public subroutine add_success() Arguments None Calls proc~~add_success~~CallsGraph proc~add_success add_success proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add_success~~CalledByGraph proc~add_success add_success proc~assert_not_equals_double_ assert_not_equals_double_ proc~assert_not_equals_double_->proc~add_success proc~assert_eq_2d_double_ assert_eq_2d_double_ proc~assert_eq_2d_double_->proc~add_success proc~obsolete_addsuccess_ obsolete_addSuccess_ proc~obsolete_addsuccess_->proc~add_success proc~assert_eq_logical_ assert_eq_logical_ proc~assert_eq_logical_->proc~add_success proc~assert_false_ assert_false_ proc~assert_false_->proc~add_success proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ proc~assert_not_equals_2d_complex_->proc~add_success proc~assert_eq_1d_real_ assert_eq_1d_real_ proc~assert_eq_1d_real_->proc~add_success proc~assert_eq_1d_logical_ assert_eq_1d_logical_ proc~assert_eq_1d_logical_->proc~add_success proc~assert_eq_2d_string_ assert_eq_2d_string_ proc~assert_eq_2d_string_->proc~add_success proc~assert_eq_2d_int_ assert_eq_2d_int_ proc~assert_eq_2d_int_->proc~add_success proc~assert_eq_1d_double_ assert_eq_1d_double_ proc~assert_eq_1d_double_->proc~add_success proc~assert_eq_complex_ assert_eq_complex_ proc~assert_eq_complex_->proc~add_success proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ proc~assert_eq_1d_double_in_range_->proc~add_success proc~assert_eq_2d_complex_ assert_eq_2d_complex_ proc~assert_eq_2d_complex_->proc~add_success proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ proc~assert_eq_1d_real_in_range_->proc~add_success proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ proc~assert_not_equals_1d_real_->proc~add_success proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ proc~assert_not_equals_2d_logical_->proc~add_success proc~assert_not_equals_logical_ assert_not_equals_logical_ proc~assert_not_equals_logical_->proc~add_success proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ proc~assert_not_equals_1d_logical_->proc~add_success proc~assert_eq_1d_string_ assert_eq_1d_string_ proc~assert_eq_1d_string_->proc~add_success proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ proc~assert_eq_complex_in_range_->proc~add_success proc~assert_not_equals_real_ assert_not_equals_real_ proc~assert_not_equals_real_->proc~add_success proc~assert_eq_double_ assert_eq_double_ proc~assert_eq_double_->proc~add_success proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~assert_eq_string_ assert_eq_string_ proc~assert_eq_string_->proc~add_success proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ proc~assert_not_equals_complex_in_range_->proc~add_success proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ proc~assert_not_equals_2d_string_->proc~add_success proc~assert_not_equals_complex_ assert_not_equals_complex_ proc~assert_not_equals_complex_->proc~add_success proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ proc~assert_not_equals_2d_int_->proc~add_success proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~assert_eq_real_in_range_ assert_eq_real_in_range_ proc~assert_eq_real_in_range_->proc~add_success proc~assert_eq_2d_logical_ assert_eq_2d_logical_ proc~assert_eq_2d_logical_->proc~add_success proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ proc~assert_not_equals_1d_double_->proc~add_success proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ proc~assert_not_equals_1d_string_->proc~add_success proc~assert_eq_int_ assert_eq_int_ proc~assert_eq_int_->proc~add_success proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ proc~assert_eq_2d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ proc~assert_not_equals_1d_complex_->proc~add_success proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~assert_not_equals_int_ assert_not_equals_int_ proc~assert_not_equals_int_->proc~add_success proc~assert_eq_1d_complex_ assert_eq_1d_complex_ proc~assert_eq_1d_complex_->proc~add_success proc~assert_eq_1d_int_ assert_eq_1d_int_ proc~assert_eq_1d_int_->proc~add_success proc~assert_not_equals_string_ assert_not_equals_string_ proc~assert_not_equals_string_->proc~add_success proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ proc~assert_not_equals_2d_real_->proc~add_success proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ proc~assert_eq_1d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ proc~assert_not_equals_1d_int_->proc~add_success proc~assert_eq_real_ assert_eq_real_ proc~assert_eq_real_->proc~add_success proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ proc~assert_not_equals_2d_double_->proc~add_success proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_in_range_->proc~add_success proc~assert_eq_2d_real_ assert_eq_2d_real_ proc~assert_eq_2d_real_->proc~add_success proc~assert_true assert_true proc~assert_true->proc~add_success proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ proc~assert_not_equals_real_in_range_->proc~add_success proc~assert_eq_double_in_range_ assert_eq_double_in_range_ proc~assert_eq_double_in_range_->proc~add_success proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ proc~assert_not_equals_double_in_range_->proc~add_success proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ proc~assert_eq_2d_double_in_range_->proc~add_success interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_logical_ interface~assert_equals->proc~assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_complex_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_double_ interface~assert_equals->proc~assert_eq_string_ interface~assert_equals->proc~assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_int_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_real_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ interface~assertequals->proc~assert_eq_logical_ interface~assertequals->proc~assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_int_ interface~assertequals->proc~assert_eq_1d_double_ interface~assertequals->proc~assert_eq_complex_ interface~assertequals->proc~assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_string_ interface~assertequals->proc~assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_double_ interface~assertequals->proc~assert_eq_string_ interface~assertequals->proc~assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_int_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_real_ interface~assertequals->proc~assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_ interface~assertequals->proc~assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ interface~addsuccess addSuccess interface~addsuccess->proc~obsolete_addsuccess_ proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code add_success Source Code subroutine add_success !$omp critical     (FRUIT_OMP_ADD_SUCCESS) successful_assert_count = successful_assert_count + 1 last_passed = . true . !$omp end critical (FRUIT_OMP_ADD_SUCCESS) if ( if_show_dots ) then call success_mark_ endif end subroutine add_success","tags":"","loc":"proc/add_success.html"},{"title":"failed_assert_action – naturalFRUIT","text":"public subroutine failed_assert_action(expected, got, message, if_is) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is Calls proc~~failed_assert_action~~CallsGraph proc~failed_assert_action failed_assert_action proc~failed_mark_ failed_mark_ proc~failed_assert_action->proc~failed_mark_ proc~make_error_msg_ make_error_msg_ proc~failed_assert_action->proc~make_error_msg_ proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action->proc~increase_message_stack_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~failed_assert_action~~CalledByGraph proc~failed_assert_action failed_assert_action proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code failed_assert_action Source Code subroutine failed_assert_action ( expected , got , message , if_is ) character ( * ), intent ( in ) :: expected , got character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: if_is !$omp critical     (FRUIT_OMP_ADD_FAIL) if ( present ( if_is )) then call make_error_msg_ ( expected , got , if_is , message ) else call make_error_msg_ ( expected , got , . true ., message ) endif call increase_message_stack_ failed_assert_count = failed_assert_count + 1 last_passed = . false . case_passed = . false . !$omp end critical (FRUIT_OMP_ADD_FAIL) call failed_mark_ end subroutine failed_assert_action","tags":"","loc":"proc/failed_assert_action.html"},{"title":"set_case_name_ – naturalFRUIT","text":"private subroutine set_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Calls proc~~set_case_name_~~CallsGraph proc~set_case_name_ set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_case_name_~~CalledByGraph proc~set_case_name_ set_case_name_ interface~set_case_name set_case_name interface~set_case_name->proc~set_case_name_ interface~set_unit_name set_unit_name interface~set_unit_name->proc~set_case_name_ proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_named_->interface~set_case_name proc~run_test_case_ run_test_case_ proc~run_test_case_->proc~run_test_case_named_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ interface~run_test_case->proc~run_test_case_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_case_name_ Source Code subroutine set_case_name_ ( value ) character ( * ), intent ( in ) :: value case_name = strip ( value , MSG_LENGTH ) end subroutine set_case_name_","tags":"","loc":"proc/set_case_name_.html"},{"title":"get_case_name_ – naturalFRUIT","text":"private subroutine get_case_name_(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value Calls proc~~get_case_name_~~CallsGraph proc~get_case_name_ get_case_name_ interface~strip strip proc~get_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_case_name_~~CalledByGraph proc~get_case_name_ get_case_name_ interface~get_case_name get_case_name interface~get_case_name->proc~get_case_name_ interface~get_unit_name get_unit_name interface~get_unit_name->proc~get_case_name_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_case_name_ Source Code subroutine get_case_name_ ( value ) character ( * ), intent ( out ) :: value value = strip ( case_name ) end subroutine get_case_name_","tags":"","loc":"proc/get_case_name_.html"},{"title":"make_error_msg_ – naturalFRUIT","text":"private subroutine make_error_msg_(var1, var2, if_is, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 logical, intent(in) :: if_is character(len=*), intent(in), optional :: message Calls proc~~make_error_msg_~~CallsGraph proc~make_error_msg_ make_error_msg_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_error_msg_~~CalledByGraph proc~make_error_msg_ make_error_msg_ proc~failed_assert_action failed_assert_action proc~failed_assert_action->proc~make_error_msg_ proc~add_fail_ add_fail_ proc~add_fail_->proc~failed_assert_action proc~add_fail_unit_ add_fail_unit_ proc~add_fail_unit_->proc~add_fail_ interface~addfail addFail interface~addfail->proc~add_fail_ interface~addfail->proc~add_fail_unit_ interface~add_fail add_fail interface~add_fail->proc~add_fail_ interface~add_fail->proc~add_fail_unit_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_error_msg_ Source Code subroutine make_error_msg_ ( var1 , var2 , if_is , message ) character ( * ), intent ( in ) :: var1 , var2 logical , intent ( in ) :: if_is character ( * ), intent ( in ), optional :: message msg = '[' // trim ( strip ( case_name )) // ']: ' if ( if_is ) then msg = trim ( msg ) // 'Expected' else msg = trim ( msg ) // 'Expected Not' endif msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var1 )) // '], ' msg = trim ( msg ) // \" \" // 'Got' msg = trim ( msg ) // \" \" // '[' // trim ( strip ( var2 )) // ']' if ( present ( message )) then msg = trim ( msg ) // '; User message: [' // trim ( message ) // ']' endif end subroutine make_error_msg_","tags":"","loc":"proc/make_error_msg_.html"},{"title":"override_stdout_ – naturalFRUIT","text":"private subroutine override_stdout_(write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename Called by proc~~override_stdout_~~CalledByGraph proc~override_stdout_ override_stdout_ interface~override_stdout override_stdout interface~override_stdout->proc~override_stdout_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code override_stdout_ Source Code subroutine override_stdout_ ( write_unit , filename ) integer , intent ( in ) :: write_unit character ( len = * ), intent ( in ) :: filename stdout = write_unit open ( stdout , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_stdout_","tags":"","loc":"proc/override_stdout_.html"},{"title":"override_xml_work_ – naturalFRUIT","text":"private subroutine override_xml_work_(new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename Called by proc~~override_xml_work_~~CalledByGraph proc~override_xml_work_ override_xml_work_ interface~override_xml_work override_xml_work interface~override_xml_work->proc~override_xml_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code override_xml_work_ Source Code subroutine override_xml_work_ ( new_unit , filename ) integer , intent ( in ) :: new_unit character ( len = * ), intent ( in ) :: filename xml_work = new_unit xml_filename_work = filename open ( xml_work , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_xml_work_","tags":"","loc":"proc/override_xml_work_.html"},{"title":"stash_test_suite – naturalFRUIT","text":"public subroutine stash_test_suite() Arguments None Contents Source Code stash_test_suite Source Code subroutine stash_test_suite stashed_suite % successful_assert_count = successful_assert_count successful_assert_count = 0 stashed_suite % failed_assert_count = failed_assert_count failed_assert_count = 0 allocate ( stashed_suite % message_array ( current_max )) stashed_suite % message_array ( 1 : message_index ) = & & message_array ( 1 : message_index ) deallocate ( message_array ) allocate ( message_array ( MSG_ARRAY_INCREMENT )) stashed_suite % message_index = message_index message_index = 1 stashed_suite % message_index_from = message_index_from message_index_from = 1 stashed_suite % current_max = current_max current_max = 50 stashed_suite % successful_case_count = successful_case_count successful_case_count = 0 stashed_suite % failed_case_count = failed_case_count failed_case_count = 0 stashed_suite % testCaseIndex = testCaseIndex testCaseIndex = 1 stashed_suite % case_name = case_name case_name = DEFAULT_CASE_NAME stashed_suite % last_passed = last_passed last_passed = . false . stashed_suite % case_passed = case_passed case_passed = DEFAULT_CASE_PASSED stashed_suite % case_time_from = case_time_from case_time_from = 0 stashed_suite % linechar_count = linechar_count linechar_count = 0 stashed_suite % if_show_dots = if_show_dots if_show_dots = . true . end subroutine stash_test_suite","tags":"","loc":"proc/stash_test_suite.html"},{"title":"restore_test_suite – naturalFRUIT","text":"public subroutine restore_test_suite() Arguments None Contents Source Code restore_test_suite Source Code subroutine restore_test_suite successful_assert_count = stashed_suite % successful_assert_count failed_assert_count = stashed_suite % failed_assert_count message_index = stashed_suite % message_index message_index_from = stashed_suite % message_index_from current_max = stashed_suite % current_max deallocate ( message_array ) allocate ( message_array ( current_max )) message_array ( 1 : message_index ) = & & stashed_suite % message_array ( 1 : message_index ) deallocate ( stashed_suite % message_array ) successful_case_count = stashed_suite % successful_case_count failed_case_count = stashed_suite % failed_case_count testCaseIndex = stashed_suite % testCaseIndex case_name = stashed_suite % case_name last_passed = stashed_suite % last_passed case_passed = stashed_suite % case_passed case_time_from = stashed_suite % case_time_from linechar_count = stashed_suite % linechar_count if_show_dots = stashed_suite % if_show_dots end subroutine restore_test_suite","tags":"","loc":"proc/restore_test_suite.html"},{"title":"end_override_stdout_ – naturalFRUIT","text":"private subroutine end_override_stdout_() Arguments None Called by proc~~end_override_stdout_~~CalledByGraph proc~end_override_stdout_ end_override_stdout_ interface~end_override_stdout end_override_stdout interface~end_override_stdout->proc~end_override_stdout_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code end_override_stdout_ Source Code subroutine end_override_stdout_ close ( stdout ) stdout = STDOUT_DEFAULT end subroutine end_override_stdout_","tags":"","loc":"proc/end_override_stdout_.html"},{"title":"end_override_xml_work_ – naturalFRUIT","text":"private subroutine end_override_xml_work_() Arguments None Called by proc~~end_override_xml_work_~~CalledByGraph proc~end_override_xml_work_ end_override_xml_work_ interface~end_override_xml_work end_override_xml_work interface~end_override_xml_work->proc~end_override_xml_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code end_override_xml_work_ Source Code subroutine end_override_xml_work_ close ( xml_work ) xml_work = XML_WORK_DEFAULT xml_filename_work = XML_FN_WORK_DEF end subroutine end_override_xml_work_","tags":"","loc":"proc/end_override_xml_work_.html"},{"title":"set_prefix_ – naturalFRUIT","text":"private subroutine set_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Called by proc~~set_prefix_~~CalledByGraph proc~set_prefix_ set_prefix_ interface~set_prefix set_prefix interface~set_prefix->proc~set_prefix_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code set_prefix_ Source Code subroutine set_prefix_ ( str ) character ( len = * ), intent ( in ) :: str character ( len = len_trim ( str )) :: str2 str2 = trim ( adjustl ( str )) if ( len_trim ( str2 ) <= FRUIT_PREFIX_LEN_MAX ) then prefix = str2 else prefix = str2 ( 1 : FRUIT_PREFIX_LEN_MAX ) endif end subroutine set_prefix_","tags":"","loc":"proc/set_prefix_.html"},{"title":"get_prefix_ – naturalFRUIT","text":"private subroutine get_prefix_(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str Called by proc~~get_prefix_~~CalledByGraph proc~get_prefix_ get_prefix_ interface~get_prefix get_prefix interface~get_prefix->proc~get_prefix_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_prefix_ Source Code subroutine get_prefix_ ( str ) character ( len = * ), intent ( out ) :: str if ( len ( str ) <= len ( prefix )) then str = trim ( prefix ) else str = prefix endif end subroutine get_prefix_","tags":"","loc":"proc/get_prefix_.html"},{"title":"get_assert_and_case_count_ – naturalFRUIT","text":"private subroutine get_assert_and_case_count_(fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case Called by proc~~get_assert_and_case_count_~~CalledByGraph proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count get_assert_and_case_count interface~get_assert_and_case_count->proc~get_assert_and_case_count_ proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ proc~fruit_summary_mpi_xml_->interface~get_assert_and_case_count proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_assert_and_case_count interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ var panprocget_assert_and_case_count_CalledByGraph = svgPanZoom('#procget_assert_and_case_count_CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_assert_and_case_count_ Source Code subroutine get_assert_and_case_count_ ( fail_assert , suc_assert , fail_case , suc_case ) integer , intent ( out ) :: fail_assert , suc_assert , fail_case , suc_case fail_assert = failed_assert_count suc_assert = successful_assert_count fail_case = failed_case_count suc_case = successful_case_count end subroutine get_assert_and_case_count_","tags":"","loc":"proc/get_assert_and_case_count_.html"},{"title":"obsolete_assert_true_logical_ – naturalFRUIT","text":"private subroutine obsolete_assert_true_logical_(var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message Calls proc~~obsolete_assert_true_logical_~~CallsGraph proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_ obsolete_ proc~obsolete_assert_true_logical_->proc~obsolete_ proc~assert_true assert_true proc~obsolete_assert_true_logical_->proc~assert_true interface~to_s to_s proc~assert_true->interface~to_s proc~add_success add_success proc~assert_true->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var panprocobsolete_assert_true_logical_CallsGraph = svgPanZoom('#procobsolete_assert_true_logical_CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~obsolete_assert_true_logical_~~CalledByGraph proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code obsolete_assert_true_logical_ Source Code subroutine obsolete_assert_true_logical_ ( var1 , message ) logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message call obsolete_ ( 'assertTrue subroutine is replaced by function assert_true' ) call assert_true ( var1 , message ) end subroutine obsolete_assert_true_logical_","tags":"","loc":"proc/obsolete_assert_true_logical_.html"},{"title":"assert_true – naturalFRUIT","text":"public subroutine assert_true(var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message Calls proc~~assert_true~~CallsGraph proc~assert_true assert_true interface~to_s to_s proc~assert_true->interface~to_s proc~add_success add_success proc~assert_true->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_true~~CalledByGraph proc~assert_true assert_true proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ proc~obsolete_assert_true_logical_->proc~assert_true interface~asserttrue assertTrue interface~asserttrue->proc~obsolete_assert_true_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_true Source Code subroutine assert_true ( var1 , message ) logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message if ( var1 . eqv . . true .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . true .) end if end subroutine assert_true","tags":"","loc":"proc/assert_true.html"},{"title":"assert_false_ – naturalFRUIT","text":"private subroutine assert_false_(var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message Calls proc~~assert_false_~~CallsGraph proc~assert_false_ assert_false_ interface~to_s to_s proc~assert_false_->interface~to_s proc~add_success add_success proc~assert_false_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_false_~~CalledByGraph proc~assert_false_ assert_false_ interface~assert_false assert_false interface~assert_false->proc~assert_false_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_false_ Source Code subroutine assert_false_ ( var1 , message ) logical , intent ( in ) :: var1 character ( len = * ), intent ( in ), optional :: message if ( var1 . eqv . . false .) then call add_success else call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . false .) endif end subroutine assert_false_","tags":"","loc":"proc/assert_false_.html"},{"title":"assert_eq_logical_ – naturalFRUIT","text":"private subroutine assert_eq_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_logical_~~CallsGraph proc~assert_eq_logical_ assert_eq_logical_ interface~to_s to_s proc~assert_eq_logical_->interface~to_s proc~add_success add_success proc~assert_eq_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_logical_~~CalledByGraph proc~assert_eq_logical_ assert_eq_logical_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_logical_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_logical_ Source Code subroutine assert_eq_logical_ ( var1 , var2 , message ) logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 . neqv . var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_logical_","tags":"","loc":"proc/assert_eq_logical_.html"},{"title":"assert_eq_1d_logical_ – naturalFRUIT","text":"private subroutine assert_eq_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_logical_~~CallsGraph proc~assert_eq_1d_logical_ assert_eq_1d_logical_ interface~to_s to_s proc~assert_eq_1d_logical_->interface~to_s proc~add_success add_success proc~assert_eq_1d_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_logical_~~CalledByGraph proc~assert_eq_1d_logical_ assert_eq_1d_logical_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_logical_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_logical_ Source Code subroutine assert_eq_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_logical_","tags":"","loc":"proc/assert_eq_1d_logical_.html"},{"title":"assert_eq_2d_logical_ – naturalFRUIT","text":"private subroutine assert_eq_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_logical_~~CallsGraph proc~assert_eq_2d_logical_ assert_eq_2d_logical_ interface~to_s to_s proc~assert_eq_2d_logical_->interface~to_s proc~add_success add_success proc~assert_eq_2d_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_logical_~~CalledByGraph proc~assert_eq_2d_logical_ assert_eq_2d_logical_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_logical_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_logical_ Source Code subroutine assert_eq_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_logical_","tags":"","loc":"proc/assert_eq_2d_logical_.html"},{"title":"assert_eq_string_ – naturalFRUIT","text":"private subroutine assert_eq_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_string_~~CallsGraph proc~assert_eq_string_ assert_eq_string_ interface~to_s to_s proc~assert_eq_string_->interface~to_s interface~strip strip proc~assert_eq_string_->interface~strip proc~add_success add_success proc~assert_eq_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_string_~~CalledByGraph proc~assert_eq_string_ assert_eq_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_string_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_string_ Source Code subroutine assert_eq_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_string_","tags":"","loc":"proc/assert_eq_string_.html"},{"title":"assert_eq_1d_string_ – naturalFRUIT","text":"private subroutine assert_eq_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_string_~~CallsGraph proc~assert_eq_1d_string_ assert_eq_1d_string_ interface~to_s to_s proc~assert_eq_1d_string_->interface~to_s interface~strip strip proc~assert_eq_1d_string_->interface~strip proc~add_success add_success proc~assert_eq_1d_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_string_~~CalledByGraph proc~assert_eq_1d_string_ assert_eq_1d_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_string_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_string_ Source Code subroutine assert_eq_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_string_","tags":"","loc":"proc/assert_eq_1d_string_.html"},{"title":"assert_eq_2d_string_ – naturalFRUIT","text":"private subroutine assert_eq_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_string_~~CallsGraph proc~assert_eq_2d_string_ assert_eq_2d_string_ interface~to_s to_s proc~assert_eq_2d_string_->interface~to_s interface~strip strip proc~assert_eq_2d_string_->interface~strip proc~add_success add_success proc~assert_eq_2d_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_string_~~CalledByGraph proc~assert_eq_2d_string_ assert_eq_2d_string_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_string_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_string_ Source Code subroutine assert_eq_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_string_","tags":"","loc":"proc/assert_eq_2d_string_.html"},{"title":"assert_eq_int_ – naturalFRUIT","text":"private subroutine assert_eq_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_int_~~CallsGraph proc~assert_eq_int_ assert_eq_int_ interface~to_s to_s proc~assert_eq_int_->interface~to_s proc~add_success add_success proc~assert_eq_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_int_~~CalledByGraph proc~assert_eq_int_ assert_eq_int_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_int_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_int_ Source Code subroutine assert_eq_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if ( var1 /= var2 ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_int_","tags":"","loc":"proc/assert_eq_int_.html"},{"title":"assert_eq_1d_int_ – naturalFRUIT","text":"private subroutine assert_eq_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_int_~~CallsGraph proc~assert_eq_1d_int_ assert_eq_1d_int_ interface~to_s to_s proc~assert_eq_1d_int_->interface~to_s proc~add_success add_success proc~assert_eq_1d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_int_~~CalledByGraph proc~assert_eq_1d_int_ assert_eq_1d_int_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_int_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_int_ Source Code subroutine assert_eq_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_int_","tags":"","loc":"proc/assert_eq_1d_int_.html"},{"title":"assert_eq_2d_int_ – naturalFRUIT","text":"private subroutine assert_eq_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_int_~~CallsGraph proc~assert_eq_2d_int_ assert_eq_2d_int_ interface~to_s to_s proc~assert_eq_2d_int_->interface~to_s proc~add_success add_success proc~assert_eq_2d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_int_~~CalledByGraph proc~assert_eq_2d_int_ assert_eq_2d_int_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_int_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_int_ Source Code subroutine assert_eq_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_int_","tags":"","loc":"proc/assert_eq_2d_int_.html"},{"title":"assert_eq_real_ – naturalFRUIT","text":"private subroutine assert_eq_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_real_~~CallsGraph proc~assert_eq_real_ assert_eq_real_ interface~to_s to_s proc~assert_eq_real_->interface~to_s proc~add_success add_success proc~assert_eq_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_real_~~CalledByGraph proc~assert_eq_real_ assert_eq_real_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_real_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_real_ Source Code subroutine assert_eq_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_","tags":"","loc":"proc/assert_eq_real_.html"},{"title":"assert_eq_real_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_real_in_range_~~CallsGraph proc~assert_eq_real_in_range_ assert_eq_real_in_range_ interface~to_s to_s proc~assert_eq_real_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_real_in_range_~~CalledByGraph proc~assert_eq_real_in_range_ assert_eq_real_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_real_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_real_in_range_ Source Code subroutine assert_eq_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_real_in_range_","tags":"","loc":"proc/assert_eq_real_in_range_.html"},{"title":"assert_eq_1d_real_ – naturalFRUIT","text":"private subroutine assert_eq_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_real_~~CallsGraph proc~assert_eq_1d_real_ assert_eq_1d_real_ interface~to_s to_s proc~assert_eq_1d_real_->interface~to_s proc~add_success add_success proc~assert_eq_1d_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_real_~~CalledByGraph proc~assert_eq_1d_real_ assert_eq_1d_real_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_real_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_real_ Source Code subroutine assert_eq_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_","tags":"","loc":"proc/assert_eq_1d_real_.html"},{"title":"assert_eq_1d_real_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_real_in_range_~~CallsGraph proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ interface~to_s to_s proc~assert_eq_1d_real_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_1d_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_real_in_range_~~CalledByGraph proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_real_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_real_in_range_ Source Code subroutine assert_eq_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_real_in_range_","tags":"","loc":"proc/assert_eq_1d_real_in_range_.html"},{"title":"assert_eq_2d_real_ – naturalFRUIT","text":"private subroutine assert_eq_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_real_~~CallsGraph proc~assert_eq_2d_real_ assert_eq_2d_real_ interface~to_s to_s proc~assert_eq_2d_real_->interface~to_s proc~add_success add_success proc~assert_eq_2d_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_real_~~CalledByGraph proc~assert_eq_2d_real_ assert_eq_2d_real_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_real_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_real_ Source Code subroutine assert_eq_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_","tags":"","loc":"proc/assert_eq_2d_real_.html"},{"title":"assert_eq_2d_real_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_real_in_range_~~CallsGraph proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ interface~to_s to_s proc~assert_eq_2d_real_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_2d_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_real_in_range_~~CalledByGraph proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_real_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_real_in_range_ Source Code subroutine assert_eq_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_real_in_range_","tags":"","loc":"proc/assert_eq_2d_real_in_range_.html"},{"title":"assert_eq_double_ – naturalFRUIT","text":"private subroutine assert_eq_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_double_~~CallsGraph proc~assert_eq_double_ assert_eq_double_ interface~to_s to_s proc~assert_eq_double_->interface~to_s proc~add_success add_success proc~assert_eq_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_double_~~CalledByGraph proc~assert_eq_double_ assert_eq_double_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_double_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_double_ Source Code subroutine assert_eq_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( var1 < var2 ) . or . ( var1 > var2 )) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_","tags":"","loc":"proc/assert_eq_double_.html"},{"title":"assert_eq_double_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_double_in_range_~~CallsGraph proc~assert_eq_double_in_range_ assert_eq_double_in_range_ interface~to_s to_s proc~assert_eq_double_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_double_in_range_~~CalledByGraph proc~assert_eq_double_in_range_ assert_eq_double_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_double_in_range_ Source Code subroutine assert_eq_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_double_in_range_","tags":"","loc":"proc/assert_eq_double_in_range_.html"},{"title":"assert_eq_1d_double_ – naturalFRUIT","text":"private subroutine assert_eq_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_double_~~CallsGraph proc~assert_eq_1d_double_ assert_eq_1d_double_ interface~to_s to_s proc~assert_eq_1d_double_->interface~to_s proc~add_success add_success proc~assert_eq_1d_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_double_~~CalledByGraph proc~assert_eq_1d_double_ assert_eq_1d_double_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_double_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_double_ Source Code subroutine assert_eq_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_","tags":"","loc":"proc/assert_eq_1d_double_.html"},{"title":"assert_eq_1d_double_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_double_in_range_~~CallsGraph proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ interface~to_s to_s proc~assert_eq_1d_double_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_1d_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_double_in_range_~~CalledByGraph proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_double_in_range_ Source Code subroutine assert_eq_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_double_in_range_","tags":"","loc":"proc/assert_eq_1d_double_in_range_.html"},{"title":"assert_eq_2d_double_ – naturalFRUIT","text":"private subroutine assert_eq_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_double_~~CallsGraph proc~assert_eq_2d_double_ assert_eq_2d_double_ interface~to_s to_s proc~assert_eq_2d_double_->interface~to_s proc~add_success add_success proc~assert_eq_2d_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_double_~~CalledByGraph proc~assert_eq_2d_double_ assert_eq_2d_double_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_double_ Source Code subroutine assert_eq_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_","tags":"","loc":"proc/assert_eq_2d_double_.html"},{"title":"assert_eq_2d_double_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_double_in_range_~~CallsGraph proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ interface~to_s to_s proc~assert_eq_2d_double_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_2d_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_double_in_range_~~CalledByGraph proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_double_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_double_in_range_ Source Code subroutine assert_eq_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_double_in_range_","tags":"","loc":"proc/assert_eq_2d_double_in_range_.html"},{"title":"assert_eq_complex_ – naturalFRUIT","text":"private subroutine assert_eq_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_eq_complex_~~CallsGraph proc~assert_eq_complex_ assert_eq_complex_ interface~to_s to_s proc~assert_eq_complex_->interface~to_s proc~add_success add_success proc~assert_eq_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_complex_~~CalledByGraph proc~assert_eq_complex_ assert_eq_complex_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_complex_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_complex_ Source Code subroutine assert_eq_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_","tags":"","loc":"proc/assert_eq_complex_.html"},{"title":"assert_eq_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_complex_in_range_~~CallsGraph proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ interface~to_s to_s proc~assert_eq_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_complex_in_range_~~CalledByGraph proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_complex_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_complex_in_range_ Source Code subroutine assert_eq_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message if ( abs ( var1 - var2 ) > delta ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) return endif call add_success end subroutine assert_eq_complex_in_range_","tags":"","loc":"proc/assert_eq_complex_in_range_.html"},{"title":"assert_eq_1d_complex_ – naturalFRUIT","text":"private subroutine assert_eq_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_complex_~~CallsGraph proc~assert_eq_1d_complex_ assert_eq_1d_complex_ interface~to_s to_s proc~assert_eq_1d_complex_->interface~to_s proc~add_success add_success proc~assert_eq_1d_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_complex_~~CalledByGraph proc~assert_eq_1d_complex_ assert_eq_1d_complex_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_complex_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_complex_ Source Code subroutine assert_eq_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_","tags":"","loc":"proc/assert_eq_1d_complex_.html"},{"title":"assert_eq_1d_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_1d_complex_in_range_~~CallsGraph proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ interface~to_s to_s proc~assert_eq_1d_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_1d_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_1d_complex_in_range_~~CalledByGraph proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_1d_complex_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_1d_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_1d_complex_in_range_ Source Code subroutine assert_eq_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) return endif enddo call add_success end subroutine assert_eq_1d_complex_in_range_","tags":"","loc":"proc/assert_eq_1d_complex_in_range_.html"},{"title":"assert_eq_2d_complex_ – naturalFRUIT","text":"private subroutine assert_eq_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_complex_~~CallsGraph proc~assert_eq_2d_complex_ assert_eq_2d_complex_ interface~to_s to_s proc~assert_eq_2d_complex_->interface~to_s proc~add_success add_success proc~assert_eq_2d_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_complex_~~CalledByGraph proc~assert_eq_2d_complex_ assert_eq_2d_complex_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_complex_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_complex_ Source Code subroutine assert_eq_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_","tags":"","loc":"proc/assert_eq_2d_complex_.html"},{"title":"assert_eq_2d_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_eq_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_eq_2d_complex_in_range_~~CallsGraph proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ interface~to_s to_s proc~assert_eq_2d_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_eq_2d_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_eq_2d_complex_in_range_~~CalledByGraph proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ interface~assert_equals assert_equals interface~assert_equals->proc~assert_eq_2d_complex_in_range_ interface~assertequals assertEquals interface~assertequals->proc~assert_eq_2d_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_eq_2d_complex_in_range_ Source Code subroutine assert_eq_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then call failed_assert_action (& & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) return endif enddo enddo call add_success end subroutine assert_eq_2d_complex_in_range_","tags":"","loc":"proc/assert_eq_2d_complex_in_range_.html"},{"title":"assert_not_equals_logical_ – naturalFRUIT","text":"private subroutine assert_not_equals_logical_(var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_logical_~~CallsGraph proc~assert_not_equals_logical_ assert_not_equals_logical_ interface~to_s to_s proc~assert_not_equals_logical_->interface~to_s proc~add_success add_success proc~assert_not_equals_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_logical_~~CalledByGraph proc~assert_not_equals_logical_ assert_not_equals_logical_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_logical_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_logical_ Source Code subroutine assert_not_equals_logical_ ( var1 , var2 , message ) logical , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 . neqv . var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_logical_","tags":"","loc":"proc/assert_not_equals_logical_.html"},{"title":"assert_not_equals_1d_logical_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_logical_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_logical_~~CallsGraph proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ interface~to_s to_s proc~assert_not_equals_1d_logical_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_logical_~~CalledByGraph proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_logical_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_logical_ Source Code subroutine assert_not_equals_1d_logical_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i logical , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) . neqv . var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_logical_","tags":"","loc":"proc/assert_not_equals_1d_logical_.html"},{"title":"assert_not_equals_2d_logical_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_logical_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_logical_~~CallsGraph proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ interface~to_s to_s proc~assert_not_equals_2d_logical_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_logical_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_logical_~~CalledByGraph proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_logical_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_logical_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_logical_ Source Code subroutine assert_not_equals_2d_logical_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j logical , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) . neqv . var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_logical_","tags":"","loc":"proc/assert_not_equals_2d_logical_.html"},{"title":"assert_not_equals_string_ – naturalFRUIT","text":"private subroutine assert_not_equals_string_(var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_string_~~CallsGraph proc~assert_not_equals_string_ assert_not_equals_string_ interface~to_s to_s proc~assert_not_equals_string_->interface~to_s interface~strip strip proc~assert_not_equals_string_->interface~strip proc~add_success add_success proc~assert_not_equals_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_string_~~CalledByGraph proc~assert_not_equals_string_ assert_not_equals_string_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_string_ Source Code subroutine assert_not_equals_string_ ( var1 , var2 , message ) character ( len = * ), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( trim ( strip ( var1 )) /= trim ( strip ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_string_","tags":"","loc":"proc/assert_not_equals_string_.html"},{"title":"assert_not_equals_1d_string_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_string_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_string_~~CallsGraph proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ interface~to_s to_s proc~assert_not_equals_1d_string_->interface~to_s interface~strip strip proc~assert_not_equals_1d_string_->interface~strip proc~add_success add_success proc~assert_not_equals_1d_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_string_~~CalledByGraph proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_string_ Source Code subroutine assert_not_equals_1d_string_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i character ( len = * ), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( trim ( strip ( var1 ( i ))) /= trim ( strip ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_string_","tags":"","loc":"proc/assert_not_equals_1d_string_.html"},{"title":"assert_not_equals_2d_string_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_string_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_string_~~CallsGraph proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ interface~to_s to_s proc~assert_not_equals_2d_string_->interface~to_s interface~strip strip proc~assert_not_equals_2d_string_->interface~strip proc~add_success add_success proc~assert_not_equals_2d_string_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_string_~~CalledByGraph proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_string_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_string_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_string_ Source Code subroutine assert_not_equals_2d_string_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j character ( len = * ), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( trim ( strip ( var1 ( i , j ))) /= trim ( strip ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_string_","tags":"","loc":"proc/assert_not_equals_2d_string_.html"},{"title":"assert_not_equals_int_ – naturalFRUIT","text":"private subroutine assert_not_equals_int_(var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_int_~~CallsGraph proc~assert_not_equals_int_ assert_not_equals_int_ interface~to_s to_s proc~assert_not_equals_int_->interface~to_s proc~add_success add_success proc~assert_not_equals_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_int_~~CalledByGraph proc~assert_not_equals_int_ assert_not_equals_int_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_int_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_int_ Source Code subroutine assert_not_equals_int_ ( var1 , var2 , message ) integer , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( var1 /= var2 ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_int_","tags":"","loc":"proc/assert_not_equals_int_.html"},{"title":"assert_not_equals_1d_int_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_int_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_int_~~CallsGraph proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ interface~to_s to_s proc~assert_not_equals_1d_int_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_int_~~CalledByGraph proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_int_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_int_ Source Code subroutine assert_not_equals_1d_int_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i integer , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( var1 ( i ) /= var2 ( i )) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_int_","tags":"","loc":"proc/assert_not_equals_1d_int_.html"},{"title":"assert_not_equals_2d_int_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_int_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_int_~~CallsGraph proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ interface~to_s to_s proc~assert_not_equals_2d_int_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_int_~~CalledByGraph proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_int_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_int_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_int_ Source Code subroutine assert_not_equals_2d_int_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j integer , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( var1 ( i , j ) /= var2 ( i , j )) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_int_","tags":"","loc":"proc/assert_not_equals_2d_int_.html"},{"title":"assert_not_equals_real_ – naturalFRUIT","text":"private subroutine assert_not_equals_real_(var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_real_~~CallsGraph proc~assert_not_equals_real_ assert_not_equals_real_ interface~to_s to_s proc~assert_not_equals_real_->interface~to_s proc~add_success add_success proc~assert_not_equals_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_real_~~CalledByGraph proc~assert_not_equals_real_ assert_not_equals_real_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_real_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_real_ Source Code subroutine assert_not_equals_real_ ( var1 , var2 , message ) real , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_real_","tags":"","loc":"proc/assert_not_equals_real_.html"},{"title":"assert_not_equals_real_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_real_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_real_in_range_~~CallsGraph proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ interface~to_s to_s proc~assert_not_equals_real_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_real_in_range_~~CalledByGraph proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_real_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_real_in_range_ Source Code subroutine assert_not_equals_real_in_range_ ( var1 , var2 , delta , message ) real , intent ( in ) :: var1 , var2 real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_real_in_range_","tags":"","loc":"proc/assert_not_equals_real_in_range_.html"},{"title":"assert_not_equals_1d_real_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_real_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_real_~~CallsGraph proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ interface~to_s to_s proc~assert_not_equals_1d_real_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_real_~~CalledByGraph proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_real_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_real_ Source Code subroutine assert_not_equals_1d_real_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_real_","tags":"","loc":"proc/assert_not_equals_1d_real_.html"},{"title":"assert_not_equals_1d_real_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_real_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_real_in_range_~~CallsGraph proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ interface~to_s to_s proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_real_in_range_~~CalledByGraph proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_real_in_range_ Source Code subroutine assert_not_equals_1d_real_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i real , intent ( in ) :: var1 ( n ), var2 ( n ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_real_in_range_","tags":"","loc":"proc/assert_not_equals_1d_real_in_range_.html"},{"title":"assert_not_equals_2d_real_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_real_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_real_~~CallsGraph proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ interface~to_s to_s proc~assert_not_equals_2d_real_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_real_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_real_~~CalledByGraph proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_real_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_real_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_real_ Source Code subroutine assert_not_equals_2d_real_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_real_","tags":"","loc":"proc/assert_not_equals_2d_real_.html"},{"title":"assert_not_equals_2d_real_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_real_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_real_in_range_~~CallsGraph proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ interface~to_s to_s proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_real_in_range_~~CalledByGraph proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_real_in_range_ Source Code subroutine assert_not_equals_2d_real_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j real , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) real , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_real_in_range_","tags":"","loc":"proc/assert_not_equals_2d_real_in_range_.html"},{"title":"assert_not_equals_double_ – naturalFRUIT","text":"private subroutine assert_not_equals_double_(var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_double_~~CallsGraph proc~assert_not_equals_double_ assert_not_equals_double_ interface~to_s to_s proc~assert_not_equals_double_->interface~to_s proc~add_success add_success proc~assert_not_equals_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_double_~~CalledByGraph proc~assert_not_equals_double_ assert_not_equals_double_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_double_ Source Code subroutine assert_not_equals_double_ ( var1 , var2 , message ) double precision , intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( var1 < var2 ) . or . ( var1 > var2 )) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_double_","tags":"","loc":"proc/assert_not_equals_double_.html"},{"title":"assert_not_equals_double_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_double_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_double_in_range_~~CallsGraph proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ interface~to_s to_s proc~assert_not_equals_double_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_double_in_range_~~CalledByGraph proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_double_in_range_ Source Code subroutine assert_not_equals_double_in_range_ ( var1 , var2 , delta , message ) double precision , intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_double_in_range_","tags":"","loc":"proc/assert_not_equals_double_in_range_.html"},{"title":"assert_not_equals_1d_double_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_double_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_double_~~CallsGraph proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ interface~to_s to_s proc~assert_not_equals_1d_double_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_double_~~CalledByGraph proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_double_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_double_ Source Code subroutine assert_not_equals_1d_double_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( var1 ( i ) < var2 ( i )) . or . ( var1 ( i ) > var2 ( i ))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_double_","tags":"","loc":"proc/assert_not_equals_1d_double_.html"},{"title":"assert_not_equals_1d_double_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_double_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_double_in_range_~~CallsGraph proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ interface~to_s to_s proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_double_in_range_~~CalledByGraph proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_double_in_range_ Source Code subroutine assert_not_equals_1d_double_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i double precision , intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_double_in_range_","tags":"","loc":"proc/assert_not_equals_1d_double_in_range_.html"},{"title":"assert_not_equals_2d_double_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_double_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_double_~~CallsGraph proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ interface~to_s to_s proc~assert_not_equals_2d_double_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_double_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_double_~~CalledByGraph proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_double_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_double_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_double_ Source Code subroutine assert_not_equals_2d_double_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( var1 ( i , j ) < var2 ( i , j )) . or . ( var1 ( i , j ) > var2 ( i , j ))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_double_","tags":"","loc":"proc/assert_not_equals_2d_double_.html"},{"title":"assert_not_equals_2d_double_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_double_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_double_in_range_~~CallsGraph proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ interface~to_s to_s proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_double_in_range_~~CalledByGraph proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_double_in_range_ Source Code subroutine assert_not_equals_2d_double_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j double precision , intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_double_in_range_","tags":"","loc":"proc/assert_not_equals_2d_double_in_range_.html"},{"title":"assert_not_equals_complex_ – naturalFRUIT","text":"private subroutine assert_not_equals_complex_(var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_complex_~~CallsGraph proc~assert_not_equals_complex_ assert_not_equals_complex_ interface~to_s to_s proc~assert_not_equals_complex_->interface~to_s proc~add_success add_success proc~assert_not_equals_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_complex_~~CalledByGraph proc~assert_not_equals_complex_ assert_not_equals_complex_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_complex_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_complex_ Source Code subroutine assert_not_equals_complex_ ( var1 , var2 , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if (( real ( var1 ) < real ( var2 )) . or . & &( real ( var1 ) > real ( var2 )) . or . & &( aimag ( var1 ) < aimag ( var2 )) . or . & &( aimag ( var1 ) > aimag ( var2 ))) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_complex_","tags":"","loc":"proc/assert_not_equals_complex_.html"},{"title":"assert_not_equals_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_complex_in_range_(var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_complex_in_range_~~CallsGraph proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ interface~to_s to_s proc~assert_not_equals_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_complex_in_range_~~CalledByGraph proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_complex_in_range_ Source Code subroutine assert_not_equals_complex_in_range_ ( var1 , var2 , delta , message ) complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 , var2 double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . if ( abs ( var1 - var2 ) > delta ) then same_so_far = . false . endif if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_complex_in_range_","tags":"","loc":"proc/assert_not_equals_complex_in_range_.html"},{"title":"assert_not_equals_1d_complex_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_complex_(var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_complex_~~CallsGraph proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ interface~to_s to_s proc~assert_not_equals_1d_complex_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_complex_~~CalledByGraph proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_complex_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_complex_ Source Code subroutine assert_not_equals_1d_complex_ ( var1 , var2 , n , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if (( real ( var1 ( i )) < real ( var2 ( i ))) . or . & &( real ( var1 ( i )) > real ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) < aimag ( var2 ( i ))) . or . & &( aimag ( var1 ( i )) > aimag ( var2 ( i )))) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_complex_","tags":"","loc":"proc/assert_not_equals_1d_complex_.html"},{"title":"assert_not_equals_1d_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_1d_complex_in_range_(var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_1d_complex_in_range_~~CallsGraph proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ interface~to_s to_s proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_1d_complex_in_range_~~CalledByGraph proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_1d_complex_in_range_ Source Code subroutine assert_not_equals_1d_complex_in_range_ ( var1 , var2 , n , delta , message ) integer , intent ( in ) :: n integer :: i complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n ), var2 ( n ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do i = 1 , n if ( abs ( var1 ( i ) - var2 ( i )) > delta ) then same_so_far = . false . endif enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_1d_complex_in_range_","tags":"","loc":"proc/assert_not_equals_1d_complex_in_range_.html"},{"title":"assert_not_equals_2d_complex_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_complex_(var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_complex_~~CallsGraph proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ interface~to_s to_s proc~assert_not_equals_2d_complex_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_complex_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_complex_~~CalledByGraph proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_complex_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_complex_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_complex_ Source Code subroutine assert_not_equals_2d_complex_ ( var1 , var2 , n , m , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if (( real ( var1 ( i , j )) < real ( var2 ( i , j ))) . or . & &( real ( var1 ( i , j )) > real ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) < aimag ( var2 ( i , j ))) . or . & &( aimag ( var1 ( i , j )) > aimag ( var2 ( i , j )))) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_complex_","tags":"","loc":"proc/assert_not_equals_2d_complex_.html"},{"title":"assert_not_equals_2d_complex_in_range_ – naturalFRUIT","text":"private subroutine assert_not_equals_2d_complex_in_range_(var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message Calls proc~~assert_not_equals_2d_complex_in_range_~~CallsGraph proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ interface~to_s to_s proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~add_success add_success proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_not_equals_2d_complex_in_range_~~CalledByGraph proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ interface~assert_not_equals assert_not_equals interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ interface~assertnotequals assertNotEquals interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code assert_not_equals_2d_complex_in_range_ Source Code subroutine assert_not_equals_2d_complex_in_range_ ( var1 , var2 , n , m , delta , message ) integer , intent ( in ) :: n , m integer :: i , j complex ( kind = kind ( 1.0D0 )), intent ( in ) :: var1 ( n , m ), var2 ( n , m ) double precision , intent ( in ) :: delta character ( len = * ), intent ( in ), optional :: message logical :: same_so_far same_so_far = . true . do j = 1 , m do i = 1 , n if ( abs ( var1 ( i , j ) - var2 ( i , j )) > delta ) then same_so_far = . false . endif enddo enddo if ( same_so_far ) then call failed_assert_action (& & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) return endif call add_success end subroutine assert_not_equals_2d_complex_in_range_","tags":"","loc":"proc/assert_not_equals_2d_complex_in_range_.html"},{"title":"initializeFruit – naturalFRUIT","text":"public interface initializeFruit Calls interface~~initializefruit~~CallsGraph interface~initializefruit initializeFruit proc~obsolete_initializefruit_ obsolete_initializeFruit_ interface~initializefruit->proc~obsolete_initializefruit_ proc~obsolete_ obsolete_ proc~obsolete_initializefruit_->proc~obsolete_ proc~init_fruit init_fruit proc~obsolete_initializefruit_->proc~init_fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_initializeFruit_ Module Procedures private subroutine obsolete_initializeFruit_ () Arguments None","tags":"","loc":"interface/initializefruit.html"},{"title":"getTestSummary – naturalFRUIT","text":"public interface getTestSummary Calls interface~~gettestsummary~~CallsGraph interface~gettestsummary getTestSummary proc~obsolete_gettestsummary_ obsolete_getTestSummary_ interface~gettestsummary->proc~obsolete_gettestsummary_ proc~fruit_summary_ fruit_summary_ proc~obsolete_gettestsummary_->proc~fruit_summary_ proc~obsolete_ obsolete_ proc~obsolete_gettestsummary_->proc~obsolete_ proc~fruit_summary_table_ fruit_summary_table_ proc~fruit_summary_->proc~fruit_summary_table_ interface~strip strip proc~fruit_summary_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfacegettestsummaryCallsGraph = svgPanZoom('#interfacegettestsummaryCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_getTestSummary_ Module Procedures private subroutine obsolete_getTestSummary_ () Arguments None","tags":"","loc":"interface/gettestsummary.html"},{"title":"assertTrue – naturalFRUIT","text":"public interface assertTrue Calls interface~~asserttrue~~CallsGraph interface~asserttrue assertTrue proc~obsolete_assert_true_logical_ obsolete_assert_true_logical_ interface~asserttrue->proc~obsolete_assert_true_logical_ proc~obsolete_ obsolete_ proc~obsolete_assert_true_logical_->proc~obsolete_ proc~assert_true assert_true proc~obsolete_assert_true_logical_->proc~assert_true interface~to_s to_s proc~assert_true->interface~to_s proc~add_success add_success proc~assert_true->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var paninterfaceasserttrueCallsGraph = svgPanZoom('#interfaceasserttrueCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_assert_true_logical_ Module Procedures private subroutine obsolete_assert_true_logical_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message","tags":"","loc":"interface/asserttrue.html"},{"title":"assert_false – naturalFRUIT","text":"public interface assert_false Calls interface~~assert_false~~CallsGraph interface~assert_false assert_false proc~assert_false_ assert_false_ interface~assert_false->proc~assert_false_ interface~to_s to_s proc~assert_false_->interface~to_s proc~add_success add_success proc~assert_false_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures assert_false_ Module Procedures private subroutine assert_false_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_false.html"},{"title":"assert_equals – naturalFRUIT","text":"public interface assert_equals Calls interface~~assert_equals~~CallsGraph interface~assert_equals assert_equals proc~assert_eq_2d_double_ assert_eq_2d_double_ interface~assert_equals->proc~assert_eq_2d_double_ proc~assert_eq_logical_ assert_eq_logical_ interface~assert_equals->proc~assert_eq_logical_ proc~assert_eq_1d_real_ assert_eq_1d_real_ interface~assert_equals->proc~assert_eq_1d_real_ proc~assert_eq_1d_logical_ assert_eq_1d_logical_ interface~assert_equals->proc~assert_eq_1d_logical_ proc~assert_eq_2d_string_ assert_eq_2d_string_ interface~assert_equals->proc~assert_eq_2d_string_ proc~assert_eq_2d_int_ assert_eq_2d_int_ interface~assert_equals->proc~assert_eq_2d_int_ proc~assert_eq_1d_double_ assert_eq_1d_double_ interface~assert_equals->proc~assert_eq_1d_double_ proc~assert_eq_complex_ assert_eq_complex_ interface~assert_equals->proc~assert_eq_complex_ proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ interface~assert_equals->proc~assert_eq_1d_double_in_range_ proc~assert_eq_2d_complex_ assert_eq_2d_complex_ interface~assert_equals->proc~assert_eq_2d_complex_ proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ interface~assert_equals->proc~assert_eq_1d_real_in_range_ proc~assert_eq_1d_string_ assert_eq_1d_string_ interface~assert_equals->proc~assert_eq_1d_string_ proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ interface~assert_equals->proc~assert_eq_complex_in_range_ proc~assert_eq_double_ assert_eq_double_ interface~assert_equals->proc~assert_eq_double_ proc~assert_eq_string_ assert_eq_string_ interface~assert_equals->proc~assert_eq_string_ proc~assert_eq_real_in_range_ assert_eq_real_in_range_ interface~assert_equals->proc~assert_eq_real_in_range_ proc~assert_eq_2d_logical_ assert_eq_2d_logical_ interface~assert_equals->proc~assert_eq_2d_logical_ proc~assert_eq_int_ assert_eq_int_ interface~assert_equals->proc~assert_eq_int_ proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ interface~assert_equals->proc~assert_eq_2d_complex_in_range_ proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ interface~assert_equals->proc~assert_eq_2d_double_in_range_ proc~assert_eq_1d_complex_ assert_eq_1d_complex_ interface~assert_equals->proc~assert_eq_1d_complex_ proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ interface~assert_equals->proc~assert_eq_1d_complex_in_range_ proc~assert_eq_real_ assert_eq_real_ interface~assert_equals->proc~assert_eq_real_ proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ interface~assert_equals->proc~assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_ assert_eq_2d_real_ interface~assert_equals->proc~assert_eq_2d_real_ proc~assert_eq_double_in_range_ assert_eq_double_in_range_ interface~assert_equals->proc~assert_eq_double_in_range_ proc~assert_eq_1d_int_ assert_eq_1d_int_ interface~assert_equals->proc~assert_eq_1d_int_ interface~to_s to_s proc~assert_eq_2d_double_->interface~to_s proc~add_success add_success proc~assert_eq_2d_double_->proc~add_success proc~assert_eq_logical_->interface~to_s proc~assert_eq_logical_->proc~add_success proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_real_->proc~add_success proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_1d_logical_->proc~add_success proc~assert_eq_2d_string_->interface~to_s interface~strip strip proc~assert_eq_2d_string_->interface~strip proc~assert_eq_2d_string_->proc~add_success proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_2d_int_->proc~add_success proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_1d_double_->proc~add_success proc~assert_eq_complex_->interface~to_s proc~assert_eq_complex_->proc~add_success proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_1d_double_in_range_->proc~add_success proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_2d_complex_->proc~add_success proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_eq_1d_real_in_range_->proc~add_success proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_1d_string_->interface~strip proc~assert_eq_1d_string_->proc~add_success proc~assert_eq_complex_in_range_->interface~to_s proc~assert_eq_complex_in_range_->proc~add_success proc~assert_eq_double_->interface~to_s proc~assert_eq_double_->proc~add_success proc~assert_eq_string_->interface~to_s proc~assert_eq_string_->interface~strip proc~assert_eq_string_->proc~add_success proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_real_in_range_->proc~add_success proc~assert_eq_2d_logical_->interface~to_s proc~assert_eq_2d_logical_->proc~add_success proc~assert_eq_int_->interface~to_s proc~assert_eq_int_->proc~add_success proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_eq_2d_complex_in_range_->proc~add_success proc~assert_eq_2d_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_->proc~add_success proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_complex_->proc~add_success proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_->proc~add_success proc~assert_eq_real_->interface~to_s proc~assert_eq_real_->proc~add_success proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_in_range_->proc~add_success proc~assert_eq_2d_real_->interface~to_s proc~assert_eq_2d_real_->proc~add_success proc~assert_eq_double_in_range_->interface~to_s proc~assert_eq_double_in_range_->proc~add_success proc~assert_eq_1d_int_->interface~to_s proc~assert_eq_1d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var paninterfaceassert_equalsCallsGraph = svgPanZoom('#interfaceassert_equalsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures assert_eq_logical_ assert_eq_1d_logical_ assert_eq_2d_logical_ assert_eq_string_ assert_eq_1d_string_ assert_eq_2d_string_ assert_eq_int_ assert_eq_1d_int_ assert_eq_2d_int_ assert_eq_real_ assert_eq_real_in_range_ assert_eq_1d_real_ assert_eq_1d_real_in_range_ assert_eq_2d_real_ assert_eq_2d_real_in_range_ assert_eq_double_ assert_eq_double_in_range_ assert_eq_1d_double_ assert_eq_1d_double_in_range_ assert_eq_2d_double_ assert_eq_2d_double_in_range_ assert_eq_complex_ assert_eq_complex_in_range_ assert_eq_1d_complex_ assert_eq_1d_complex_in_range_ assert_eq_2d_complex_ assert_eq_2d_complex_in_range_ Module Procedures private subroutine assert_eq_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_equals.html"},{"title":"assertEquals – naturalFRUIT","text":"public interface assertEquals Calls interface~~assertequals~~CallsGraph interface~assertequals assertEquals proc~assert_eq_2d_double_ assert_eq_2d_double_ interface~assertequals->proc~assert_eq_2d_double_ proc~assert_eq_logical_ assert_eq_logical_ interface~assertequals->proc~assert_eq_logical_ proc~assert_eq_1d_real_ assert_eq_1d_real_ interface~assertequals->proc~assert_eq_1d_real_ proc~assert_eq_1d_logical_ assert_eq_1d_logical_ interface~assertequals->proc~assert_eq_1d_logical_ proc~assert_eq_2d_string_ assert_eq_2d_string_ interface~assertequals->proc~assert_eq_2d_string_ proc~assert_eq_2d_int_ assert_eq_2d_int_ interface~assertequals->proc~assert_eq_2d_int_ proc~assert_eq_1d_double_ assert_eq_1d_double_ interface~assertequals->proc~assert_eq_1d_double_ proc~assert_eq_complex_ assert_eq_complex_ interface~assertequals->proc~assert_eq_complex_ proc~assert_eq_1d_double_in_range_ assert_eq_1d_double_in_range_ interface~assertequals->proc~assert_eq_1d_double_in_range_ proc~assert_eq_2d_complex_ assert_eq_2d_complex_ interface~assertequals->proc~assert_eq_2d_complex_ proc~assert_eq_1d_real_in_range_ assert_eq_1d_real_in_range_ interface~assertequals->proc~assert_eq_1d_real_in_range_ proc~assert_eq_1d_string_ assert_eq_1d_string_ interface~assertequals->proc~assert_eq_1d_string_ proc~assert_eq_complex_in_range_ assert_eq_complex_in_range_ interface~assertequals->proc~assert_eq_complex_in_range_ proc~assert_eq_double_ assert_eq_double_ interface~assertequals->proc~assert_eq_double_ proc~assert_eq_string_ assert_eq_string_ interface~assertequals->proc~assert_eq_string_ proc~assert_eq_real_in_range_ assert_eq_real_in_range_ interface~assertequals->proc~assert_eq_real_in_range_ proc~assert_eq_2d_logical_ assert_eq_2d_logical_ interface~assertequals->proc~assert_eq_2d_logical_ proc~assert_eq_int_ assert_eq_int_ interface~assertequals->proc~assert_eq_int_ proc~assert_eq_2d_complex_in_range_ assert_eq_2d_complex_in_range_ interface~assertequals->proc~assert_eq_2d_complex_in_range_ proc~assert_eq_2d_double_in_range_ assert_eq_2d_double_in_range_ interface~assertequals->proc~assert_eq_2d_double_in_range_ proc~assert_eq_1d_complex_ assert_eq_1d_complex_ interface~assertequals->proc~assert_eq_1d_complex_ proc~assert_eq_1d_complex_in_range_ assert_eq_1d_complex_in_range_ interface~assertequals->proc~assert_eq_1d_complex_in_range_ proc~assert_eq_real_ assert_eq_real_ interface~assertequals->proc~assert_eq_real_ proc~assert_eq_2d_real_in_range_ assert_eq_2d_real_in_range_ interface~assertequals->proc~assert_eq_2d_real_in_range_ proc~assert_eq_2d_real_ assert_eq_2d_real_ interface~assertequals->proc~assert_eq_2d_real_ proc~assert_eq_double_in_range_ assert_eq_double_in_range_ interface~assertequals->proc~assert_eq_double_in_range_ proc~assert_eq_1d_int_ assert_eq_1d_int_ interface~assertequals->proc~assert_eq_1d_int_ interface~to_s to_s proc~assert_eq_2d_double_->interface~to_s proc~add_success add_success proc~assert_eq_2d_double_->proc~add_success proc~assert_eq_logical_->interface~to_s proc~assert_eq_logical_->proc~add_success proc~assert_eq_1d_real_->interface~to_s proc~assert_eq_1d_real_->proc~add_success proc~assert_eq_1d_logical_->interface~to_s proc~assert_eq_1d_logical_->proc~add_success proc~assert_eq_2d_string_->interface~to_s interface~strip strip proc~assert_eq_2d_string_->interface~strip proc~assert_eq_2d_string_->proc~add_success proc~assert_eq_2d_int_->interface~to_s proc~assert_eq_2d_int_->proc~add_success proc~assert_eq_1d_double_->interface~to_s proc~assert_eq_1d_double_->proc~add_success proc~assert_eq_complex_->interface~to_s proc~assert_eq_complex_->proc~add_success proc~assert_eq_1d_double_in_range_->interface~to_s proc~assert_eq_1d_double_in_range_->proc~add_success proc~assert_eq_2d_complex_->interface~to_s proc~assert_eq_2d_complex_->proc~add_success proc~assert_eq_1d_real_in_range_->interface~to_s proc~assert_eq_1d_real_in_range_->proc~add_success proc~assert_eq_1d_string_->interface~to_s proc~assert_eq_1d_string_->interface~strip proc~assert_eq_1d_string_->proc~add_success proc~assert_eq_complex_in_range_->interface~to_s proc~assert_eq_complex_in_range_->proc~add_success proc~assert_eq_double_->interface~to_s proc~assert_eq_double_->proc~add_success proc~assert_eq_string_->interface~to_s proc~assert_eq_string_->interface~strip proc~assert_eq_string_->proc~add_success proc~assert_eq_real_in_range_->interface~to_s proc~assert_eq_real_in_range_->proc~add_success proc~assert_eq_2d_logical_->interface~to_s proc~assert_eq_2d_logical_->proc~add_success proc~assert_eq_int_->interface~to_s proc~assert_eq_int_->proc~add_success proc~assert_eq_2d_complex_in_range_->interface~to_s proc~assert_eq_2d_complex_in_range_->proc~add_success proc~assert_eq_2d_double_in_range_->interface~to_s proc~assert_eq_2d_double_in_range_->proc~add_success proc~assert_eq_1d_complex_->interface~to_s proc~assert_eq_1d_complex_->proc~add_success proc~assert_eq_1d_complex_in_range_->interface~to_s proc~assert_eq_1d_complex_in_range_->proc~add_success proc~assert_eq_real_->interface~to_s proc~assert_eq_real_->proc~add_success proc~assert_eq_2d_real_in_range_->interface~to_s proc~assert_eq_2d_real_in_range_->proc~add_success proc~assert_eq_2d_real_->interface~to_s proc~assert_eq_2d_real_->proc~add_success proc~assert_eq_double_in_range_->interface~to_s proc~assert_eq_double_in_range_->proc~add_success proc~assert_eq_1d_int_->interface~to_s proc~assert_eq_1d_int_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var paninterfaceassertequalsCallsGraph = svgPanZoom('#interfaceassertequalsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures assert_eq_logical_ assert_eq_1d_logical_ assert_eq_2d_logical_ assert_eq_string_ assert_eq_1d_string_ assert_eq_2d_string_ assert_eq_int_ assert_eq_1d_int_ assert_eq_2d_int_ assert_eq_real_ assert_eq_real_in_range_ assert_eq_1d_real_ assert_eq_1d_real_in_range_ assert_eq_2d_real_ assert_eq_2d_real_in_range_ assert_eq_double_ assert_eq_double_in_range_ assert_eq_1d_double_ assert_eq_1d_double_in_range_ assert_eq_2d_double_ assert_eq_2d_double_in_range_ assert_eq_complex_ assert_eq_complex_in_range_ assert_eq_1d_complex_ assert_eq_1d_complex_in_range_ assert_eq_2d_complex_ assert_eq_2d_complex_in_range_ Module Procedures private subroutine assert_eq_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assertequals.html"},{"title":"assert_not_equals – naturalFRUIT","text":"public interface assert_not_equals Calls interface~~assert_not_equals~~CallsGraph interface~assert_not_equals assert_not_equals proc~assert_not_equals_double_ assert_not_equals_double_ interface~assert_not_equals->proc~assert_not_equals_double_ proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_ proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_double_in_range_ proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ interface~assert_not_equals->proc~assert_not_equals_1d_real_ proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ interface~assert_not_equals->proc~assert_not_equals_2d_logical_ proc~assert_not_equals_logical_ assert_not_equals_logical_ interface~assert_not_equals->proc~assert_not_equals_logical_ proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ interface~assert_not_equals->proc~assert_not_equals_1d_logical_ proc~assert_not_equals_real_ assert_not_equals_real_ interface~assert_not_equals->proc~assert_not_equals_real_ proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_real_in_range_ proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_complex_in_range_ proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ interface~assert_not_equals->proc~assert_not_equals_2d_string_ proc~assert_not_equals_complex_ assert_not_equals_complex_ interface~assert_not_equals->proc~assert_not_equals_complex_ proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ interface~assert_not_equals->proc~assert_not_equals_2d_int_ proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ interface~assert_not_equals->proc~assert_not_equals_1d_double_ proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_ proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ interface~assert_not_equals->proc~assert_not_equals_1d_string_ proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_int_ assert_not_equals_int_ interface~assert_not_equals->proc~assert_not_equals_int_ proc~assert_not_equals_string_ assert_not_equals_string_ interface~assert_not_equals->proc~assert_not_equals_string_ proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ interface~assert_not_equals->proc~assert_not_equals_2d_real_ proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ interface~assert_not_equals->proc~assert_not_equals_1d_int_ proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_1d_double_in_range_ proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ interface~assert_not_equals->proc~assert_not_equals_2d_double_ proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ interface~assert_not_equals->proc~assert_not_equals_real_in_range_ proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ interface~assert_not_equals->proc~assert_not_equals_double_in_range_ interface~to_s to_s proc~assert_not_equals_double_->interface~to_s proc~add_success add_success proc~assert_not_equals_double_->proc~add_success proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_not_equals_2d_complex_->proc~add_success proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_1d_real_->proc~add_success proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_2d_logical_->proc~add_success proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_logical_->proc~add_success proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_not_equals_1d_logical_->proc~add_success proc~assert_not_equals_real_->interface~to_s proc~assert_not_equals_real_->proc~add_success proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_complex_in_range_->proc~add_success proc~assert_not_equals_2d_string_->interface~to_s interface~strip strip proc~assert_not_equals_2d_string_->interface~strip proc~assert_not_equals_2d_string_->proc~add_success proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_complex_->proc~add_success proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_int_->proc~add_success proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_double_->proc~add_success proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_->proc~add_success proc~assert_not_equals_1d_string_->interface~to_s proc~assert_not_equals_1d_string_->interface~strip proc~assert_not_equals_1d_string_->proc~add_success proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~assert_not_equals_int_->interface~to_s proc~assert_not_equals_int_->proc~add_success proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_string_->interface~strip proc~assert_not_equals_string_->proc~add_success proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_2d_real_->proc~add_success proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~assert_not_equals_1d_int_->interface~to_s proc~assert_not_equals_1d_int_->proc~add_success proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~assert_not_equals_2d_double_->interface~to_s proc~assert_not_equals_2d_double_->proc~add_success proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_not_equals_real_in_range_->proc~add_success proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var paninterfaceassert_not_equalsCallsGraph = svgPanZoom('#interfaceassert_not_equalsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures assert_not_equals_logical_ assert_not_equals_1d_logical_ assert_not_equals_2d_logical_ assert_not_equals_string_ assert_not_equals_1d_string_ assert_not_equals_2d_string_ assert_not_equals_int_ assert_not_equals_1d_int_ assert_not_equals_2d_int_ assert_not_equals_real_ assert_not_equals_real_in_range_ assert_not_equals_1d_real_ assert_not_equals_1d_real_in_range_ assert_not_equals_2d_real_ assert_not_equals_2d_real_in_range_ assert_not_equals_double_ assert_not_equals_double_in_range_ assert_not_equals_1d_double_ assert_not_equals_1d_double_in_range_ assert_not_equals_2d_double_ assert_not_equals_2d_double_in_range_ assert_not_equals_complex_ assert_not_equals_complex_in_range_ assert_not_equals_1d_complex_ assert_not_equals_1d_complex_in_range_ assert_not_equals_2d_complex_ assert_not_equals_2d_complex_in_range_ Module Procedures private subroutine assert_not_equals_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assert_not_equals.html"},{"title":"assertNotEquals – naturalFRUIT","text":"public interface assertNotEquals Calls interface~~assertnotequals~~CallsGraph interface~assertnotequals assertNotEquals proc~assert_not_equals_double_ assert_not_equals_double_ interface~assertnotequals->proc~assert_not_equals_double_ proc~assert_not_equals_2d_complex_ assert_not_equals_2d_complex_ interface~assertnotequals->proc~assert_not_equals_2d_complex_ proc~assert_not_equals_2d_double_in_range_ assert_not_equals_2d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_double_in_range_ proc~assert_not_equals_1d_real_ assert_not_equals_1d_real_ interface~assertnotequals->proc~assert_not_equals_1d_real_ proc~assert_not_equals_2d_logical_ assert_not_equals_2d_logical_ interface~assertnotequals->proc~assert_not_equals_2d_logical_ proc~assert_not_equals_logical_ assert_not_equals_logical_ interface~assertnotequals->proc~assert_not_equals_logical_ proc~assert_not_equals_1d_logical_ assert_not_equals_1d_logical_ interface~assertnotequals->proc~assert_not_equals_1d_logical_ proc~assert_not_equals_real_ assert_not_equals_real_ interface~assertnotequals->proc~assert_not_equals_real_ proc~assert_not_equals_2d_real_in_range_ assert_not_equals_2d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_real_in_range_ proc~assert_not_equals_complex_in_range_ assert_not_equals_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_complex_in_range_ proc~assert_not_equals_2d_string_ assert_not_equals_2d_string_ interface~assertnotequals->proc~assert_not_equals_2d_string_ proc~assert_not_equals_complex_ assert_not_equals_complex_ interface~assertnotequals->proc~assert_not_equals_complex_ proc~assert_not_equals_2d_int_ assert_not_equals_2d_int_ interface~assertnotequals->proc~assert_not_equals_2d_int_ proc~assert_not_equals_2d_complex_in_range_ assert_not_equals_2d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_2d_complex_in_range_ proc~assert_not_equals_1d_double_ assert_not_equals_1d_double_ interface~assertnotequals->proc~assert_not_equals_1d_double_ proc~assert_not_equals_1d_complex_ assert_not_equals_1d_complex_ interface~assertnotequals->proc~assert_not_equals_1d_complex_ proc~assert_not_equals_1d_string_ assert_not_equals_1d_string_ interface~assertnotequals->proc~assert_not_equals_1d_string_ proc~assert_not_equals_1d_complex_in_range_ assert_not_equals_1d_complex_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_complex_in_range_ proc~assert_not_equals_int_ assert_not_equals_int_ interface~assertnotequals->proc~assert_not_equals_int_ proc~assert_not_equals_string_ assert_not_equals_string_ interface~assertnotequals->proc~assert_not_equals_string_ proc~assert_not_equals_2d_real_ assert_not_equals_2d_real_ interface~assertnotequals->proc~assert_not_equals_2d_real_ proc~assert_not_equals_1d_real_in_range_ assert_not_equals_1d_real_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_real_in_range_ proc~assert_not_equals_1d_int_ assert_not_equals_1d_int_ interface~assertnotequals->proc~assert_not_equals_1d_int_ proc~assert_not_equals_1d_double_in_range_ assert_not_equals_1d_double_in_range_ interface~assertnotequals->proc~assert_not_equals_1d_double_in_range_ proc~assert_not_equals_2d_double_ assert_not_equals_2d_double_ interface~assertnotequals->proc~assert_not_equals_2d_double_ proc~assert_not_equals_real_in_range_ assert_not_equals_real_in_range_ interface~assertnotequals->proc~assert_not_equals_real_in_range_ proc~assert_not_equals_double_in_range_ assert_not_equals_double_in_range_ interface~assertnotequals->proc~assert_not_equals_double_in_range_ interface~to_s to_s proc~assert_not_equals_double_->interface~to_s proc~add_success add_success proc~assert_not_equals_double_->proc~add_success proc~assert_not_equals_2d_complex_->interface~to_s proc~assert_not_equals_2d_complex_->proc~add_success proc~assert_not_equals_2d_double_in_range_->interface~to_s proc~assert_not_equals_2d_double_in_range_->proc~add_success proc~assert_not_equals_1d_real_->interface~to_s proc~assert_not_equals_1d_real_->proc~add_success proc~assert_not_equals_2d_logical_->interface~to_s proc~assert_not_equals_2d_logical_->proc~add_success proc~assert_not_equals_logical_->interface~to_s proc~assert_not_equals_logical_->proc~add_success proc~assert_not_equals_1d_logical_->interface~to_s proc~assert_not_equals_1d_logical_->proc~add_success proc~assert_not_equals_real_->interface~to_s proc~assert_not_equals_real_->proc~add_success proc~assert_not_equals_2d_real_in_range_->interface~to_s proc~assert_not_equals_2d_real_in_range_->proc~add_success proc~assert_not_equals_complex_in_range_->interface~to_s proc~assert_not_equals_complex_in_range_->proc~add_success proc~assert_not_equals_2d_string_->interface~to_s interface~strip strip proc~assert_not_equals_2d_string_->interface~strip proc~assert_not_equals_2d_string_->proc~add_success proc~assert_not_equals_complex_->interface~to_s proc~assert_not_equals_complex_->proc~add_success proc~assert_not_equals_2d_int_->interface~to_s proc~assert_not_equals_2d_int_->proc~add_success proc~assert_not_equals_2d_complex_in_range_->interface~to_s proc~assert_not_equals_2d_complex_in_range_->proc~add_success proc~assert_not_equals_1d_double_->interface~to_s proc~assert_not_equals_1d_double_->proc~add_success proc~assert_not_equals_1d_complex_->interface~to_s proc~assert_not_equals_1d_complex_->proc~add_success proc~assert_not_equals_1d_string_->interface~to_s proc~assert_not_equals_1d_string_->interface~strip proc~assert_not_equals_1d_string_->proc~add_success proc~assert_not_equals_1d_complex_in_range_->interface~to_s proc~assert_not_equals_1d_complex_in_range_->proc~add_success proc~assert_not_equals_int_->interface~to_s proc~assert_not_equals_int_->proc~add_success proc~assert_not_equals_string_->interface~to_s proc~assert_not_equals_string_->interface~strip proc~assert_not_equals_string_->proc~add_success proc~assert_not_equals_2d_real_->interface~to_s proc~assert_not_equals_2d_real_->proc~add_success proc~assert_not_equals_1d_real_in_range_->interface~to_s proc~assert_not_equals_1d_real_in_range_->proc~add_success proc~assert_not_equals_1d_int_->interface~to_s proc~assert_not_equals_1d_int_->proc~add_success proc~assert_not_equals_1d_double_in_range_->interface~to_s proc~assert_not_equals_1d_double_in_range_->proc~add_success proc~assert_not_equals_2d_double_->interface~to_s proc~assert_not_equals_2d_double_->proc~add_success proc~assert_not_equals_real_in_range_->interface~to_s proc~assert_not_equals_real_in_range_->proc~add_success proc~assert_not_equals_double_in_range_->interface~to_s proc~assert_not_equals_double_in_range_->proc~add_success proc~to_s_int_ to_s_int_ interface~to_s->proc~to_s_int_ proc~to_s_string_ to_s_string_ interface~to_s->proc~to_s_string_ proc~to_s_complex_ to_s_complex_ interface~to_s->proc~to_s_complex_ proc~to_s_real_ to_s_real_ interface~to_s->proc~to_s_real_ proc~to_s_logical_ to_s_logical_ interface~to_s->proc~to_s_logical_ proc~to_s_double_ to_s_double_ interface~to_s->proc~to_s_double_ proc~to_s_double_complex_ to_s_double_complex_ interface~to_s->proc~to_s_double_complex_ proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ var paninterfaceassertnotequalsCallsGraph = svgPanZoom('#interfaceassertnotequalsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures assert_not_equals_logical_ assert_not_equals_1d_logical_ assert_not_equals_2d_logical_ assert_not_equals_string_ assert_not_equals_1d_string_ assert_not_equals_2d_string_ assert_not_equals_int_ assert_not_equals_1d_int_ assert_not_equals_2d_int_ assert_not_equals_real_ assert_not_equals_real_in_range_ assert_not_equals_1d_real_ assert_not_equals_1d_real_in_range_ assert_not_equals_2d_real_ assert_not_equals_2d_real_in_range_ assert_not_equals_double_ assert_not_equals_double_in_range_ assert_not_equals_1d_double_ assert_not_equals_1d_double_in_range_ assert_not_equals_2d_double_ assert_not_equals_2d_double_in_range_ assert_not_equals_complex_ assert_not_equals_complex_in_range_ assert_not_equals_1d_complex_ assert_not_equals_1d_complex_in_range_ assert_not_equals_2d_complex_ assert_not_equals_2d_complex_in_range_ Module Procedures private subroutine assert_not_equals_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"interface/assertnotequals.html"},{"title":"addSuccess – naturalFRUIT","text":"public interface addSuccess Calls interface~~addsuccess~~CallsGraph interface~addsuccess addSuccess proc~obsolete_addsuccess_ obsolete_addSuccess_ interface~addsuccess->proc~obsolete_addsuccess_ proc~obsolete_ obsolete_ proc~obsolete_addsuccess_->proc~obsolete_ proc~add_success add_success proc~obsolete_addsuccess_->proc~add_success proc~success_mark_ success_mark_ proc~add_success->proc~success_mark_ proc~output_mark_ output_mark_ proc~success_mark_->proc~output_mark_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_addSuccess_ Module Procedures private subroutine obsolete_addSuccess_ () Arguments None","tags":"","loc":"interface/addsuccess.html"},{"title":"add_fail – naturalFRUIT","text":"public interface add_fail Calls interface~~add_fail~~CallsGraph interface~add_fail add_fail proc~add_fail_unit_ add_fail_unit_ interface~add_fail->proc~add_fail_unit_ proc~add_fail_ add_fail_ interface~add_fail->proc~add_fail_ proc~add_fail_unit_->proc~add_fail_ proc~failed_assert_action failed_assert_action proc~add_fail_->proc~failed_assert_action proc~failed_mark_ failed_mark_ proc~failed_assert_action->proc~failed_mark_ proc~make_error_msg_ make_error_msg_ proc~failed_assert_action->proc~make_error_msg_ proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action->proc~increase_message_stack_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfaceadd_failCallsGraph = svgPanZoom('#interfaceadd_failCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures add_fail_ add_fail_unit_ Module Procedures private subroutine add_fail_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_ (unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message","tags":"","loc":"interface/add_fail.html"},{"title":"addFail – naturalFRUIT","text":"public interface addFail Calls interface~~addfail~~CallsGraph interface~addfail addFail proc~add_fail_unit_ add_fail_unit_ interface~addfail->proc~add_fail_unit_ proc~add_fail_ add_fail_ interface~addfail->proc~add_fail_ proc~add_fail_unit_->proc~add_fail_ proc~failed_assert_action failed_assert_action proc~add_fail_->proc~failed_assert_action proc~failed_mark_ failed_mark_ proc~failed_assert_action->proc~failed_mark_ proc~make_error_msg_ make_error_msg_ proc~failed_assert_action->proc~make_error_msg_ proc~increase_message_stack_ increase_message_stack_ proc~failed_assert_action->proc~increase_message_stack_ proc~output_mark_ output_mark_ proc~failed_mark_->proc~output_mark_ interface~strip strip proc~make_error_msg_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfaceaddfailCallsGraph = svgPanZoom('#interfaceaddfailCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures add_fail_ add_fail_unit_ Module Procedures private subroutine add_fail_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_ (unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message","tags":"","loc":"interface/addfail.html"},{"title":"getTotalCount – naturalFRUIT","text":"public interface getTotalCount Calls interface~~gettotalcount~~CallsGraph interface~gettotalcount getTotalCount proc~obsolete_gettotalcount_ obsolete_getTotalCount_ interface~gettotalcount->proc~obsolete_gettotalcount_ proc~obsolete_ obsolete_ proc~obsolete_gettotalcount_->proc~obsolete_ proc~get_total_count get_total_count proc~obsolete_gettotalcount_->proc~get_total_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_getTotalCount_ Module Procedures private subroutine obsolete_getTotalCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count","tags":"","loc":"interface/gettotalcount.html"},{"title":"getFailedCount – naturalFRUIT","text":"public interface getFailedCount Calls interface~~getfailedcount~~CallsGraph interface~getfailedcount getFailedCount proc~obsolete_getfailedcount_ obsolete_getFailedCount_ interface~getfailedcount->proc~obsolete_getfailedcount_ proc~obsolete_ obsolete_ proc~obsolete_getfailedcount_->proc~obsolete_ proc~get_failed_count get_failed_count proc~obsolete_getfailedcount_->proc~get_failed_count Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_getFailedCount_ Module Procedures private subroutine obsolete_getFailedCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count","tags":"","loc":"interface/getfailedcount.html"},{"title":"isAllSuccessful – naturalFRUIT","text":"public interface isAllSuccessful Calls interface~~isallsuccessful~~CallsGraph interface~isallsuccessful isAllSuccessful proc~obsolete_isallsuccessful_ obsolete_isAllSuccessful_ interface~isallsuccessful->proc~obsolete_isallsuccessful_ proc~obsolete_ obsolete_ proc~obsolete_isallsuccessful_->proc~obsolete_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures obsolete_isAllSuccessful_ Module Procedures private subroutine obsolete_isAllSuccessful_ (result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result","tags":"","loc":"interface/isallsuccessful.html"},{"title":"run_test_case – naturalFRUIT","text":"public interface run_test_case Calls interface~~run_test_case~~CallsGraph interface~run_test_case run_test_case proc~run_test_case_named_ run_test_case_named_ interface~run_test_case->proc~run_test_case_named_ proc~run_test_case_ run_test_case_ interface~run_test_case->proc~run_test_case_ interface~set_case_name set_case_name proc~run_test_case_named_->interface~set_case_name proc~run_test_case_->proc~run_test_case_named_ proc~set_case_name_ set_case_name_ interface~set_case_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfacerun_test_caseCallsGraph = svgPanZoom('#interfacerun_test_caseCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures run_test_case_ run_test_case_named_ Module Procedures private subroutine run_test_case_ (tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_ (tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name","tags":"","loc":"interface/run_test_case.html"},{"title":"runTestCase – naturalFRUIT","text":"public interface runTestCase Calls interface~~runtestcase~~CallsGraph interface~runtestcase runTestCase proc~run_test_case_named_ run_test_case_named_ interface~runtestcase->proc~run_test_case_named_ proc~run_test_case_ run_test_case_ interface~runtestcase->proc~run_test_case_ interface~set_case_name set_case_name proc~run_test_case_named_->interface~set_case_name proc~run_test_case_->proc~run_test_case_named_ proc~set_case_name_ set_case_name_ interface~set_case_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ var paninterfaceruntestcaseCallsGraph = svgPanZoom('#interfaceruntestcaseCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures run_test_case_ run_test_case_named_ Module Procedures private subroutine run_test_case_ (tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_ (tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name","tags":"","loc":"interface/runtestcase.html"},{"title":"init_fruit_xml – naturalFRUIT","text":"public interface init_fruit_xml Calls interface~~init_fruit_xml~~CallsGraph interface~init_fruit_xml init_fruit_xml proc~init_fruit_xml_ init_fruit_xml_ interface~init_fruit_xml->proc~init_fruit_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~init_fruit_xml~~CalledByGraph interface~init_fruit_xml init_fruit_xml proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ proc~fruit_init_mpi_xml_->interface~init_fruit_xml interface~fruit_init_mpi_xml fruit_init_mpi_xml interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures init_fruit_xml_ Module Procedures private subroutine init_fruit_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank","tags":"","loc":"interface/init_fruit_xml.html"},{"title":"fruit_summary – naturalFRUIT","text":"public interface fruit_summary Calls interface~~fruit_summary~~CallsGraph interface~fruit_summary fruit_summary proc~fruit_summary_ fruit_summary_ interface~fruit_summary->proc~fruit_summary_ proc~fruit_summary_table_ fruit_summary_table_ proc~fruit_summary_->proc~fruit_summary_table_ interface~strip strip proc~fruit_summary_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_summary_ Module Procedures private subroutine fruit_summary_ () Arguments None","tags":"","loc":"interface/fruit_summary.html"},{"title":"fruit_summary_xml – naturalFRUIT","text":"public interface fruit_summary_xml Calls interface~~fruit_summary_xml~~CallsGraph interface~fruit_summary_xml fruit_summary_xml proc~fruit_summary_xml_ fruit_summary_xml_ interface~fruit_summary_xml->proc~fruit_summary_xml_ proc~int_to_str~2 int_to_str proc~fruit_summary_xml_->proc~int_to_str~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_summary_xml_ Module Procedures private subroutine fruit_summary_xml_ () Arguments None","tags":"","loc":"interface/fruit_summary_xml.html"},{"title":"case_passed_xml – naturalFRUIT","text":"public interface case_passed_xml Calls interface~~case_passed_xml~~CallsGraph interface~case_passed_xml case_passed_xml proc~case_passed_xml_ case_passed_xml_ interface~case_passed_xml->proc~case_passed_xml_ proc~case_delta_t case_delta_t proc~case_passed_xml_->proc~case_delta_t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures case_passed_xml_ Module Procedures private subroutine case_passed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname","tags":"","loc":"interface/case_passed_xml.html"},{"title":"case_failed_xml – naturalFRUIT","text":"public interface case_failed_xml Calls interface~~case_failed_xml~~CallsGraph interface~case_failed_xml case_failed_xml proc~case_failed_xml_ case_failed_xml_ interface~case_failed_xml->proc~case_failed_xml_ proc~case_delta_t case_delta_t proc~case_failed_xml_->proc~case_delta_t interface~strip strip proc~case_failed_xml_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures case_failed_xml_ Module Procedures private subroutine case_failed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname","tags":"","loc":"interface/case_failed_xml.html"},{"title":"override_stdout – naturalFRUIT","text":"public interface override_stdout Calls interface~~override_stdout~~CallsGraph interface~override_stdout override_stdout proc~override_stdout_ override_stdout_ interface~override_stdout->proc~override_stdout_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures override_stdout_ Module Procedures private subroutine override_stdout_ (write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename","tags":"","loc":"interface/override_stdout.html"},{"title":"end_override_stdout – naturalFRUIT","text":"public interface end_override_stdout Calls interface~~end_override_stdout~~CallsGraph interface~end_override_stdout end_override_stdout proc~end_override_stdout_ end_override_stdout_ interface~end_override_stdout->proc~end_override_stdout_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures end_override_stdout_ Module Procedures private subroutine end_override_stdout_ () Arguments None","tags":"","loc":"interface/end_override_stdout.html"},{"title":"override_xml_work – naturalFRUIT","text":"public interface override_xml_work Calls interface~~override_xml_work~~CallsGraph interface~override_xml_work override_xml_work proc~override_xml_work_ override_xml_work_ interface~override_xml_work->proc~override_xml_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures override_xml_work_ Module Procedures private subroutine override_xml_work_ (new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename","tags":"","loc":"interface/override_xml_work.html"},{"title":"end_override_xml_work – naturalFRUIT","text":"public interface end_override_xml_work Calls interface~~end_override_xml_work~~CallsGraph interface~end_override_xml_work end_override_xml_work proc~end_override_xml_work_ end_override_xml_work_ interface~end_override_xml_work->proc~end_override_xml_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures end_override_xml_work_ Module Procedures private subroutine end_override_xml_work_ () Arguments None","tags":"","loc":"interface/end_override_xml_work.html"},{"title":"get_xml_filename_work – naturalFRUIT","text":"public interface get_xml_filename_work Calls interface~~get_xml_filename_work~~CallsGraph interface~get_xml_filename_work get_xml_filename_work proc~get_xml_filename_work_ get_xml_filename_work_ interface~get_xml_filename_work->proc~get_xml_filename_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~get_xml_filename_work~~CalledByGraph interface~get_xml_filename_work get_xml_filename_work proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ proc~fruit_summary_mpi_xml_->interface~get_xml_filename_work interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_xml_filename_work_ Module Procedures private subroutine get_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string","tags":"","loc":"interface/get_xml_filename_work.html"},{"title":"set_xml_filename_work – naturalFRUIT","text":"public interface set_xml_filename_work Calls interface~~set_xml_filename_work~~CallsGraph interface~set_xml_filename_work set_xml_filename_work proc~set_xml_filename_work_ set_xml_filename_work_ interface~set_xml_filename_work->proc~set_xml_filename_work_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~set_xml_filename_work~~CalledByGraph interface~set_xml_filename_work set_xml_filename_work proc~fruit_init_mpi_xml_ fruit_init_mpi_xml_ proc~fruit_init_mpi_xml_->interface~set_xml_filename_work interface~fruit_init_mpi_xml fruit_init_mpi_xml interface~fruit_init_mpi_xml->proc~fruit_init_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures set_xml_filename_work_ Module Procedures private subroutine set_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string","tags":"","loc":"interface/set_xml_filename_work.html"},{"title":"get_message_index – naturalFRUIT","text":"public interface get_message_index Calls interface~~get_message_index~~CallsGraph interface~get_message_index get_message_index proc~get_message_index_ get_message_index_ interface~get_message_index->proc~get_message_index_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~get_message_index~~CalledByGraph interface~get_message_index get_message_index proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_index interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_message_index_ Module Procedures private subroutine get_message_index_ (index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index","tags":"","loc":"interface/get_message_index.html"},{"title":"get_messages – naturalFRUIT","text":"public interface get_messages Calls interface~~get_messages~~CallsGraph interface~get_messages get_messages proc~get_messages_ get_messages_ interface~get_messages->proc~get_messages_ interface~strip strip proc~get_messages_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_messages_ Module Procedures private subroutine get_messages_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:)","tags":"","loc":"interface/get_messages.html"},{"title":"get_message_array – naturalFRUIT","text":"public interface get_message_array Calls interface~~get_message_array~~CallsGraph interface~get_message_array get_message_array proc~get_message_array_ get_message_array_ interface~get_message_array->proc~get_message_array_ interface~strip strip proc~get_message_array_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~get_message_array~~CalledByGraph interface~get_message_array get_message_array proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_message_array interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_message_array_ Module Procedures private subroutine get_message_array_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:)","tags":"","loc":"interface/get_message_array.html"},{"title":"set_unit_name – naturalFRUIT","text":"public interface set_unit_name Calls interface~~set_unit_name~~CallsGraph interface~set_unit_name set_unit_name proc~set_case_name_ set_case_name_ interface~set_unit_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures set_case_name_ Module Procedures private subroutine set_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value","tags":"","loc":"interface/set_unit_name.html"},{"title":"set_case_name – naturalFRUIT","text":"public interface set_case_name Calls interface~~set_case_name~~CallsGraph interface~set_case_name set_case_name proc~set_case_name_ set_case_name_ interface~set_case_name->proc~set_case_name_ interface~strip strip proc~set_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~set_case_name~~CalledByGraph interface~set_case_name set_case_name proc~run_test_case_named_ run_test_case_named_ proc~run_test_case_named_->interface~set_case_name proc~run_test_case_ run_test_case_ proc~run_test_case_->proc~run_test_case_named_ interface~run_test_case run_test_case interface~run_test_case->proc~run_test_case_named_ interface~run_test_case->proc~run_test_case_ interface~runtestcase runTestCase interface~runtestcase->proc~run_test_case_named_ interface~runtestcase->proc~run_test_case_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures set_case_name_ Module Procedures private subroutine set_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value","tags":"","loc":"interface/set_case_name.html"},{"title":"get_unit_name – naturalFRUIT","text":"public interface get_unit_name Calls interface~~get_unit_name~~CallsGraph interface~get_unit_name get_unit_name proc~get_case_name_ get_case_name_ interface~get_unit_name->proc~get_case_name_ interface~strip strip proc~get_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_case_name_ Module Procedures private subroutine get_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value","tags":"","loc":"interface/get_unit_name.html"},{"title":"get_case_name – naturalFRUIT","text":"public interface get_case_name Calls interface~~get_case_name~~CallsGraph interface~get_case_name get_case_name proc~get_case_name_ get_case_name_ interface~get_case_name->proc~get_case_name_ interface~strip strip proc~get_case_name_->interface~strip proc~strip_ strip_ interface~strip->proc~strip_ proc~strip_length_ strip_length_ interface~strip->proc~strip_length_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_case_name_ Module Procedures private subroutine get_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value","tags":"","loc":"interface/get_case_name.html"},{"title":"fruit_finalize – naturalFRUIT","text":"public interface fruit_finalize Calls interface~~fruit_finalize~~CallsGraph interface~fruit_finalize fruit_finalize proc~fruit_finalize_ fruit_finalize_ interface~fruit_finalize->proc~fruit_finalize_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fruit_finalize~~CalledByGraph interface~fruit_finalize fruit_finalize proc~fruit_finalize_mpi_ fruit_finalize_mpi_ proc~fruit_finalize_mpi_->interface~fruit_finalize interface~fruit_finalize_mpi fruit_finalize_mpi interface~fruit_finalize_mpi->proc~fruit_finalize_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_finalize_ Module Procedures private subroutine fruit_finalize_ () Arguments None","tags":"","loc":"interface/fruit_finalize.html"},{"title":"set_prefix – naturalFRUIT","text":"public interface set_prefix Calls interface~~set_prefix~~CallsGraph interface~set_prefix set_prefix proc~set_prefix_ set_prefix_ interface~set_prefix->proc~set_prefix_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures set_prefix_ Module Procedures private subroutine set_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"interface/set_prefix.html"},{"title":"get_prefix – naturalFRUIT","text":"public interface get_prefix Calls interface~~get_prefix~~CallsGraph interface~get_prefix get_prefix proc~get_prefix_ get_prefix_ interface~get_prefix->proc~get_prefix_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_prefix_ Module Procedures private subroutine get_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str","tags":"","loc":"interface/get_prefix.html"},{"title":"get_assert_and_case_count – naturalFRUIT","text":"public interface get_assert_and_case_count Calls interface~~get_assert_and_case_count~~CallsGraph interface~get_assert_and_case_count get_assert_and_case_count proc~get_assert_and_case_count_ get_assert_and_case_count_ interface~get_assert_and_case_count->proc~get_assert_and_case_count_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~get_assert_and_case_count~~CalledByGraph interface~get_assert_and_case_count get_assert_and_case_count proc~fruit_summary_mpi_xml_ fruit_summary_mpi_xml_ proc~fruit_summary_mpi_xml_->interface~get_assert_and_case_count proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~get_assert_and_case_count interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ interface~fruit_summary_mpi_xml fruit_summary_mpi_xml interface~fruit_summary_mpi_xml->proc~fruit_summary_mpi_xml_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures get_assert_and_case_count_ Module Procedures private subroutine get_assert_and_case_count_ (fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case","tags":"","loc":"interface/get_assert_and_case_count.html"},{"title":"fruit_summary_table – naturalFRUIT","text":"public interface fruit_summary_table Calls interface~~fruit_summary_table~~CallsGraph interface~fruit_summary_table fruit_summary_table proc~fruit_summary_table_ fruit_summary_table_ interface~fruit_summary_table->proc~fruit_summary_table_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fruit_summary_table~~CalledByGraph interface~fruit_summary_table fruit_summary_table proc~fruit_summary_mpi_ fruit_summary_mpi_ proc~fruit_summary_mpi_->interface~fruit_summary_table interface~fruit_summary_mpi fruit_summary_mpi interface~fruit_summary_mpi->proc~fruit_summary_mpi_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_summary_table_ Module Procedures private subroutine fruit_summary_table_ (succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case","tags":"","loc":"interface/fruit_summary_table.html"},{"title":"fruit_if_case_failed – naturalFRUIT","text":"public interface fruit_if_case_failed Calls interface~~fruit_if_case_failed~~CallsGraph interface~fruit_if_case_failed fruit_if_case_failed proc~fruit_if_case_failed_ fruit_if_case_failed_ interface~fruit_if_case_failed->proc~fruit_if_case_failed_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_if_case_failed_ Module Procedures private function fruit_if_case_failed_ () Arguments None Return Value logical","tags":"","loc":"interface/fruit_if_case_failed.html"},{"title":"fruit_hide_dots – naturalFRUIT","text":"public interface fruit_hide_dots Calls interface~~fruit_hide_dots~~CallsGraph interface~fruit_hide_dots fruit_hide_dots proc~fruit_hide_dots_ fruit_hide_dots_ interface~fruit_hide_dots->proc~fruit_hide_dots_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_hide_dots_ Module Procedures private subroutine fruit_hide_dots_ () Arguments None","tags":"","loc":"interface/fruit_hide_dots.html"},{"title":"fruit_show_dots – naturalFRUIT","text":"public interface fruit_show_dots Calls interface~~fruit_show_dots~~CallsGraph interface~fruit_show_dots fruit_show_dots proc~fruit_show_dots_ fruit_show_dots_ interface~fruit_show_dots->proc~fruit_show_dots_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fruit_show_dots_ Module Procedures private subroutine fruit_show_dots_ () Arguments None","tags":"","loc":"interface/fruit_show_dots.html"},{"title":"fruit_mpi – naturalFRUIT","text":"Uses fruit mpi module~~fruit_mpi~~UsesGraph module~fruit_mpi fruit_mpi mpi mpi module~fruit_mpi->mpi module~fruit fruit module~fruit_mpi->module~fruit module~fruit_util fruit_util module~fruit->module~fruit_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables XML_OPEN XML_WORK xml_filename NUMBER_LENGTH FN_LENGTH Interfaces fruit_init_mpi_xml fruit_finalize_mpi fruit_summary_mpi fruit_summary_mpi_xml Functions int_to_str Subroutines fruit_init_mpi_xml_ fruit_finalize_mpi_ fruit_summary_mpi_ fruit_summary_mpi_xml_ Variables Type Visibility Attributes Name Initial integer, private, parameter :: XML_OPEN = 20 integer, private, parameter :: XML_WORK = 21 character(len=*), private, parameter :: xml_filename = \"result.xml\" integer, private, parameter :: NUMBER_LENGTH = 10 integer, private, parameter :: FN_LENGTH = 50 Interfaces public interface fruit_init_mpi_xml private subroutine fruit_init_mpi_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank public interface fruit_finalize_mpi private subroutine fruit_finalize_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank public interface fruit_summary_mpi private subroutine fruit_summary_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank public interface fruit_summary_mpi_xml private subroutine fruit_summary_mpi_xml_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank Functions private function int_to_str (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=NUMBER_LENGTH) Subroutines private subroutine fruit_init_mpi_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rank private subroutine fruit_finalize_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank private subroutine fruit_summary_mpi_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank private subroutine fruit_summary_mpi_xml_ (size, rank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: size integer, intent(in) :: rank","tags":"","loc":"module/fruit_mpi.html"},{"title":"fruit_util – naturalFRUIT","text":"Used by module~~fruit_util~~UsedByGraph module~fruit_util fruit_util module~fruit fruit module~fruit->module~fruit_util module~fruit_mpi fruit_mpi module~fruit_mpi->module~fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces equals to_s strip Functions to_s_int_ to_s_real_ to_s_double_ to_s_complex_ to_s_double_complex_ to_s_logical_ to_s_string_ strip_ strip_length_ equalEpsilon floatEqual doublePrecisionEqual integerEqual stringEqual logicalEqual Interfaces public interface equals private function equalEpsilon (number1, number2, epsilon) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 real, intent(in) :: epsilon Return Value logical private function floatEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 Return Value logical private function integerEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number1 integer, intent(in) :: number2 Return Value logical private function doublePrecisionEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: number1 double precision, intent(in) :: number2 Return Value logical private function stringEqual (str1, str2) result(resultValue) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private function logicalEqual (l1, l2) result(resultValue) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l1 logical, intent(in) :: l2 Return Value logical public interface to_s private function to_s_int_ (value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=500) private function to_s_real_ (value) Arguments Type Intent Optional Attributes Name real, intent(in) :: value Return Value character(len=500) private function to_s_logical_ (value) Arguments Type Intent Optional Attributes Name logical, intent(in) :: value Return Value character(len=500) private function to_s_double_ (value) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value Return Value character(len=500) private function to_s_complex_ (value) Arguments Type Intent Optional Attributes Name complex, intent(in) :: value Return Value character(len=500) private function to_s_double_complex_ (value) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: value Return Value character(len=500) private function to_s_string_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) public interface strip private function strip_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) private function strip_length_ (value, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value integer, intent(in) :: length Return Value character(len=length) Functions private function to_s_int_ (value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value character(len=500) private function to_s_real_ (value) Arguments Type Intent Optional Attributes Name real, intent(in) :: value Return Value character(len=500) private function to_s_double_ (value) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: value Return Value character(len=500) private function to_s_complex_ (value) Arguments Type Intent Optional Attributes Name complex, intent(in) :: value Return Value character(len=500) private function to_s_double_complex_ (value) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: value Return Value character(len=500) private function to_s_logical_ (value) Arguments Type Intent Optional Attributes Name logical, intent(in) :: value Return Value character(len=500) private function to_s_string_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) private function strip_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(len=500) private function strip_length_ (value, length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value integer, intent(in) :: length Return Value character(len=length) private function equalEpsilon (number1, number2, epsilon) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 real, intent(in) :: epsilon Return Value logical private function floatEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: number1 real, intent(in) :: number2 Return Value logical private function doublePrecisionEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: number1 double precision, intent(in) :: number2 Return Value logical private function integerEqual (number1, number2) result(resultValue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number1 integer, intent(in) :: number2 Return Value logical private function stringEqual (str1, str2) result(resultValue) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private function logicalEqual (l1, l2) result(resultValue) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l1 logical, intent(in) :: l2 Return Value logical","tags":"","loc":"module/fruit_util.html"},{"title":"fruit – naturalFRUIT","text":"Uses fruit_util module~~fruit~~UsesGraph module~fruit fruit module~fruit_util fruit_util module~fruit->module~fruit_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fruit~~UsedByGraph module~fruit fruit module~fruit_mpi fruit_mpi module~fruit_mpi->module~fruit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables STDOUT_DEFAULT stdout XML_OPEN XML_WORK_DEFAULT xml_work xml_filename XML_FN_WORK_DEF xml_filename_work MAX_NUM_FAILURES_IN_XML XML_LINE_LENGTH STRLEN_T NUMBER_LENGTH MSG_LENGTH MAX_MSG_STACK_SIZE MSG_ARRAY_INCREMENT MAX_MARKS_PER_LINE DEFAULT_CASE_NAME DEFAULT_CASE_PASSED successful_assert_count failed_assert_count message_index message_index_from current_max message_array msg case_name successful_case_count failed_case_count testCaseIndex last_passed case_passed case_time_from linechar_count if_show_dots FRUIT_PREFIX_LEN_MAX prefix stashed_suite Interfaces initializeFruit getTestSummary assertTrue assert_false assert_equals assertEquals assert_not_equals assertNotEquals addSuccess add_fail addFail getTotalCount getFailedCount isAllSuccessful run_test_case runTestCase init_fruit_xml fruit_summary fruit_summary_xml case_passed_xml case_failed_xml override_stdout end_override_stdout override_xml_work end_override_xml_work get_xml_filename_work set_xml_filename_work get_message_index get_messages get_message_array set_unit_name set_case_name get_unit_name get_case_name fruit_finalize set_prefix get_prefix get_assert_and_case_count fruit_summary_table fruit_if_case_failed fruit_hide_dots fruit_show_dots Derived Types ty_stack Functions case_delta_t int_to_str fruit_if_case_failed_ get_last_message is_last_passed is_case_passed Subroutines init_fruit fruit_finalize_ init_fruit_xml_ case_passed_xml_ case_failed_xml_ fruit_summary_xml_ obsolete_initializeFruit_ obsolete_getTestSummary_ fruit_show_dots_ fruit_hide_dots_ run_test_case_named_ run_test_case_ fruit_summary_ fruit_summary_table_ obsolete_addSuccess_ add_fail_ add_fail_unit_ obsolete_isAllSuccessful_ is_all_successful output_mark_ success_mark_ failed_mark_ increase_message_stack_ get_xml_filename_work_ set_xml_filename_work_ get_message_index_ get_message_array_ get_messages_ obsolete_getTotalCount_ get_total_count obsolete_getFailedCount_ get_failed_count obsolete_ add_success failed_assert_action set_case_name_ get_case_name_ make_error_msg_ override_stdout_ override_xml_work_ stash_test_suite restore_test_suite end_override_stdout_ end_override_xml_work_ set_prefix_ get_prefix_ get_assert_and_case_count_ obsolete_assert_true_logical_ assert_true assert_false_ assert_eq_logical_ assert_eq_1d_logical_ assert_eq_2d_logical_ assert_eq_string_ assert_eq_1d_string_ assert_eq_2d_string_ assert_eq_int_ assert_eq_1d_int_ assert_eq_2d_int_ assert_eq_real_ assert_eq_real_in_range_ assert_eq_1d_real_ assert_eq_1d_real_in_range_ assert_eq_2d_real_ assert_eq_2d_real_in_range_ assert_eq_double_ assert_eq_double_in_range_ assert_eq_1d_double_ assert_eq_1d_double_in_range_ assert_eq_2d_double_ assert_eq_2d_double_in_range_ assert_eq_complex_ assert_eq_complex_in_range_ assert_eq_1d_complex_ assert_eq_1d_complex_in_range_ assert_eq_2d_complex_ assert_eq_2d_complex_in_range_ assert_not_equals_logical_ assert_not_equals_1d_logical_ assert_not_equals_2d_logical_ assert_not_equals_string_ assert_not_equals_1d_string_ assert_not_equals_2d_string_ assert_not_equals_int_ assert_not_equals_1d_int_ assert_not_equals_2d_int_ assert_not_equals_real_ assert_not_equals_real_in_range_ assert_not_equals_1d_real_ assert_not_equals_1d_real_in_range_ assert_not_equals_2d_real_ assert_not_equals_2d_real_in_range_ assert_not_equals_double_ assert_not_equals_double_in_range_ assert_not_equals_1d_double_ assert_not_equals_1d_double_in_range_ assert_not_equals_2d_double_ assert_not_equals_2d_double_in_range_ assert_not_equals_complex_ assert_not_equals_complex_in_range_ assert_not_equals_1d_complex_ assert_not_equals_1d_complex_in_range_ assert_not_equals_2d_complex_ assert_not_equals_2d_complex_in_range_ Variables Type Visibility Attributes Name Initial integer, private, parameter :: STDOUT_DEFAULT = 6 integer, private :: stdout = STDOUT_DEFAULT integer, private, parameter :: XML_OPEN = 20 integer, private, parameter :: XML_WORK_DEFAULT = 21 integer, private :: xml_work = XML_WORK_DEFAULT character(len=*), private, parameter :: xml_filename = \"result.xml\" character(len=*), private, parameter :: XML_FN_WORK_DEF = \"result_tmp.xml\" character(len=50), private :: xml_filename_work = XML_FN_WORK_DEF integer, private, parameter :: MAX_NUM_FAILURES_IN_XML = 10 integer, private, parameter :: XML_LINE_LENGTH = 2670 xml_line_length >= max_num_failures_in_xml * (msg_length + 1) + 50 integer, private, parameter :: STRLEN_T = 12 integer, private, parameter :: NUMBER_LENGTH = 10 integer, private, parameter :: MSG_LENGTH = 256 integer, private, parameter :: MAX_MSG_STACK_SIZE = 2000 integer, private, parameter :: MSG_ARRAY_INCREMENT = 50 integer, private, parameter :: MAX_MARKS_PER_LINE = 78 character(len=*), private, parameter :: DEFAULT_CASE_NAME = '_not_set_' logical, private, parameter :: DEFAULT_CASE_PASSED = .true. integer, private, save :: successful_assert_count = 0 integer, private, save :: failed_assert_count = 0 integer, private, save :: message_index = 1 integer, private, save :: message_index_from = 1 integer, private, save :: current_max = 50 character(len=MSG_LENGTH), private, allocatable :: message_array (:) character(len=MSG_LENGTH), private, save :: msg = '[unit name not set from set_name]: ' character(len=MSG_LENGTH), private, save :: case_name = DEFAULT_CASE_NAME integer, private, save :: successful_case_count = 0 integer, private, save :: failed_case_count = 0 integer, private, save :: testCaseIndex = 1 logical, private, save :: last_passed = .false. logical, private, save :: case_passed = DEFAULT_CASE_PASSED integer, private, save :: case_time_from = 0 integer, private, save :: linechar_count = 0 logical, private, save :: if_show_dots = .true. integer, public, parameter :: FRUIT_PREFIX_LEN_MAX = 50 character(len=FRUIT_PREFIX_LEN_MAX), private :: prefix = \"\" type( ty_stack ), private, save :: stashed_suite Interfaces public interface initializeFruit private subroutine obsolete_initializeFruit_ () Arguments None public interface getTestSummary private subroutine obsolete_getTestSummary_ () Arguments None public interface assertTrue private subroutine obsolete_assert_true_logical_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message public interface assert_false private subroutine assert_false_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message public interface assert_equals private subroutine assert_eq_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface assertEquals private subroutine assert_eq_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface assert_not_equals private subroutine assert_not_equals_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface assertNotEquals private subroutine assert_not_equals_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message public interface addSuccess private subroutine obsolete_addSuccess_ () Arguments None public interface add_fail private subroutine add_fail_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_ (unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message public interface addFail private subroutine add_fail_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_ (unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message public interface getTotalCount private subroutine obsolete_getTotalCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public interface getFailedCount private subroutine obsolete_getFailedCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public interface isAllSuccessful private subroutine obsolete_isAllSuccessful_ (result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result public interface run_test_case private subroutine run_test_case_ (tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_ (tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name public interface runTestCase private subroutine run_test_case_ (tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine run_test_case_named_ (tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name public interface init_fruit_xml private subroutine init_fruit_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank public interface fruit_summary private subroutine fruit_summary_ () Arguments None public interface fruit_summary_xml private subroutine fruit_summary_xml_ () Arguments None public interface case_passed_xml private subroutine case_passed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public interface case_failed_xml private subroutine case_failed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public interface override_stdout private subroutine override_stdout_ (write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename public interface end_override_stdout private subroutine end_override_stdout_ () Arguments None public interface override_xml_work private subroutine override_xml_work_ (new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename public interface end_override_xml_work private subroutine end_override_xml_work_ () Arguments None public interface get_xml_filename_work private subroutine get_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string public interface set_xml_filename_work private subroutine set_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public interface get_message_index private subroutine get_message_index_ (index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index public interface get_messages private subroutine get_messages_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public interface get_message_array private subroutine get_message_array_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public interface set_unit_name private subroutine set_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value public interface set_case_name private subroutine set_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value public interface get_unit_name private subroutine get_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value public interface get_case_name private subroutine get_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value public interface fruit_finalize private subroutine fruit_finalize_ () Arguments None public interface set_prefix private subroutine set_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str public interface get_prefix private subroutine get_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str public interface get_assert_and_case_count private subroutine get_assert_and_case_count_ (fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case public interface fruit_summary_table private subroutine fruit_summary_table_ (succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case public interface fruit_if_case_failed private function fruit_if_case_failed_ () Arguments None Return Value logical public interface fruit_hide_dots private subroutine fruit_hide_dots_ () Arguments None public interface fruit_show_dots private subroutine fruit_show_dots_ () Arguments None Derived Types type, private :: ty_stack Components Type Visibility Attributes Name Initial integer, public :: successful_assert_count integer, public :: failed_assert_count integer, public :: message_index integer, public :: message_index_from integer, public :: current_max character(len=MSG_LENGTH), public, pointer :: message_array (:) character(len=MSG_LENGTH), public :: case_name integer, public :: successful_case_count integer, public :: failed_case_count integer, public :: testCaseIndex logical, public :: last_passed logical, public :: case_passed = DEFAULT_CASE_PASSED integer, public :: case_time_from integer, public :: linechar_count logical, public :: if_show_dots Functions private function case_delta_t () Arguments None Return Value character(len=STRLEN_T) private function int_to_str (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=NUMBER_LENGTH) private function fruit_if_case_failed_ () Arguments None Return Value logical public function get_last_message () Arguments None Return Value character(len=MSG_LENGTH) public function is_last_passed () Arguments None Return Value logical public function is_case_passed () Arguments None Return Value logical Subroutines public subroutine init_fruit (rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank private subroutine fruit_finalize_ () Arguments None private subroutine init_fruit_xml_ (rank) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank private subroutine case_passed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname private subroutine case_failed_xml_ (tc_name, classname) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname private subroutine fruit_summary_xml_ () Arguments None private subroutine obsolete_initializeFruit_ () Arguments None private subroutine obsolete_getTestSummary_ () Arguments None private subroutine fruit_show_dots_ () Arguments None private subroutine fruit_hide_dots_ () Arguments None private subroutine run_test_case_named_ (tc, tc_name) reset linechar_count for each test case.\n! \"case_passed\" is true here.\n! \"case_passed\" becomes .false. at the first fail of assertion Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None character(len=*), intent(in) :: tc_name private subroutine run_test_case_ (tc) Arguments Type Intent Optional Attributes Name public subroutine tc() Arguments None private subroutine fruit_summary_ () Arguments None private subroutine fruit_summary_table_ (succ_assert, fail_assert, succ_case, fail_case) Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case private subroutine obsolete_addSuccess_ () Arguments None private subroutine add_fail_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_unit_ (unitName, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: unitName character(len=*), intent(in) :: message private subroutine obsolete_isAllSuccessful_ (result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result public subroutine is_all_successful (result) Arguments Type Intent Optional Attributes Name logical, intent(out) :: result private subroutine output_mark_ (chr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: chr integer, save :: linechar_count = 0\n  Definition of linechar_count is moved to module,\n  so that it can be stashed and restored. private subroutine success_mark_ () Arguments None private subroutine failed_mark_ () Arguments None private subroutine increase_message_stack_ () Arguments None private subroutine get_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string private subroutine set_xml_filename_work_ (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string private subroutine get_message_index_ (index) Arguments Type Intent Optional Attributes Name integer, intent(out) :: index private subroutine get_message_array_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) private subroutine get_messages_ (msgs) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) private subroutine obsolete_getTotalCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine get_total_count (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count private subroutine obsolete_getFailedCount_ (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine get_failed_count (count) Arguments Type Intent Optional Attributes Name integer, intent(out) :: count private subroutine obsolete_ (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message public subroutine add_success () Arguments None public subroutine failed_assert_action (expected, got, message, if_is) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is private subroutine set_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value private subroutine get_case_name_ (value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value private subroutine make_error_msg_ (var1, var2, if_is, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 logical, intent(in) :: if_is character(len=*), intent(in), optional :: message private subroutine override_stdout_ (write_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename private subroutine override_xml_work_ (new_unit, filename) Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename public subroutine stash_test_suite () Arguments None public subroutine restore_test_suite () Arguments None private subroutine end_override_stdout_ () Arguments None private subroutine end_override_xml_work_ () Arguments None private subroutine set_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str private subroutine get_prefix_ (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str private subroutine get_assert_and_case_count_ (fail_assert, suc_assert, fail_case, suc_case) Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case private subroutine obsolete_assert_true_logical_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message public subroutine assert_true (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message private subroutine assert_false_ (var1, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message private subroutine assert_eq_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_eq_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_eq_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_eq_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_logical_ (var1, var2, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_logical_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n) logical, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_logical_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 (n,m) logical, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_string_ (var1, var2, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_string_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n) character(len=*), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_string_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 (n,m) character(len=*), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_int_ (var1, var2, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_int_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n) integer, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_int_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 (n,m) integer, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_ (var1, var2, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_real_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_real_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n) real, intent(in) :: var2 (n) integer, intent(in) :: n real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_real_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 (n,m) real, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m real, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_ (var1, var2, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_double_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 double precision, intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_double_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n) double precision, intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_double_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: var1 (n,m) double precision, intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_ (var1, var2, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 character(len=*), intent(in), optional :: message private subroutine assert_not_equals_complex_in_range_ (var1, var2, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 complex(kind=kind(1.0D0)), intent(in) :: var2 double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_ (var1, var2, n, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n character(len=*), intent(in), optional :: message private subroutine assert_not_equals_1d_complex_in_range_ (var1, var2, n, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n) complex(kind=kind(1.0D0)), intent(in) :: var2 (n) integer, intent(in) :: n double precision, intent(in) :: delta character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_ (var1, var2, n, m, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in), optional :: message private subroutine assert_not_equals_2d_complex_in_range_ (var1, var2, n, m, delta, message) Arguments Type Intent Optional Attributes Name complex(kind=kind(1.0D0)), intent(in) :: var1 (n,m) complex(kind=kind(1.0D0)), intent(in) :: var2 (n,m) integer, intent(in) :: n integer, intent(in) :: m double precision, intent(in) :: delta character(len=*), intent(in), optional :: message","tags":"","loc":"module/fruit.html"},{"title":"Documentation – naturalFRUIT","text":"Under construction","tags":"","loc":"page//index.html"}]}