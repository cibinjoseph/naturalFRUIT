var tipuesearch = {"pages":[{"title":" naturalFRUIT ","text":"naturalFRUIT A purely Fortran based unit testing framework derived from the original Fortran Unit Test Framework (FRUIT) . The term natural in naturalFRUIT, signifies a framework unadultered by programming languages other than Fortran. Documentation available here .\nFor a list of test subroutines visit the Procedures page. Developer Info Cibin Joseph Ph.D. student at IIT Madras, India.","tags":"home","loc":"index.html"},{"title":"naturalfruit.f90 â€“ naturalFRUIT","text":"Contents Modules naturalfruit Source Code naturalfruit.f90 Source Code !---------------------------------------------------------- ! naturalFRUIT ! VERSION: 0.2 ! LICENSE: BSD-3-Clause ! ! Original author: Andrew H. Chen meihome@gmail.com ! Modified by: Cibin Joseph cibinjoseph92@gmail.com !---------------------------------------------------------- ! ! This work is derived from FRUIT, ! Unit test framework for FORTRAN.  (FoRtran UnIT) ! ! This module is to perform unit testing for FORTRAN subroutines ! The methods used most are: assert_true, assert_equal ! module naturalfruit !! Summary: This module contains fruit procedures and variables !! This module contains the procedures and variables that the user may use !! for unit testing with fruit. implicit none private integer , parameter :: dp = kind ( 1.0d0 ) !! Double precision real , parameter :: eps = epsilon ( 1.0 ) !! Machine epsilon real , parameter :: eps_dp = epsilon ( 1.0d0 ) !! Machine epsilon integer , parameter :: STDOUT_DEFAULT = 6 integer :: stdout = STDOUT_DEFAULT integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK_DEFAULT = 21 integer :: xml_work = XML_WORK_DEFAULT character ( len =* ), parameter :: xml_filename = \"result.xml\" character ( len =* ), parameter :: XML_FN_WORK_DEF = \"result_tmp.xml\" character ( len = 50 ) :: xml_filename_work = XML_FN_WORK_DEF integer , parameter :: MAX_NUM_FAILURES_IN_XML = 10 integer , parameter :: XML_LINE_LENGTH = 2670 ! xml_line_length >= max_num_failures_in_xml * (msg_length + 1) + 50 integer , parameter :: STRLEN_T = 12 integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: MSG_LENGTH = 256 integer , parameter :: MAX_MSG_STACK_SIZE = 2000 integer , parameter :: MSG_ARRAY_INCREMENT = 50 integer , parameter :: MAX_MARKS_PER_LINE = 78 character ( * ), parameter :: DEFAULT_CASE_NAME = '_not_set_' logical , private , parameter :: DEFAULT_CASE_PASSED = . true . !---------- save ---------- integer , private , save :: successful_assert_count = 0 integer , private , save :: failed_assert_count = 0 integer , private , save :: initial_failed_assert_count = 0 integer , private , save :: message_index = 1 integer , private , save :: message_index_from = 1 integer , private , save :: current_max = 50 character ( len = MSG_LENGTH ), private , allocatable :: message_array (:) character ( len = MSG_LENGTH ), private , save :: msg = '[case name not set from set_name]: ' character ( len = MSG_LENGTH ), private , save :: case_name = DEFAULT_CASE_NAME integer , private , save :: successful_case_count = 0 integer , private , save :: failed_case_count = 0 integer , private , save :: testCaseIndex = 1 logical , private , save :: last_passed = . false . logical , private , save :: case_passed = DEFAULT_CASE_PASSED integer , private , save :: case_time_from = 0 integer , private , save :: linechar_count = 0 logical , private , save :: if_show_dots = . true . integer , parameter :: FRUIT_PREFIX_LEN_MAX = 50 character ( len = FRUIT_PREFIX_LEN_MAX ) :: prefix = \"\" !---------- save ---------- type ty_stack !! display: none integer :: successful_assert_count , failed_assert_count integer :: initial_failed_assert_count integer :: message_index integer :: message_index_from integer :: current_max character ( len = MSG_LENGTH ), pointer :: message_array (:) character ( len = MSG_LENGTH ) :: case_name !  = DEFAULT_CASE_NAME integer :: successful_case_count , failed_case_count integer :: testCaseIndex logical :: last_passed logical :: case_passed = DEFAULT_CASE_PASSED integer :: case_time_from integer :: linechar_count logical :: if_show_dots end type ty_stack type ( ty_stack ), save :: stashed_suite public :: FRUIT_PREFIX_LEN_MAX private :: to_s ! Assert subroutines public :: assert_equal , assert_not_equal public :: assert_true , assert_false public :: assert_identical , assert_not_identical ! Common testing subroutines public :: testsuite_initialize , testsuite_finalize public :: testcase_initialize , testcase_finalize public :: testsuite_summary , testsuite_summary_table public :: fruit_if_case_failed , failed_assert_action public :: get_total_count , get_failed_count public :: get_assert_and_case_count public :: get_case_name , set_case_name public :: add_success , add_fail public :: stash_test_suite , restore_test_suite ! Subroutines for checks public :: is_last_passed , is_case_passed public :: is_all_successful ! Message subroutines public :: get_last_message public :: get_messages , get_message_array public :: get_message_index ! XML specific subroutines public :: testsuite_initialize_xml public :: testsuite_summary_xml public :: case_passed_xml , case_failed_xml public :: get_xml_filename_work , set_xml_filename_work ! Override subroutines public :: override_stdout , end_override_stdout public :: override_xml_work , end_override_xml_work public :: fruit_hide_dots , fruit_show_dots public :: get_prefix , set_prefix private :: findfalse ! findloc() intrinsic introduced in Fortran 2008 ! may be used in place of findfalse. ! However, untill gfortran-9 is well adopted by users, ! findfalse can be used for ease of setup interface assert_equal !! category: testcase subroutines !! summary: Test that *var1* and *var2* are equal. !! Test that *var1* and *var2* are equal. !! If the values do not compare equal, the test will fail.<br/><br/> !! assert_equal invokes one of the following subroutines according !! to the number or type of arguments. !====== begin of generated interface ====== module procedure assert_eq_logical_ module procedure assert_eq_1d_logical_ module procedure assert_eq_2d_logical_ module procedure assert_eq_string_ module procedure assert_eq_1d_string_ module procedure assert_eq_2d_string_ module procedure assert_eq_int_ module procedure assert_eq_1d_int_ module procedure assert_eq_2d_int_ module procedure assert_eq_real_ module procedure assert_eq_1d_real_ module procedure assert_eq_2d_real_ module procedure assert_eq_double_ module procedure assert_eq_1d_double_ module procedure assert_eq_2d_double_ module procedure assert_eq_complex_real_ module procedure assert_eq_1d_complex_real_ module procedure assert_eq_2d_complex_real_ module procedure assert_eq_complex_double_ module procedure assert_eq_1d_complex_double_ module procedure assert_eq_2d_complex_double_ !====== end of generated inteface ====== end interface interface assert_not_equal !! category: testcase subroutines !! summary: Test that *var1* and *var2* are not equal. !! Test that *var1* and *var2* are not equal. !! If the values do compare equal, the test will fail.<br/><br/> !! assert_not_equal invokes one of the following subroutines according !! to the number or type of arguments. !====== begin of generated interface ====== module procedure assert_not_eq_logical_ module procedure assert_not_eq_1d_logical_ module procedure assert_not_eq_2d_logical_ module procedure assert_not_eq_string_ module procedure assert_not_eq_1d_string_ module procedure assert_not_eq_2d_string_ module procedure assert_not_eq_int_ module procedure assert_not_eq_1d_int_ module procedure assert_not_eq_2d_int_ module procedure assert_not_eq_real_ module procedure assert_not_eq_1d_real_ module procedure assert_not_eq_2d_real_ module procedure assert_not_eq_double_ module procedure assert_not_eq_1d_double_ module procedure assert_not_eq_2d_double_ module procedure assert_not_eq_complex_real_ module procedure assert_not_eq_1d_complex_real_ module procedure assert_not_eq_2d_complex_real_ module procedure assert_not_eq_complex_double_ module procedure assert_not_eq_1d_complex_double_ module procedure assert_not_eq_2d_complex_double_ !====== end of generated inteface ====== end interface interface add_fail !! category: testsuite subroutine !! summary: Print message to screen on assert failure and add to count. !! Print message to screen on assert failure and add to count.<br/><br/> !! add_fail invokes one of the following subroutines according !! to number of arguments. module procedure add_fail_ module procedure add_fail_case_named_ end interface interface to_s !! Convert to string module procedure to_s_int_ module procedure to_s_real_ module procedure to_s_logical_ module procedure to_s_double_ module procedure to_s_complex_ module procedure to_s_double_complex_ module procedure to_s_string_ end interface interface findfalse !! Returns location of first occurence of false value module procedure findfalse_1d_ module procedure findfalse_2d_ end interface findfalse contains subroutine testsuite_initialize ( rank ) !! category: testsuite subroutine !! Initialize FRUIT driver environment. integer , intent ( in ), optional :: rank logical :: if_write successful_assert_count = 0 failed_assert_count = 0 message_index = 1 message_index_from = 1 if_write = . true . if ( present ( rank )) then if ( rank /= 0 ) if_write = . false . endif if ( if_write ) then write ( stdout , * ) write ( stdout , * ) \"Test module initialized\" write ( stdout , * ) write ( stdout , * ) \"   . : successful assert,   F : failed assert \" write ( stdout , * ) endif !$omp critical     (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if (. not . allocated ( message_array )) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) end subroutine testsuite_initialize subroutine testsuite_finalize ( exit_code ) !! category: testsuite subroutine !! summary: Finalize FRUIT driver environment !! Finalize FRUIT driver environment and optionally !!  return no. of failed cases as an *exit_code*. !!  for exception handling integer , intent ( out ), optional :: exit_code !$omp critical     (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) if ( allocated ( message_array )) then deallocate ( message_array ) endif if ( present ( exit_code )) exit_code = failed_case_count !$omp end critical (FRUIT_OMP_DEALLOCATE_MESSAGE_ARRAY) end subroutine testsuite_finalize subroutine testsuite_initialize_xml ( rank ) !! category: testsuite subroutine !! Initialize FRUIT driver environment for output to XML file integer , optional , intent ( in ) :: rank logical :: rank_zero_or_single rank_zero_or_single = . true . if ( present ( rank )) then if ( rank /= 0 ) then rank_zero_or_single = . false . endif endif if ( rank_zero_or_single ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite \")' , advance = \"no\" ) write ( XML_OPEN , '(      \"errors=\"\"0\"\" \"   )' , advance = \"no\" ) write ( XML_OPEN , '(      \"tests=\"\"1\"\" \"    )' , advance = \"no\" ) write ( XML_OPEN , '(      \"failures=\"\"1\"\" \" )' , advance = \"no\" ) write ( XML_OPEN , '(      \"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) \"name of test suite\" write ( XML_OPEN , '(      \"id=\"\"1\"\">\")' ) write ( XML_OPEN , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & \"dummy_testcase\" , \"dummy_classname\" , \"0\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"      <failure type=\"\"failure\"\" message=\"\"\" write ( XML_OPEN , '(a)' , advance = \"no\" ) \"FRUIT did not generate regular content of result.xml.\" write ( XML_OPEN , '(a)' ) \"\"\"/>\" write ( XML_OPEN , '(\"    </testcase>\")' ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif open ( xml_work , FILE = xml_filename_work , action = \"write\" , status = 'replace' ) close ( xml_work ) end subroutine testsuite_initialize_xml function case_delta_t () character ( len = STRLEN_T ) :: case_delta_t real :: delta_t integer :: case_time_to , time_rate , time_max call system_clock ( case_time_to , time_rate , time_max ) if ( time_rate > 0 ) then delta_t = real ( case_time_to - case_time_from ) / real ( time_rate ) if ( delta_t < 0 ) then delta_t = delta_t + real ( time_max ) / real ( time_rate ) endif else delta_t = 0 endif write ( case_delta_t , '(g12.4)' ) delta_t case_delta_t = adjustl ( case_delta_t ) end function case_delta_t subroutine case_passed_xml ( tc_name , classname ) !! category: testsuite subroutine !! Write to XML file a passed case. character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\"/>\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) close ( xml_work ) end subroutine case_passed_xml subroutine case_failed_xml ( tc_name , classname ) !! category: testsuite subroutine !! Write to XML file a passed case. character ( * ), intent ( in ) :: tc_name character ( * ), intent ( in ) :: classname integer :: i , j character ( len = STRLEN_T ) :: case_time case_time = case_delta_t () open ( xml_work , FILE = xml_filename_work , position = 'append' ) write ( xml_work , & & '(\"    <testcase name=\"\"\", a, \"\"\" classname=\"\"\", a, a, \"\"\" time=\"\"\", a, \"\"\">\")' ) & & trim ( tc_name ), trim ( prefix ), trim ( classname ), trim ( case_time ) write ( xml_work , '(\"      <failure type=\"\"failure\"\" message=\"\"\")' , advance = \"no\" ) do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > MAX_NUM_FAILURES_IN_XML ) then write ( xml_work , '(\"(omit the rest)\")' , advance = \"no\" ) exit endif write ( xml_work , '(a)' , advance = \"no\" ) trim ( adjustl ( message_array ( i ))) if ( i == message_index - 1 ) then continue else write ( xml_work , '(\"&#xA;\")' , advance = \"no\" ) endif enddo write ( xml_work , '(\"\"\"/>\")' ) write ( xml_work , & & '(\"    </testcase>\")' ) close ( xml_work ) end subroutine case_failed_xml subroutine testsuite_summary_xml !! category: testsuite subroutine !! Summarize FRUIT test results in XML format to result.xml file. character ( len = XML_LINE_LENGTH ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count full_count = int_to_str ( successful_case_count + failed_case_count ) fail_count = int_to_str ( failed_case_count ) open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) open ( xml_work , FILE = xml_filename_work ) do read ( xml_work , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( xml_work ) write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) end subroutine testsuite_summary_xml function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str logical function fruit_if_case_failed () !! category: testsuite subroutine !! Return TRUE if any assert in current case has failed. if ( failed_assert_count == 0 ) then fruit_if_case_failed = . false . return endif if ( case_passed ) then fruit_if_case_failed = . false . else fruit_if_case_failed = . true . endif end function fruit_if_case_failed subroutine fruit_show_dots !! category: testsuite subroutine !! Show dots signifying test success on screen. Visible by default. if_show_dots = . true . end subroutine fruit_show_dots subroutine fruit_hide_dots !! category: testsuite subroutine !! Hide dots signifying test success on screen. Visible by default. if_show_dots = . false . end subroutine fruit_hide_dots subroutine testcase_initialize ( tc_name ) !! category: testcase subroutine !! summary: Initialize a testcase. !! Initialize a test case.<br/><br/> character ( * ), intent ( in ), optional :: tc_name initial_failed_assert_count = failed_assert_count ! Set the name of the test case if ( present ( tc_name )) then call set_case_name ( tc_name ) else call set_case_name ( 'unnamed' ) endif last_passed = . true . case_passed = . true . linechar_count = 0 ! reset linechar_count for each test case. message_index_from = message_index call system_clock ( case_time_from ) !$OMP BARRIER ! \"case_passed\" is true here. ! \"case_passed\" becomes .false. at the first fail of assertion end subroutine testcase_initialize subroutine testcase_finalize ( exit_code ) !! category: testcase subroutine !! summary: Finalize a testcase !! Finalize a testcase and optionally !! return no. of failed asserts as an *exit_code*. !! Initialize a test case.<br/><br/> integer , intent ( out ), optional :: exit_code !$OMP BARRIER if ( initial_failed_assert_count . eq . failed_assert_count ) then ! If no additional assertions failed during the run of this test case ! then the test case was successful successful_case_count = successful_case_count + 1 else failed_case_count = failed_case_count + 1 end if testCaseIndex = testCaseIndex + 1 if ( present ( exit_code )) & & exit_code = failed_assert_count - initial_failed_assert_count ! Reset the name of the unit test back to the default call set_case_name ( DEFAULT_CASE_NAME ) end subroutine testcase_finalize subroutine testsuite_summary () !! category: testsuite subroutine !! Summarize FRUIT test results to screen. integer :: i write ( stdout , * ) write ( stdout , * ) write ( stdout , * ) '    Start of FRUIT summary: ' write ( stdout , * ) if ( failed_assert_count > 0 ) then write ( stdout , * ) 'Some tests failed!' else write ( stdout , * ) 'SUCCESSFUL!' end if write ( stdout , * ) if ( message_index > 1 ) then write ( stdout , * ) '  -- Failed assertion messages:' do i = 1 , message_index - 1 write ( stdout , \"(A)\" ) '   ' // trim ( adjustl ( message_array ( i ))) end do write ( stdout , * ) '  -- end of failed assertion messages.' write ( stdout , * ) else write ( stdout , * ) '  No messages ' end if if ( successful_assert_count + failed_assert_count /= 0 ) then ! If testcase not intialized using testcase_intialize() if ( successful_case_count + failed_case_count == 0 ) then failed_case_count = min ( 1 , failed_assert_count ) if ( failed_case_count == 0 ) successful_case_count = 1 endif call testsuite_summary_table (& & successful_assert_count , failed_assert_count , & & successful_case_count , failed_case_count & &) end if write ( stdout , * ) '  -- end of FRUIT summary' end subroutine testsuite_summary subroutine testsuite_summary_table (& & succ_assert , fail_assert , & & succ_case , fail_case & &) !! category: testsuite subroutine !! Print statistics of cases and asserts in default format. integer , intent ( in ) :: succ_assert , fail_assert integer , intent ( in ) :: succ_case , fail_case write ( stdout , * ) 'Total asserts :   ' , succ_assert + fail_assert write ( stdout , * ) 'Successful    :   ' , succ_assert write ( stdout , * ) 'Failed        :   ' , fail_assert write ( stdout , '(\"Successful rate:   \",f6.2,\"%\")' ) real ( succ_assert ) * 10 0.0 / & real ( succ_assert + fail_assert ) write ( stdout , * ) write ( stdout , * ) 'Successful asserts / total asserts : [ ' , & succ_assert , '/' , succ_assert + fail_assert , ' ]' write ( stdout , * ) & & 'Successful cases   / total cases   : [ ' , succ_case , '/' , & succ_case + fail_case , ' ]' end subroutine testsuite_summary_table subroutine add_fail_ ( message ) !! category: testsuite subroutine !! summary: Print message to screen on assert failure and add to count. !! Print message to screen on assert failure and add to count. character ( * ), intent ( in ), optional :: message call failed_assert_action ( 'none' , 'none' , message , if_is = . true .) end subroutine add_fail_ subroutine add_fail_case_named_ ( caseName , message ) !! category: testsuite subroutine !! summary: Print message to screen on assert failure and add to count. !! Print message to screen on assert failure and add to count. character ( * ), intent ( in ) :: caseName character ( * ), intent ( in ) :: message call add_fail_ ( \"[in \" // caseName // \"(fail)]: \" // message ) end subroutine add_fail_case_named_ subroutine is_all_successful ( result ) !! category: testsuite subroutine !! Return true to *result* if any assert has failed till now. logical , intent ( out ) :: result result = ( failed_assert_count . eq . 0 ) end subroutine is_all_successful ! Private, helper routine to wrap lines of success/failed marks subroutine output_mark_ ( chr ) !! Wrap lines of success/failed marks character ( 1 ), intent ( in ) :: chr !  integer, save :: linechar_count = 0 !  Definition of linechar_count is moved to module, !  so that it can be stashed and restored. !$omp critical      (FRUIT_OMP_ADD_OUTPUT_MARK) linechar_count = linechar_count + 1 if ( linechar_count . lt . MAX_MARKS_PER_LINE ) then write ( stdout , \"(A1)\" , ADVANCE = 'NO' ) chr else write ( stdout , \"(A1)\" , ADVANCE = 'YES' ) chr linechar_count = 0 endif !$omp end critical  (FRUIT_OMP_ADD_OUTPUT_MARK) end subroutine output_mark_ subroutine success_mark_ !! category: testsuite subroutine !! Print success mark call output_mark_ ( '.' ) end subroutine success_mark_ subroutine failed_mark_ !! category: testsuite subroutine !! Print failed mark call output_mark_ ( 'F' ) end subroutine failed_mark_ subroutine increase_message_stack_ !! Increase message stack size character ( len = MSG_LENGTH ) :: msg_swap_holder ( current_max ) ! If testsuite_initialize hasn't been called !$omp critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if (. not . allocated ( message_array )) then allocate ( message_array ( MSG_ARRAY_INCREMENT )) end if !$omp end critical (FRUIT_OMP_ALLOCATE_MESSAGE_ARRAY) if ( message_index > MAX_MSG_STACK_SIZE ) then return end if if ( message_index > current_max ) then msg_swap_holder ( 1 : current_max ) = message_array ( 1 : current_max ) deallocate ( message_array ) current_max = current_max + MSG_ARRAY_INCREMENT allocate ( message_array ( current_max )) message_array ( 1 : current_max - MSG_ARRAY_INCREMENT ) & = msg_swap_holder ( 1 : current_max - MSG_ARRAY_INCREMENT ) end if message_array ( message_index ) = msg if ( message_index == MAX_MSG_STACK_SIZE ) then message_array ( message_index ) = \"Max number of messages reached. Further messages suppressed.\" endif message_index = message_index + 1 if ( message_index > MAX_MSG_STACK_SIZE ) then write ( stdout , * ) \"Stop because there are too many error messages to put into stack.\" write ( stdout , * ) \"Try to increase MAX_MSG_STACK_SIZE if you really need so.\" end if end subroutine increase_message_stack_ subroutine get_xml_filename_work ( string ) !! category: testsuite subroutine !! Get filename of XML file. result.xml by default. character ( len =* ), intent ( out ) :: string string = trim ( xml_filename_work ) end subroutine get_xml_filename_work subroutine set_xml_filename_work ( string ) !! category: testsuite subroutine !! Set filename of XML file. result.xml by default. character ( len =* ), intent ( in ) :: string xml_filename_work = trim ( string ) end subroutine set_xml_filename_work function get_last_message () !! category: testsuite subroutine !! Return last message. character ( len = MSG_LENGTH ) :: get_last_message if ( message_index > 1 ) then get_last_message = trim ( adjustl ( message_array ( message_index - 1 ))) else get_last_message = '' end if end function get_last_message subroutine get_message_index ( index ) !! category: testsuite subroutine !! Get number of failed assertion messages. integer , intent ( out ) :: index index = message_index end subroutine get_message_index subroutine get_message_array ( msgs ) !! category: testsuite subroutine !! Get failed asssertion messages to *msgs*. character ( len =* ), intent ( out ) :: msgs (:) integer :: i msgs (:) = \"\" do i = 1 , message_index - 1 msgs ( i ) = trim ( adjustl ( message_array ( i ))) enddo end subroutine get_message_array subroutine get_messages ( msgs ) !! category: testsuite subroutine !! Get failed asssertion messages to *msgs*. character ( len =* ), intent ( out ) :: msgs (:) integer :: i , j msgs (:) = \"\" do i = message_index_from , message_index - 1 j = i - message_index_from + 1 if ( j > ubound ( msgs , 1 )) exit msgs ( j ) = trim ( adjustl ( message_array ( i ))) enddo end subroutine get_messages subroutine get_total_count ( count ) !! category: testsuite subroutine !! Get total number of asserts. integer , intent ( out ) :: count count = successful_assert_count + failed_assert_count end subroutine get_total_count subroutine get_failed_count ( count ) !! category: testsuite subroutine !! Get number of assert failures. integer , intent ( out ) :: count count = failed_assert_count end subroutine get_failed_count subroutine add_success !! category: testsuite subroutine !! summary: Print message to screen on assert success and add to count. !! Print message to screen on assert success and add to count. !$omp critical     (FRUIT_OMP_ADD_SUCCESS) successful_assert_count = successful_assert_count + 1 last_passed = . true . !$omp end critical (FRUIT_OMP_ADD_SUCCESS) if ( if_show_dots ) then call success_mark_ endif end subroutine add_success subroutine failed_assert_action ( expected , got , message , if_is ) !! category: testsuite subroutine !! Print *message* to screen and take necessary actions for assert failure. character ( * ), intent ( in ) :: expected , got character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: if_is !$omp critical     (FRUIT_OMP_ADD_FAIL) if ( present ( if_is )) then call make_error_msg_ ( expected , got , if_is , message ) else call make_error_msg_ ( expected , got , . true ., message ) endif call increase_message_stack_ failed_assert_count = failed_assert_count + 1 last_passed = . false . case_passed = . false . !$omp end critical (FRUIT_OMP_ADD_FAIL) call failed_mark_ end subroutine failed_assert_action subroutine set_case_name ( value ) !! category: testsuite subroutine !! Set name of case to *value*. character ( * ), intent ( in ) :: value case_name = trim ( adjustl ( value )) end subroutine set_case_name subroutine get_case_name ( value ) !! category: testsuite subroutine !! Get name of case to *value*. character ( * ), intent ( out ) :: value value = trim ( adjustl ( case_name )) end subroutine get_case_name subroutine make_error_msg_ ( var1 , var2 , if_is , message ) character ( * ), intent ( in ) :: var1 , var2 logical , intent ( in ) :: if_is character ( * ), intent ( in ), optional :: message msg = '[' // trim ( adjustl ( case_name )) // ']:' if ( if_is ) then msg = trim ( msg ) // ' Expected' else msg = trim ( msg ) // ' Expected Not' endif msg = trim ( msg ) // ' [' // trim ( adjustl ( var1 )) // '],' msg = trim ( msg ) // ' Got' msg = trim ( msg ) // ' [' // trim ( adjustl ( var2 )) // ']' if ( present ( message )) then msg = trim ( msg ) // '; User message: [' // trim ( message ) // ']' endif end subroutine make_error_msg_ function is_last_passed () !! category: testsuite subroutine !! Return true if last assert is successful in case. logical :: is_last_passed is_last_passed = last_passed end function is_last_passed function is_case_passed () !! category: testsuite subroutine !! Return true if all asserts are successful in case. logical :: is_case_passed is_case_passed = case_passed end function is_case_passed subroutine override_stdout ( write_unit , filename ) !! category: testsuite subroutine !! Override stdout to a user-specified file. Terminal by default. integer , intent ( in ) :: write_unit character ( len =* ), intent ( in ) :: filename stdout = write_unit open ( stdout , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_stdout subroutine override_xml_work ( new_unit , filename ) !! category: testsuite subroutine !! Override XML file unit number to a user-specified number. 21 by default. integer , intent ( in ) :: new_unit character ( len =* ), intent ( in ) :: filename xml_work = new_unit xml_filename_work = filename open ( xml_work , file = filename , action = \"write\" , status = \"replace\" ) end subroutine override_xml_work subroutine stash_test_suite !! category: testsuite subroutine !! Stash results of test case for later use. stashed_suite % successful_assert_count = successful_assert_count successful_assert_count = 0 stashed_suite % failed_assert_count = failed_assert_count failed_assert_count = 0 allocate ( stashed_suite % message_array ( current_max )) stashed_suite % message_array ( 1 : message_index ) = & & message_array ( 1 : message_index ) deallocate ( message_array ) allocate ( message_array ( MSG_ARRAY_INCREMENT )) stashed_suite % message_index = message_index message_index = 1 stashed_suite % message_index_from = message_index_from message_index_from = 1 stashed_suite % current_max = current_max current_max = 50 stashed_suite % successful_case_count = successful_case_count successful_case_count = 0 stashed_suite % failed_case_count = failed_case_count failed_case_count = 0 stashed_suite % testCaseIndex = testCaseIndex testCaseIndex = 1 stashed_suite % case_name = case_name case_name = DEFAULT_CASE_NAME stashed_suite % last_passed = last_passed last_passed = . false . stashed_suite % case_passed = case_passed case_passed = DEFAULT_CASE_PASSED stashed_suite % case_time_from = case_time_from case_time_from = 0 stashed_suite % linechar_count = linechar_count linechar_count = 0 stashed_suite % if_show_dots = if_show_dots if_show_dots = . true . end subroutine stash_test_suite subroutine restore_test_suite !! category: testsuite subroutine !! Restore results of test case for use. successful_assert_count = stashed_suite % successful_assert_count failed_assert_count = stashed_suite % failed_assert_count message_index = stashed_suite % message_index message_index_from = stashed_suite % message_index_from current_max = stashed_suite % current_max deallocate ( message_array ) allocate ( message_array ( current_max )) message_array ( 1 : message_index ) = & & stashed_suite % message_array ( 1 : message_index ) deallocate ( stashed_suite % message_array ) successful_case_count = stashed_suite % successful_case_count failed_case_count = stashed_suite % failed_case_count testCaseIndex = stashed_suite % testCaseIndex case_name = stashed_suite % case_name last_passed = stashed_suite % last_passed case_passed = stashed_suite % case_passed case_time_from = stashed_suite % case_time_from linechar_count = stashed_suite % linechar_count if_show_dots = stashed_suite % if_show_dots end subroutine restore_test_suite subroutine end_override_stdout () !! category: testsuite subroutine !! Revert override of stdout to default. Terminal by default. close ( stdout ) stdout = STDOUT_DEFAULT end subroutine end_override_stdout subroutine end_override_xml_work () !! category: testsuite subroutine !! Revert override of XML file unit number to default. 21 by default. close ( xml_work ) xml_work = XML_WORK_DEFAULT xml_filename_work = XML_FN_WORK_DEF end subroutine end_override_xml_work subroutine set_prefix ( str ) !! category: testsuite subroutine !! Set a common prefix for classname. Null by default. character ( len =* ), intent ( in ) :: str character ( len = len_trim ( str )) :: str2 str2 = trim ( adjustl ( str )) if ( len_trim ( str2 ) <= FRUIT_PREFIX_LEN_MAX ) then prefix = str2 else prefix = str2 ( 1 : FRUIT_PREFIX_LEN_MAX ) endif end subroutine set_prefix subroutine get_prefix ( str ) !! category: testsuite subroutine !! Get a common prefix for classname. Null by default. character ( len =* ), intent ( out ) :: str if ( len ( str ) <= len ( prefix )) then str = trim ( prefix ) else str = prefix endif end subroutine get_prefix subroutine get_assert_and_case_count ( fail_assert , suc_assert , fail_case , suc_case ) !! category: testsuite subroutine !! Get statistics of cases and asserts. integer , intent ( out ) :: fail_assert , suc_assert , fail_case , suc_case fail_assert = failed_assert_count suc_assert = successful_assert_count fail_case = failed_case_count suc_case = successful_case_count end subroutine get_assert_and_case_count !-------------------------------------------------------------------------------- ! all assertions !-------------------------------------------------------------------------------- subroutine assert_true ( var1 , message , status ) !! category: testcase subroutine !! Test that *var1* is true. logical , intent ( in ) :: var1 character ( * ), intent ( in ), optional :: message logical , intent ( out ), optional :: status if ( var1 . eqv . . true .) then if (. not . present ( status )) then call add_success else status = . true . endif else if (. not . present ( status )) then call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . true .) else status = . false . endif end if end subroutine assert_true subroutine assert_false ( var1 , message , status ) !! category: testcase subroutine !! Test that *var1* is false. logical , intent ( in ) :: var1 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status if ( var1 . eqv . . false .) then if (. not . present ( status )) then call add_success else status = . true . endif else if (. not . present ( status )) then call failed_assert_action ( to_s (. true .), to_s ( var1 ), message , if_is = . false .) else status = . false . endif endif end subroutine assert_false !====== begin of generated code ====== !------ 0d_logical ------ subroutine assert_eq_logical_ ( var1 , var2 , message , status ) logical , intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status if ( var1 . neqv . var2 ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_logical_ !------ 1d_logical ------ subroutine assert_eq_1d_logical_ ( var1 , var2 , message , status ) logical , intent ( in ), dimension (:) :: var1 , var2 integer :: n integer , dimension ( 1 ) :: indx character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 )) :: logical_array n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), & & '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif logical_array = ( var1 . eqv . var2 ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ))), & & to_s ( var2 ( indx ( 1 ))), & & '1d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_1d_logical_ !------ 2d_logical ------ subroutine assert_eq_2d_logical_ ( var1 , var2 , message , status ) logical , intent ( in ), dimension (:, :) :: var1 , var2 integer :: n , m integer , dimension ( 2 ) :: indx character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 ), size ( var1 , 2 )) :: logical_array n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif logical_array = ( var1 . eqv . var2 ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ), indx ( 2 ))), & & to_s ( var2 ( indx ( 1 ), indx ( 2 ))), & & '2d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_2d_logical_ !------ 0d_string ------ subroutine assert_eq_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status if ( adjustl ( var1 ) /= adjustl ( var2 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_string_ !------ 1d_string ------ subroutine assert_eq_1d_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ), dimension (:) :: var1 , var2 integer :: i , n character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), & & '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif do i = 1 , n if ( adjustl ( var1 ( i )) /= adjustl ( var2 ( i ))) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i )), & & to_s ( var2 ( i )), & & '1d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_1d_string_ !------ 2d_string ------ subroutine assert_eq_2d_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ), dimension (:, :) :: var1 , var2 integer :: i , j , n , m character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif do j = 1 , m do i = 1 , n if ( adjustl ( var1 ( i , j )) /= adjustl ( var2 ( i , j ))) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_2d_string_ !------ 0d_int ------ subroutine assert_eq_int_ ( var1 , var2 , message , status ) integer , intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status if ( var1 /= var2 ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_int_ !------ 1d_int ------ subroutine assert_eq_1d_int_ ( var1 , var2 , message , status ) integer , intent ( in ), dimension (:) :: var1 , var2 integer :: n integer , dimension ( 1 ) :: indx character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 )) :: logical_array n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), & & '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif logical_array = ( var1 == var2 ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ))), & & to_s ( var2 ( indx ( 1 ))), & & '1d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_1d_int_ !------ 2d_int ------ subroutine assert_eq_2d_int_ ( var1 , var2 , message , status ) integer , intent ( in ), dimension (:, :) :: var1 , var2 integer :: n , m integer , dimension ( 2 ) :: indx character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 ), size ( var1 , 2 )) :: logical_array n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif logical_array = ( var1 == var2 ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ), indx ( 2 ))), & & to_s ( var2 ( indx ( 1 ), indx ( 2 ))), & & '2d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_2d_int_ !------ 0d_real ------ subroutine assert_eq_real_ ( var1 , var2 , delta , message , status ) real , intent ( in ) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real :: tol tol = eps if ( present ( delta )) tol = delta if ( abs ( var1 - var2 ) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_real_ !------ 1d_real ------ subroutine assert_eq_1d_real_ ( var1 , var2 , delta , message , status ) real , intent ( in ), dimension (:) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status integer :: n integer , dimension ( 1 ) :: indx logical , dimension ( size ( var1 , 1 )) :: logical_array real :: tol n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), & & '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps if ( present ( delta )) tol = delta logical_array = ( abs ( var1 - var2 ) <= tol ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ))), & & to_s ( var2 ( indx ( 1 ))), & & '1d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_1d_real_ !------ 2d_real ------ subroutine assert_eq_2d_real_ ( var1 , var2 , delta , message , status ) integer :: n , m integer , dimension ( 2 ) :: indx real , intent ( in ), dimension (:, :) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real :: tol logical , dimension ( size ( var1 , 1 ), size ( var1 , 2 )) :: logical_array n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps if ( present ( delta )) tol = delta logical_array = ( abs ( var1 - var2 ) <= tol ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ), indx ( 2 ))), & & to_s ( var2 ( indx ( 1 ), indx ( 2 ))), & & '2d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_2d_real_ !------ 0d_double ------ subroutine assert_eq_double_ ( var1 , var2 , delta , message , status ) real ( dp ), intent ( in ) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real ( dp ) :: tol tol = eps_dp if ( present ( delta )) tol = delta if ( abs ( var1 - var2 ) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_double_ !------ 1d_double ------ subroutine assert_eq_1d_double_ ( var1 , var2 , delta , message , status ) integer :: n integer , dimension ( 1 ) :: indx real ( dp ), intent ( in ), dimension (:) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 )) :: logical_array real ( dp ) :: tol n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), & & '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps_dp if ( present ( delta )) tol = delta logical_array = ( abs ( var1 - var2 ) <= tol ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ))), & & to_s ( var2 ( indx ( 1 ))), & & '1d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_1d_double_ !------ 2d_double ------ subroutine assert_eq_2d_double_ ( var1 , var2 , delta , message , status ) integer :: n , m integer , dimension ( 2 ) :: indx real ( dp ), intent ( in ), dimension (:, :) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical , dimension ( size ( var1 , 1 ), size ( var1 , 2 )) :: logical_array real ( dp ) :: tol n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps_dp if ( present ( delta )) tol = delta logical_array = ( abs ( var1 - var2 ) <= tol ) if ( all ( logical_array )) then if (. not . present ( status )) then call add_success else status = . true . endif else indx = findfalse ( logical_array ) if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( indx ( 1 ), indx ( 2 ))), & & to_s ( var2 ( indx ( 1 ), indx ( 2 ))), & & '2d array has difference, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_eq_2d_double_ !------ 0d_complex_real ------ subroutine assert_eq_complex_real_ ( var1 , var2 , delta , message , status ) complex , intent ( in ) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real :: tol tol = eps if ( present ( delta )) tol = delta if ( abs ( real ( var1 - var2 )) > tol . or . abs ( aimag ( var1 - var2 )) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_complex_real_ !------ 1d_complex_real ------ subroutine assert_eq_1d_complex_real_ ( var1 , var2 , delta , message , status ) integer :: i , n complex , intent ( in ), dimension (:) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real :: tol n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps if ( present ( delta )) tol = delta do i = 1 , n if ( abs ( real ( var1 ( i ) - var2 ( i ))) > tol . or . & abs ( aimag ( var1 ( i ) - var2 ( i ))) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_1d_complex_real_ !------ 2d_complex_real ------ subroutine assert_eq_2d_complex_real_ ( var1 , var2 , delta , message , status ) integer :: i , j , n , m complex , intent ( in ), dimension (:, :) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real :: tol n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps if ( present ( delta )) tol = delta do j = 1 , m do i = 1 , n if ( abs ( real ( var1 ( i , j ) - var2 ( i , j ))) > tol . or . & abs ( aimag ( var1 ( i , j ) - var2 ( i , j ))) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_2d_complex_real_ !------ 0d_complex_double ------ subroutine assert_eq_complex_double_ ( var1 , var2 , delta , message , status ) complex ( dp ), intent ( in ) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real ( dp ) :: tol tol = eps_dp if ( present ( delta )) tol = delta if ( abs ( real ( var1 - var2 , kind = dp )) > tol . or . & abs ( dimag ( var1 - var2 )) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . true .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_complex_double_ !------ 1d_complex_double ------ subroutine assert_eq_1d_complex_double_ ( var1 , var2 , delta , message , status ) integer :: i , n complex ( dp ), intent ( in ), dimension (:) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real ( dp ) :: tol n = size ( var1 , 1 ) if ( n . ne . size ( var2 , 1 )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ), & & to_s ( size ( var2 , 1 )), '1d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps_dp if ( present ( delta )) tol = delta do i = 1 , n if ( abs ( real ( var1 ( i ) - var2 ( i ), kind = dp )) > tol . or . & abs ( dimag ( var1 ( i ) - var2 ( i ))) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i )), & & to_s ( var2 ( i )), '1d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_1d_complex_double_ !------ 2d_complex_double ------ subroutine assert_eq_2d_complex_double_ ( var1 , var2 , delta , message , status ) integer :: i , j , n , m complex ( dp ), intent ( in ), dimension (:, :) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status real ( dp ) :: tol n = size ( var1 , 1 ) m = size ( var1 , 2 ) if (( size ( var2 , 1 ) . ne . n ) . and . ( size ( var2 , 2 ) . ne . m )) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( n ) // ' x ' // to_s ( m ), & & to_s ( size ( var2 , 1 )) // ' x ' // to_s ( size ( var2 , 1 )), & & '2d arrays have different sizes, ' // message , if_is = . true .) else status = . false . endif return endif tol = eps_dp if ( present ( delta )) tol = delta do j = 1 , m do i = 1 , n if ( abs ( real ( var1 ( i , j ) - var2 ( i , j ), kind = dp )) > tol . or . & abs ( dimag ( var1 ( i , j ) - var2 ( i , j ))) > tol ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( i , j )), & & to_s ( var2 ( i , j )), '2d array has difference, ' // message , if_is = . true .) else status = . false . endif return endif enddo enddo if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_eq_2d_complex_double_ !------ 0d_logical ------ subroutine assert_not_eq_logical_ ( var1 , var2 , message , status ) logical , intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_logical_ !------ 1d_logical ------ subroutine assert_not_eq_1d_logical_ ( var1 , var2 , message , status ) logical , intent ( in ), dimension (:) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_logical_ !------ 2d_logical ------ subroutine assert_not_eq_2d_logical_ ( var1 , var2 , message , status ) logical , intent ( in ), dimension (:, :) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_logical_ !------ 0d_string ------ subroutine assert_not_eq_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_string_ !------ 1d_string ------ subroutine assert_not_eq_1d_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ), dimension (:) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_string_ !------ 2d_string ------ subroutine assert_not_eq_2d_string_ ( var1 , var2 , message , status ) character ( len =* ), intent ( in ), dimension (:, :) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_string_ !------ 0d_int ------ subroutine assert_not_eq_int_ ( var1 , var2 , message , status ) integer , intent ( in ) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_int_ !------ 1d_int ------ subroutine assert_not_eq_1d_int_ ( var1 , var2 , message , status ) integer , intent ( in ), dimension (:) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_int_ !------ 2d_int ------ subroutine assert_not_eq_2d_int_ ( var1 , var2 , message , status ) integer , intent ( in ), dimension (:, :) :: var1 , var2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_equal ( var1 , var2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_int_ !------ 0d_real ------ subroutine assert_not_eq_real_ ( var1 , var2 , delta , message , status ) real , intent ( in ) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_real_ !------ 1d_real ------ subroutine assert_not_eq_1d_real_ ( var1 , var2 , delta , message , status ) real , intent ( in ), dimension (:) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_real_ !------ 2d_real ------ subroutine assert_not_eq_2d_real_ ( var1 , var2 , delta , message , status ) real , intent ( in ), dimension (:, :) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_real_ !------ 0d_double ------ subroutine assert_not_eq_double_ ( var1 , var2 , delta , message , status ) real ( dp ), intent ( in ) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_double_ !------ 1d_double ------ subroutine assert_not_eq_1d_double_ ( var1 , var2 , delta , message , status ) real ( dp ), intent ( in ), dimension (:) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_double_ !------ 2d_double ------ subroutine assert_not_eq_2d_double_ ( var1 , var2 , delta , message , status ) real ( dp ), intent ( in ), dimension (:, :) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_double_ !------ 0d_complex_real_ ------ subroutine assert_not_eq_complex_real_ ( var1 , var2 , delta , message , status ) complex , intent ( in ) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_complex_real_ !------ 1d_complex_real_------ subroutine assert_not_eq_1d_complex_real_ ( var1 , var2 , delta , message , status ) complex , intent ( in ), dimension (:) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_complex_real_ !------ 2d_complex_real_------ subroutine assert_not_eq_2d_complex_real_ ( var1 , var2 , delta , message , status ) complex , intent ( in ), dimension (:, :) :: var1 , var2 real , intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_complex_real_ !------ 0d_complex_double_ ------ subroutine assert_not_eq_complex_double_ ( var1 , var2 , delta , message , status ) complex ( dp ), intent ( in ) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ), & & to_s ( var2 ), message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_complex_double_ !------ 1d_complex_double_------ subroutine assert_not_eq_1d_complex_double_ ( var1 , var2 , delta , message , status ) complex ( dp ), intent ( in ), dimension (:) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 )), & & to_s ( var2 ( 1 )), '1d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_1d_complex_double_ !------ 2d_complex_double_------ subroutine assert_not_eq_2d_complex_double_ ( var1 , var2 , delta , message , status ) complex ( dp ), intent ( in ), dimension (:, :) :: var1 , var2 real ( dp ), intent ( in ), optional :: delta character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal if ( present ( delta )) then call assert_equal ( var1 , var2 , delta , status = is_equal ) else call assert_equal ( var1 , var2 , status = is_equal ) endif if ( is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & to_s ( var1 ( 1 , 1 )), & & to_s ( var2 ( 1 , 1 )), '2d array has no difference, ' // message , if_is = . false .) else status = . false . endif return endif if (. not . present ( status )) then call add_success else status = . true . endif end subroutine assert_not_eq_2d_complex_double_ subroutine assert_identical ( filename1 , filename2 , message , status ) !! category: testcase subroutine !! Compare two files and return true if identical character ( len =* ), intent ( in ) :: filename1 , filename2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status integer :: size1 , size2 , iostatVal character (:), allocatable :: contents1 , contents2 logical :: file_exists , is_equal ! Check file existence filename1 inquire ( file = filename1 , exist = file_exists ) if (. not . file_exists ) then if (. not . present ( status )) then call failed_assert_action ( & & filename1 , 'none' , & & 'File does not exist, ' // message , if_is = . false .) else status = . false . endif return endif ! Check file existence filename2 inquire ( file = filename2 , exist = file_exists ) if (. not . file_exists ) then if (. not . present ( status )) then call failed_assert_action ( & & filename2 , 'none' , & & 'File does not exist, ' // message , if_is = . true .) else status = . false . endif return endif open ( unit = 10 , file = filename1 , action = \"read\" , & & form = \"unformatted\" , access = \"stream\" , iostat = iostatVal ) if ( iostatVal . ne . 0 ) then if (. not . present ( status )) then call failed_assert_action ( & & filename1 , 'none' , & 'File appears empty or does not exist, ' // message , if_is = . true .) else status = . false . endif return endif inquire ( unit = 10 , size = size1 ) open ( unit = 11 , file = filename2 , action = \"read\" , & & form = \"unformatted\" , access = \"stream\" , iostat = iostatVal ) if ( iostatVal . ne . 0 ) then if (. not . present ( status )) then call failed_assert_action ( & & filename2 , 'none' , & 'File appears empty or does not exist, ' // message , if_is = . true .) else status = . false . endif return endif inquire ( unit = 11 , size = size2 ) ! Check sizes call assert_equal ( size1 , size2 , status = is_equal ) if (. not . is_equal ) then if (. not . present ( status )) then call failed_assert_action ( & & filename1 , filename2 , & & 'Files do not match, ' // message , if_is = . true .) else status = . false . endif close ( 10 ) close ( 11 ) return else allocate ( character ( size1 ) :: contents1 ) read ( 10 ) contents1 close ( 10 ) allocate ( character ( size2 ) :: contents2 ) read ( 11 ) contents2 close ( 11 ) endif ! Check contents call assert_equal ( contents1 , contents2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call add_success () else status = . true . endif else if (. not . present ( status )) then call failed_assert_action ( & & filename1 , filename2 , & & 'Files do not match, ' // message , if_is = . true .) else status = . false . endif endif end subroutine assert_identical subroutine assert_not_identical ( filename1 , filename2 , message , status ) !! category: testcase subroutine !! Compare two files and return true if not identical character ( len =* ), intent ( in ) :: filename1 , filename2 character ( len =* ), intent ( in ), optional :: message logical , intent ( out ), optional :: status logical :: is_equal call assert_identical ( filename1 , filename2 , status = is_equal ) if ( is_equal ) then if (. not . present ( status )) then call add_success () else status = . true . endif else if (. not . present ( status )) then call failed_assert_action ( & & filename1 , filename2 , & & 'Files do match, ' // message , if_is = . false .) else status = . false . endif endif end subroutine assert_not_identical !====== end of generated code ====== function to_s_int_ ( value ) !! category: fruit_util !! Convert integer to string character ( len = 500 ) :: to_s_int_ integer , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_int_ = adjustl ( trim ( result )) end function to_s_int_ function to_s_real_ ( value ) !! Convert real to string character ( len = 500 ) :: to_s_real_ real , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_real_ = adjustl ( trim ( result )) end function to_s_real_ function to_s_double_ ( value ) !! Convert double to string character ( len = 500 ) :: to_s_double_ real ( dp ), intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_ = adjustl ( trim ( result )) end function to_s_double_ function to_s_complex_ ( value ) !! Convert complex to string character ( len = 500 ) :: to_s_complex_ complex , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_complex_ = adjustl ( trim ( result )) end function to_s_complex_ function to_s_double_complex_ ( value ) !! Convert complex double to string character ( len = 500 ) :: to_s_double_complex_ complex ( dp ), intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_double_complex_ = adjustl ( trim ( result )) end function to_s_double_complex_ function to_s_logical_ ( value ) !! Convert logical to string character ( len = 500 ) :: to_s_logical_ logical , intent ( in ) :: value character ( len = 500 ) :: result write ( result , * ) value to_s_logical_ = adjustl ( trim ( result )) end function to_s_logical_ function to_s_string_ ( value ) !! Convert string to string character ( len = 500 ) :: to_s_string_ character ( len =* ), intent ( in ) :: value to_s_string_ = value end function to_s_string_ function findfalse_1d_ ( logical_array ) !! Returns first occurence of .false. in logical_array logical , intent ( in ), dimension (:) :: logical_array integer , dimension ( 1 ) :: findfalse_1d_ integer :: i do i = 1 , size ( logical_array , 1 ) if ( logical_array ( i ) . eqv . . false .) then findfalse_1d_ = ( / i / ) return endif enddo findfalse_1d_ = ( / 0 / ) end function findfalse_1d_ function findfalse_2d_ ( logical_array ) !! Returns first occurence of .false. in logical_array logical , intent ( in ), dimension (:, :) :: logical_array integer , dimension ( 2 ) :: findfalse_2d_ integer :: i , j do j = 1 , size ( logical_array , 2 ) do i = 1 , size ( logical_array , 1 ) if ( logical_array ( i , j ) . eqv . . false .) then findfalse_2d_ = ( / i , j / ) return endif enddo enddo findfalse_2d_ = ( / 0 , 0 / ) end function findfalse_2d_ end module naturalfruit","tags":"","loc":"sourcefile/naturalfruit.f90.html"},{"title":"fruit_mpi.f90 â€“ naturalFRUIT","text":"Contents Modules fruit_mpi Source Code fruit_mpi.f90 Source Code module fruit_mpi !! display: none !! !! Documentation under construction use naturalfruit use mpi implicit none private integer , parameter :: XML_OPEN = 20 integer , parameter :: XML_WORK = 21 character ( len =* ), parameter :: xml_filename = \"result.xml\" integer , parameter :: NUMBER_LENGTH = 10 integer , parameter :: FN_LENGTH = 50 public :: fruit_initialize_mpi_xml interface fruit_initialize_mpi_xml module procedure fruit_initialize_mpi_xml_ end interface public :: fruit_finalize_mpi interface fruit_finalize_mpi module procedure fruit_finalize_mpi_ end interface public :: fruit_summary_mpi interface fruit_summary_mpi module procedure fruit_summary_mpi_ end interface public :: fruit_summary_mpi_xml interface fruit_summary_mpi_xml module procedure fruit_summary_mpi_xml_ end interface contains subroutine fruit_initialize_mpi_xml_ ( rank ) integer , intent ( in ) :: rank character ( len = FN_LENGTH ) :: xml_filename_work write ( xml_filename_work , '(\"result_tmp_\", i5.5, \".xml\")' ) rank call set_xml_filename_work ( xml_filename_work ) call init_fruit_xml ( rank ) end subroutine fruit_initialize_mpi_xml_ subroutine fruit_finalize_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank if ( size < 0 ) print * , \"size negative\" if ( rank < 0 ) print * , \"rank negative\" call fruit_finalize end subroutine fruit_finalize_mpi_ subroutine fruit_summary_mpi_ ( size , rank ) integer , intent ( in ) :: size , rank integer :: fail_assert_sum integer :: succ_assert_sum integer :: fail_case_sum integer :: succ_case_sum integer :: fail_assert integer :: succ_assert integer :: fail_case integer :: succ_case integer :: message_index integer :: num_msgs integer :: num_msgs_sum integer , allocatable :: num_msgs_rank (:) integer :: ierr integer :: i integer :: imsg integer :: status ( MPI_STATUS_SIZE ) integer , parameter :: MSG_LENGTH_HERE = 256 character ( len = MSG_LENGTH_HERE ), allocatable :: msgs (:) character ( len = MSG_LENGTH_HERE ), allocatable :: msgs_all (:) call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call get_message_index ( message_index ) num_msgs = message_index - 1 allocate ( msgs ( num_msgs )) call get_message_array ( msgs ) allocate ( num_msgs_rank ( size )) call MPI_Allgather (& & num_msgs , 1 , MPI_INTEGER , & & num_msgs_rank , 1 , MPI_INTEGER , MPI_COMM_WORLD , ierr ) num_msgs_sum = sum ( num_msgs_rank (:)) allocate ( msgs_all ( num_msgs_sum )) ! array msgs_all: ! ! | msgs(:) of rank 0  | msgs(:) of rank 1   | msgs(:) of rank 2  | ! |                    |                     |                    | ! | num_msgs_rank(1)   |  num_msgs_rank(2)   | num_msgs_rank(3)   | ! |                    |                     |                    | ! |                    |                     |                    | !                       A                     A                  A !                       |                     |                  | !              sum(num_msgs_rank(1:1))+1      |             num_msgs_sum !                                    sum(num_msgs_rank(1:2))+1 if ( rank == 0 ) then msgs_all ( 1 : num_msgs ) = msgs ( 1 : num_msgs ) do i = 1 , size - 1 imsg = sum ( num_msgs_rank ( 1 : i )) + 1 call MPI_RECV (& & msgs_all ( imsg ), & & num_msgs_rank ( i + 1 ) * MSG_LENGTH_HERE , MPI_CHARACTER , & & i , 7 , MPI_COMM_WORLD , status , ierr ) enddo else call MPI_Send (& & msgs , & & num_msgs * MSG_LENGTH_HERE , MPI_CHARACTER , & & 0 , 7 , MPI_COMM_WORLD , ierr ) endif call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) if ( rank == 0 ) then write ( * , * ) write ( * , * ) write ( * , * ) '    Start of FRUIT summary: ' write ( * , * ) if ( fail_assert_sum > 0 ) then write ( * , * ) 'Some tests failed!' else write ( * , * ) 'SUCCESSFUL!' end if write ( * , * ) write ( * , * ) '  -- Failed assertion messages:' do i = 1 , num_msgs_sum write ( * , \"(A)\" ) '   ' // trim ( msgs_all ( i )) end do write ( * , * ) '  -- end of failed assertion messages.' write ( * , * ) if ( succ_assert_sum + fail_assert_sum /= 0 ) then call fruit_summary_table (& & succ_assert_sum , fail_assert_sum , & & succ_case_sum , fail_case_sum & &) endif write ( * , * ) '  -- end of FRUIT summary' endif end subroutine fruit_summary_mpi_ subroutine fruit_summary_mpi_xml_ ( size , rank ) integer , intent ( in ) :: size , rank character ( len = 1000 ) :: whole_line character ( len = 100 ) :: full_count character ( len = 100 ) :: fail_count character ( len = FN_LENGTH ) :: xml_filename_work character ( len = FN_LENGTH ), allocatable :: xml_filename_work_all (:) integer :: fail_assert , succ_assert , fail_case , succ_case integer :: fail_assert_sum , succ_assert_sum , fail_case_sum , succ_case_sum integer :: i integer :: status ( MPI_STATUS_SIZE ) integer :: ierr call get_xml_filename_work ( xml_filename_work ) allocate ( xml_filename_work_all ( size )) if ( rank /= 0 ) then call MPI_Send ( xml_filename_work , & & FN_LENGTH , MPI_CHARACTER , 0 , 8 , MPI_COMM_WORLD , ierr ) endif if ( rank == 0 ) then xml_filename_work_all ( 1 ) = xml_filename_work do i = 1 + 1 , size call MPI_RECV ( xml_filename_work_all ( i ), & & FN_LENGTH , MPI_CHARACTER , i - 1 , 8 , MPI_COMM_WORLD , status , ierr ) enddo endif call get_assert_and_case_count (& & fail_assert , succ_assert , & & fail_case , succ_case ) call MPI_REDUCE (& & fail_assert , & & fail_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_assert , & & succ_assert_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & fail_case , & & fail_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) call MPI_REDUCE (& & succ_case , & & succ_case_sum , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) full_count = int_to_str ( succ_case_sum + fail_case_sum ) fail_count = int_to_str ( fail_case_sum ) if ( rank == 0 ) then open ( XML_OPEN , file = xml_filename , action = \"write\" , status = \"replace\" ) write ( XML_OPEN , '(\"<?xml version=\"\"1.0\"\" encoding=\"\"UTF-8\"\"?>\")' ) write ( XML_OPEN , '(\"<testsuites>\")' ) write ( XML_OPEN , '(\"  <testsuite errors=\"\"0\"\" \")' , advance = \"no\" ) write ( XML_OPEN , '(\"tests=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( full_count ) write ( XML_OPEN , '(\"failures=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & trim ( fail_count ) write ( XML_OPEN , '(\"name=\"\"\", a, \"\"\" \")' , advance = \"no\" ) & & \"name of test suite\" write ( XML_OPEN , '(\"id=\"\"1\"\">\")' ) do i = 1 , size open ( XML_WORK , FILE = xml_filename_work_all ( i )) do read ( XML_WORK , '(a)' , end = 999 ) whole_line write ( XML_OPEN , '(a)' ) trim ( whole_line ) enddo 999 continue close ( XML_WORK ) enddo write ( XML_OPEN , '(\"  </testsuite>\")' ) write ( XML_OPEN , '(\"</testsuites>\")' ) close ( XML_OPEN ) endif if ( size < 0 ) print * , \"size < 0\" end subroutine fruit_summary_mpi_xml_ function int_to_str ( i ) integer , intent ( in ) :: i character ( LEN = NUMBER_LENGTH ) :: int_to_str write ( int_to_str , '(i10)' ) i int_to_str = adjustl ( int_to_str ) end function int_to_str end module fruit_mpi","tags":"","loc":"sourcefile/fruit_mpi.f90.html"},{"title":"fruit_if_case_failed â€“ naturalFRUIT","text":"public function fruit_if_case_failed() Return TRUE if any assert in current case has failed. Arguments None Return Value logical Contents None","tags":"testsuite subroutine","loc":"proc/fruit_if_case_failed.html"},{"title":"get_last_message â€“ naturalFRUIT","text":"public function get_last_message() Return last message. Arguments None Return Value character(len=MSG_LENGTH) Contents None","tags":"testsuite subroutine","loc":"proc/get_last_message.html"},{"title":"is_last_passed â€“ naturalFRUIT","text":"public function is_last_passed() Return true if last assert is successful in case. Arguments None Return Value logical Contents None","tags":"testsuite subroutine","loc":"proc/is_last_passed.html"},{"title":"is_case_passed â€“ naturalFRUIT","text":"public function is_case_passed() Return true if all asserts are successful in case. Arguments None Return Value logical Contents None","tags":"testsuite subroutine","loc":"proc/is_case_passed.html"},{"title":"testsuite_initialize â€“ naturalFRUIT","text":"public subroutine testsuite_initialize(rank) Initialize FRUIT driver environment. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_initialize.html"},{"title":"testsuite_finalize â€“ naturalFRUIT","text":"public subroutine testsuite_finalize(exit_code) Finalize FRUIT driver environment and optionally\n  return no. of failed cases as an exit_code .\n  for exception handling Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: exit_code Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_finalize.html"},{"title":"testsuite_initialize_xml â€“ naturalFRUIT","text":"public subroutine testsuite_initialize_xml(rank) Initialize FRUIT driver environment for output to XML file Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_initialize_xml.html"},{"title":"case_passed_xml â€“ naturalFRUIT","text":"public subroutine case_passed_xml(tc_name, classname) Write to XML file a passed case. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname Contents None","tags":"testsuite subroutine","loc":"proc/case_passed_xml.html"},{"title":"case_failed_xml â€“ naturalFRUIT","text":"public subroutine case_failed_xml(tc_name, classname) Write to XML file a passed case. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname Contents None","tags":"testsuite subroutine","loc":"proc/case_failed_xml.html"},{"title":"testsuite_summary_xml â€“ naturalFRUIT","text":"public subroutine testsuite_summary_xml() Summarize FRUIT test results in XML format to result.xml file. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_summary_xml.html"},{"title":"fruit_show_dots â€“ naturalFRUIT","text":"public subroutine fruit_show_dots() Show dots signifying test success on screen. Visible by default. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/fruit_show_dots.html"},{"title":"fruit_hide_dots â€“ naturalFRUIT","text":"public subroutine fruit_hide_dots() Hide dots signifying test success on screen. Visible by default. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/fruit_hide_dots.html"},{"title":"testcase_initialize â€“ naturalFRUIT","text":"public subroutine testcase_initialize(tc_name) Initialize a test case. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: tc_name Contents None","tags":"testcase subroutine","loc":"proc/testcase_initialize.html"},{"title":"testcase_finalize â€“ naturalFRUIT","text":"public subroutine testcase_finalize(exit_code) Finalize a testcase and optionally \n return no. of failed asserts as an exit_code .\n Initialize a test case. Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: exit_code Contents None","tags":"testcase subroutine","loc":"proc/testcase_finalize.html"},{"title":"testsuite_summary â€“ naturalFRUIT","text":"public subroutine testsuite_summary() Summarize FRUIT test results to screen. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_summary.html"},{"title":"testsuite_summary_table â€“ naturalFRUIT","text":"public subroutine testsuite_summary_table(succ_assert, fail_assert, succ_case, fail_case) Print statistics of cases and asserts in default format. Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case Contents None","tags":"testsuite subroutine","loc":"proc/testsuite_summary_table.html"},{"title":"is_all_successful â€“ naturalFRUIT","text":"public subroutine is_all_successful(result) Return true to result if any assert has failed till now. Arguments Type Intent Optional Attributes Name logical, intent(out) :: result Contents None","tags":"testsuite subroutine","loc":"proc/is_all_successful.html"},{"title":"get_xml_filename_work â€“ naturalFRUIT","text":"public subroutine get_xml_filename_work(string) Get filename of XML file. result.xml by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string Contents None","tags":"testsuite subroutine","loc":"proc/get_xml_filename_work.html"},{"title":"set_xml_filename_work â€“ naturalFRUIT","text":"public subroutine set_xml_filename_work(string) Set filename of XML file. result.xml by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Contents None","tags":"testsuite subroutine","loc":"proc/set_xml_filename_work.html"},{"title":"get_message_index â€“ naturalFRUIT","text":"public subroutine get_message_index(index) Get number of failed assertion messages. Arguments Type Intent Optional Attributes Name integer, intent(out) :: index Contents None","tags":"testsuite subroutine","loc":"proc/get_message_index.html"},{"title":"get_message_array â€“ naturalFRUIT","text":"public subroutine get_message_array(msgs) Get failed asssertion messages to msgs . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) Contents None","tags":"testsuite subroutine","loc":"proc/get_message_array.html"},{"title":"get_messages â€“ naturalFRUIT","text":"public subroutine get_messages(msgs) Get failed asssertion messages to msgs . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) Contents None","tags":"testsuite subroutine","loc":"proc/get_messages.html"},{"title":"get_total_count â€“ naturalFRUIT","text":"public subroutine get_total_count(count) Get total number of asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Contents None","tags":"testsuite subroutine","loc":"proc/get_total_count.html"},{"title":"get_failed_count â€“ naturalFRUIT","text":"public subroutine get_failed_count(count) Get number of assert failures. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count Contents None","tags":"testsuite subroutine","loc":"proc/get_failed_count.html"},{"title":"add_success â€“ naturalFRUIT","text":"public subroutine add_success() Print message to screen on assert success and add to count. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/add_success.html"},{"title":"failed_assert_action â€“ naturalFRUIT","text":"public subroutine failed_assert_action(expected, got, message, if_is) Print message to screen and take necessary actions for assert failure. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is Contents None","tags":"testsuite subroutine","loc":"proc/failed_assert_action.html"},{"title":"set_case_name â€“ naturalFRUIT","text":"public subroutine set_case_name(value) Set name of case to value . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Contents None","tags":"testsuite subroutine","loc":"proc/set_case_name.html"},{"title":"get_case_name â€“ naturalFRUIT","text":"public subroutine get_case_name(value) Get name of case to value . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value Contents None","tags":"testsuite subroutine","loc":"proc/get_case_name.html"},{"title":"override_stdout â€“ naturalFRUIT","text":"public subroutine override_stdout(write_unit, filename) Override stdout to a user-specified file. Terminal by default. Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename Contents None","tags":"testsuite subroutine","loc":"proc/override_stdout.html"},{"title":"override_xml_work â€“ naturalFRUIT","text":"public subroutine override_xml_work(new_unit, filename) Override XML file unit number to a user-specified number. 21 by default. Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename Contents None","tags":"testsuite subroutine","loc":"proc/override_xml_work.html"},{"title":"stash_test_suite â€“ naturalFRUIT","text":"public subroutine stash_test_suite() Stash results of test case for later use. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/stash_test_suite.html"},{"title":"restore_test_suite â€“ naturalFRUIT","text":"public subroutine restore_test_suite() Restore results of test case for use. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/restore_test_suite.html"},{"title":"end_override_stdout â€“ naturalFRUIT","text":"public subroutine end_override_stdout() Revert override of stdout to default. Terminal by default. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/end_override_stdout.html"},{"title":"end_override_xml_work â€“ naturalFRUIT","text":"public subroutine end_override_xml_work() Revert override of XML file unit number to default. 21 by default. Arguments None Contents None","tags":"testsuite subroutine","loc":"proc/end_override_xml_work.html"},{"title":"set_prefix â€“ naturalFRUIT","text":"public subroutine set_prefix(str) Set a common prefix for classname. Null by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Contents None","tags":"testsuite subroutine","loc":"proc/set_prefix.html"},{"title":"get_prefix â€“ naturalFRUIT","text":"public subroutine get_prefix(str) Get a common prefix for classname. Null by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str Contents None","tags":"testsuite subroutine","loc":"proc/get_prefix.html"},{"title":"get_assert_and_case_count â€“ naturalFRUIT","text":"public subroutine get_assert_and_case_count(fail_assert, suc_assert, fail_case, suc_case) Get statistics of cases and asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case Contents None","tags":"testsuite subroutine","loc":"proc/get_assert_and_case_count.html"},{"title":"assert_true â€“ naturalFRUIT","text":"public subroutine assert_true(var1, message, status) Test that var1 is true. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status Contents None","tags":"testcase subroutine","loc":"proc/assert_true.html"},{"title":"assert_false â€“ naturalFRUIT","text":"public subroutine assert_false(var1, message, status) Test that var1 is false. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status Contents None","tags":"testcase subroutine","loc":"proc/assert_false.html"},{"title":"assert_identical â€“ naturalFRUIT","text":"public subroutine assert_identical(filename1, filename2, message, status) Compare two files and return true if identical Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename1 character(len=*), intent(in) :: filename2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status Contents None","tags":"testcase subroutine","loc":"proc/assert_identical.html"},{"title":"assert_not_identical â€“ naturalFRUIT","text":"public subroutine assert_not_identical(filename1, filename2, message, status) Compare two files and return true if not identical Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename1 character(len=*), intent(in) :: filename2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status Contents None","tags":"testcase subroutine","loc":"proc/assert_not_identical.html"},{"title":"assert_equal â€“ naturalFRUIT","text":"public interface assert_equal Test that var1 and var2 are equal.\n If the values do not compare equal, the test will fail. assert_equal invokes one of the following subroutines according\n to the number or type of arguments. Contents Module Procedures assert_eq_logical_ assert_eq_1d_logical_ assert_eq_2d_logical_ assert_eq_string_ assert_eq_1d_string_ assert_eq_2d_string_ assert_eq_int_ assert_eq_1d_int_ assert_eq_2d_int_ assert_eq_real_ assert_eq_1d_real_ assert_eq_2d_real_ assert_eq_double_ assert_eq_1d_double_ assert_eq_2d_double_ assert_eq_complex_real_ assert_eq_1d_complex_real_ assert_eq_2d_complex_real_ assert_eq_complex_double_ assert_eq_1d_complex_double_ assert_eq_2d_complex_double_ Module Procedures private subroutine assert_eq_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: var1 logical, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:, :) :: var1 logical, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: var1 character(len=*), intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:, :) :: var1 character(len=*), intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: var1 integer, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:, :) :: var1 integer, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: var1 real, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: var1 real, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: var1 real(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: var1 real(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: var1 real(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in) :: var1 complex, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: var1 complex, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: var1 complex, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: var1 complex(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: var1 complex(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: var1 complex(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status","tags":"testcase subroutines","loc":"interface/assert_equal.html"},{"title":"assert_not_equal â€“ naturalFRUIT","text":"public interface assert_not_equal Test that var1 and var2 are not equal.\n If the values do compare equal, the test will fail. assert_not_equal invokes one of the following subroutines according\n to the number or type of arguments. Contents Module Procedures assert_not_eq_logical_ assert_not_eq_1d_logical_ assert_not_eq_2d_logical_ assert_not_eq_string_ assert_not_eq_1d_string_ assert_not_eq_2d_string_ assert_not_eq_int_ assert_not_eq_1d_int_ assert_not_eq_2d_int_ assert_not_eq_real_ assert_not_eq_1d_real_ assert_not_eq_2d_real_ assert_not_eq_double_ assert_not_eq_1d_double_ assert_not_eq_2d_double_ assert_not_eq_complex_real_ assert_not_eq_1d_complex_real_ assert_not_eq_2d_complex_real_ assert_not_eq_complex_double_ assert_not_eq_1d_complex_double_ assert_not_eq_2d_complex_double_ Module Procedures private subroutine assert_not_eq_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: var1 logical, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:, :) :: var1 logical, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: var1 character(len=*), intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:, :) :: var1 character(len=*), intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: var1 integer, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:, :) :: var1 integer, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: var1 real, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: var1 real, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: var1 real(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: var1 real(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: var1 real(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in) :: var1 complex, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: var1 complex, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: var1 complex, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: var1 complex(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: var1 complex(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: var1 complex(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status","tags":"testcase subroutines","loc":"interface/assert_not_equal.html"},{"title":"add_fail â€“ naturalFRUIT","text":"public interface add_fail Print message to screen on assert failure and add to count. add_fail invokes one of the following subroutines according\n to number of arguments. Contents Module Procedures add_fail_ add_fail_case_named_ Module Procedures private subroutine add_fail_(message) Print message to screen on assert failure and add to count. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_case_named_(caseName, message) Print message to screen on assert failure and add to count. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: caseName character(len=*), intent(in) :: message","tags":"testsuite subroutine","loc":"interface/add_fail.html"},{"title":"naturalfruit â€“ naturalFRUIT","text":"This module contains the procedures and variables that the user may use\n for unit testing with fruit. Contents Variables FRUIT_PREFIX_LEN_MAX Interfaces assert_equal assert_not_equal add_fail Functions fruit_if_case_failed get_last_message is_last_passed is_case_passed Subroutines testsuite_initialize testsuite_finalize testsuite_initialize_xml case_passed_xml case_failed_xml testsuite_summary_xml fruit_show_dots fruit_hide_dots testcase_initialize testcase_finalize testsuite_summary testsuite_summary_table is_all_successful get_xml_filename_work set_xml_filename_work get_message_index get_message_array get_messages get_total_count get_failed_count add_success failed_assert_action set_case_name get_case_name override_stdout override_xml_work stash_test_suite restore_test_suite end_override_stdout end_override_xml_work set_prefix get_prefix get_assert_and_case_count assert_true assert_false assert_identical assert_not_identical Variables Type Visibility Attributes Name Initial integer, public, parameter :: FRUIT_PREFIX_LEN_MAX = 50 Interfaces public interface assert_equal Test that var1 and var2 are equal. Read moreâ€¦ private subroutine assert_eq_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: var1 logical, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:, :) :: var1 logical, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: var1 character(len=*), intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:, :) :: var1 character(len=*), intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: var1 integer, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:, :) :: var1 integer, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: var1 real, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: var1 real, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: var1 real(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: var1 real(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: var1 real(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in) :: var1 complex, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: var1 complex, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: var1 complex, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: var1 complex(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_1d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: var1 complex(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_eq_2d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: var1 complex(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status public interface assert_not_equal Test that var1 and var2 are not equal. Read moreâ€¦ private subroutine assert_not_eq_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 logical, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: var1 logical, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_logical_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:, :) :: var1 logical, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: var1 character(len=*), intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: var1 character(len=*), intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_string_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:, :) :: var1 character(len=*), intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: var1 integer, intent(in) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: var1 integer, intent(in), dimension(:) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_int_(var1, var2, message, status) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:, :) :: var1 integer, intent(in), dimension(:, :) :: var2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in) :: var1 real, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: var1 real, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: var1 real, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: var1 real(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: var1 real(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:, :) :: var1 real(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in) :: var1 complex, intent(in) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: var1 complex, intent(in), dimension(:) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_complex_real_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: var1 complex, intent(in), dimension(:, :) :: var2 real, intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: var1 complex(kind=dp), intent(in) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_1d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: var1 complex(kind=dp), intent(in), dimension(:) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status private subroutine assert_not_eq_2d_complex_double_(var1, var2, delta, message, status) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:, :) :: var1 complex(kind=dp), intent(in), dimension(:, :) :: var2 real(kind=dp), intent(in), optional :: delta character(len=*), intent(in), optional :: message logical, intent(out), optional :: status public interface add_fail Print message to screen on assert failure and add to count. Read moreâ€¦ private subroutine add_fail_(message) Print message to screen on assert failure and add to count. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message private subroutine add_fail_case_named_(caseName, message) Print message to screen on assert failure and add to count. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: caseName character(len=*), intent(in) :: message Functions public function fruit_if_case_failed () Category testsuite subroutine Return TRUE if any assert in current case has failed. Arguments None Return Value logical public function get_last_message () Category testsuite subroutine Return last message. Arguments None Return Value character(len=MSG_LENGTH) public function is_last_passed () Category testsuite subroutine Return true if last assert is successful in case. Arguments None Return Value logical public function is_case_passed () Category testsuite subroutine Return true if all asserts are successful in case. Arguments None Return Value logical Subroutines public subroutine testsuite_initialize (rank) Category testsuite subroutine Initialize FRUIT driver environment. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank public subroutine testsuite_finalize (exit_code) Category testsuite subroutine Finalize FRUIT driver environment Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: exit_code public subroutine testsuite_initialize_xml (rank) Category testsuite subroutine Initialize FRUIT driver environment for output to XML file Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: rank public subroutine case_passed_xml (tc_name, classname) Category testsuite subroutine Write to XML file a passed case. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public subroutine case_failed_xml (tc_name, classname) Category testsuite subroutine Write to XML file a passed case. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tc_name character(len=*), intent(in) :: classname public subroutine testsuite_summary_xml () Category testsuite subroutine Summarize FRUIT test results in XML format to result.xml file. Arguments None public subroutine fruit_show_dots () Category testsuite subroutine Show dots signifying test success on screen. Visible by default. Arguments None public subroutine fruit_hide_dots () Category testsuite subroutine Hide dots signifying test success on screen. Visible by default. Arguments None public subroutine testcase_initialize (tc_name) Category testcase subroutine Initialize a testcase. Read moreâ€¦ Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: tc_name public subroutine testcase_finalize (exit_code) Category testcase subroutine Finalize a testcase Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: exit_code public subroutine testsuite_summary () Category testsuite subroutine Summarize FRUIT test results to screen. Arguments None public subroutine testsuite_summary_table (succ_assert, fail_assert, succ_case, fail_case) Category testsuite subroutine Print statistics of cases and asserts in default format. Arguments Type Intent Optional Attributes Name integer, intent(in) :: succ_assert integer, intent(in) :: fail_assert integer, intent(in) :: succ_case integer, intent(in) :: fail_case public subroutine is_all_successful (result) Category testsuite subroutine Return true to result if any assert has failed till now. Arguments Type Intent Optional Attributes Name logical, intent(out) :: result public subroutine get_xml_filename_work (string) Category testsuite subroutine Get filename of XML file. result.xml by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: string public subroutine set_xml_filename_work (string) Category testsuite subroutine Set filename of XML file. result.xml by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public subroutine get_message_index (index) Category testsuite subroutine Get number of failed assertion messages. Arguments Type Intent Optional Attributes Name integer, intent(out) :: index public subroutine get_message_array (msgs) Category testsuite subroutine Get failed asssertion messages to msgs . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public subroutine get_messages (msgs) Category testsuite subroutine Get failed asssertion messages to msgs . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: msgs (:) public subroutine get_total_count (count) Category testsuite subroutine Get total number of asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine get_failed_count (count) Category testsuite subroutine Get number of assert failures. Arguments Type Intent Optional Attributes Name integer, intent(out) :: count public subroutine add_success () Category testsuite subroutine Print message to screen on assert success and add to count. Arguments None public subroutine failed_assert_action (expected, got, message, if_is) Category testsuite subroutine Print message to screen and take necessary actions for assert failure. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: expected character(len=*), intent(in) :: got character(len=*), intent(in), optional :: message logical, intent(in), optional :: if_is public subroutine set_case_name (value) Category testsuite subroutine Set name of case to value . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value public subroutine get_case_name (value) Category testsuite subroutine Get name of case to value . Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: value public subroutine override_stdout (write_unit, filename) Category testsuite subroutine Override stdout to a user-specified file. Terminal by default. Arguments Type Intent Optional Attributes Name integer, intent(in) :: write_unit character(len=*), intent(in) :: filename public subroutine override_xml_work (new_unit, filename) Category testsuite subroutine Override XML file unit number to a user-specified number. 21 by default. Arguments Type Intent Optional Attributes Name integer, intent(in) :: new_unit character(len=*), intent(in) :: filename public subroutine stash_test_suite () Category testsuite subroutine Stash results of test case for later use. Arguments None public subroutine restore_test_suite () Category testsuite subroutine Restore results of test case for use. Arguments None public subroutine end_override_stdout () Category testsuite subroutine Revert override of stdout to default. Terminal by default. Arguments None public subroutine end_override_xml_work () Category testsuite subroutine Revert override of XML file unit number to default. 21 by default. Arguments None public subroutine set_prefix (str) Category testsuite subroutine Set a common prefix for classname. Null by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str public subroutine get_prefix (str) Category testsuite subroutine Get a common prefix for classname. Null by default. Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: str public subroutine get_assert_and_case_count (fail_assert, suc_assert, fail_case, suc_case) Category testsuite subroutine Get statistics of cases and asserts. Arguments Type Intent Optional Attributes Name integer, intent(out) :: fail_assert integer, intent(out) :: suc_assert integer, intent(out) :: fail_case integer, intent(out) :: suc_case public subroutine assert_true (var1, message, status) Category testcase subroutine Test that var1 is true. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status public subroutine assert_false (var1, message, status) Category testcase subroutine Test that var1 is false. Arguments Type Intent Optional Attributes Name logical, intent(in) :: var1 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status public subroutine assert_identical (filename1, filename2, message, status) Category testcase subroutine Compare two files and return true if identical Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename1 character(len=*), intent(in) :: filename2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status public subroutine assert_not_identical (filename1, filename2, message, status) Category testcase subroutine Compare two files and return true if not identical Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename1 character(len=*), intent(in) :: filename2 character(len=*), intent(in), optional :: message logical, intent(out), optional :: status","tags":"","loc":"module/naturalfruit.html"},{"title":"fruit_mpi â€“ naturalFRUIT","text":"Documentation under construction Uses naturalfruit mpi Contents None","tags":"","loc":"module/fruit_mpi.html"},{"title":"Documentation â€“ naturalFRUIT","text":"naturalFRUIT (If you are already familiar with the basic concepts of testing, you might want to skip to the list of assert methods .) naturalFRUIT is a unit testing framework for Fortran programs adapted from Fortran Unit Test Framework (FRUIT) with a goal to be independant of other programming languages.\nDue to the lack of reflection and exception handling in Fortran, unit test frameworks tend to rely on other languages like Ruby to ensure flexibility and elegance. naturalFRUIT compromises this elegance for ease of use, quick set-up and learning without losing flexibility.\nnaturalFRUIT was built with users of JUnit and python's unittest packages in mind. Similar concepts are used in naturalFRUIT too: assert statements The assert statement is the fundamental building block for unit testing in naturalFRUIT. Everything else is just decoration . \n  The assert statement acccepts two arguments- an expected value and a test value. Once the test value is obtained from the function being tested, the assert statement compares it against the expected value. If they match, the assert is a succes, implying the function works as expected. If not, the assert is deemed a failure and the test function is assumed to not work as expected. test case A test case is the individual unit of testing. It checks for a specific response to a particular set of inputs by using one or more assert statements. Success of all asserts inside a test case implies the test case is successful. Typically, each subroutine/function in a module is tested using a dedicated test case. test suite A test suite is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together. In naturalFRUIT, the test cases contained in a test suite are defined together as subroutines of a module. test fixture A test fixture represents the preparation needed to perform one or more tests, and any associated cleanup actions. This may involve, for example, allocating variables, creating temporary directories or initializing data sets for testing. test runner A test runner is the component which orchestrates the execution of tests and provides the outcome to the user. For naturalFRUIT, a separate Fortran program performs the duties of a test runner. This test runner program invokes testcases from the test suite module. The following image illustrates the typical workflow and basic subroutines for unit testing using naturalFRUIT: Warning Documentation, tutorials and source code are under active development. Use cautiously.","tags":"","loc":"page//index.html"},{"title":"Assert methods â€“ naturalFRUIT","text":"naturalFRUIT provides several assert methods to check for and report failures. The following list contains variants of the most commonly used formats. Although only the assert_equal , assert_true and assert_identical methods are described here, analogous formats exist for the assert_not_equal , assert_false and assert_not_identical methods. 1. assert_equal Syntax Returns true if Underlying subroutine assert_equal(logical a, logical b) a == b assert_eq_logical_ assert_equal(string a, string b) a == b assert_eq_string_ assert_equal(int a, int b) a == b assert_eq_int_ assert_equal(real a, real b) abs(a-b) < eps assert_eq_real_ assert_equal(real a, real b, real tol) abs(a-b) < tol assert_eq_real_ assert_equal(real(dp) a, real(dp) b) abs(a-b) < eps assert_eq_double_ assert_equal(real(dp) a, real(dp) b, real(dp) tol) abs(a-b) < tol assert_eq_double_ assert_equal(complex a, complex b) abs(a-b) < (eps,eps) assert_eq_complex_ assert_equal(complex a, complex b, tol) abs(a-b) < (tol,tol) assert_eq_complex_ assert_equal(complex(dp) a, complex(dp) b) abs(a-b) < (eps,eps) assert_eq_complex_double_ assert_equal(complex(dp) a, complex(dp) b, real(dp) tol) abs(a-b) < (tol,tol) assert_eq_complex_double_ 2. assert_true Syntax Returns true if Underlying subroutine assert_true(logical a) a == .true. assert_true 3. assert_identical Syntax Returns true if Underlying subroutine assert_identical(string filename1, string filename2) contents are same assert_identical Note All the assert methods accept two optional arguments message and status . message , if specified, is used as the error message on failure. status , if present, supresses general test case behaviour like printing of success and failure messages, and the boolean variable provided to the status specifier returns .true. or .false. depending on assert sucess or failure. Additionally, all assert subroutines that handle int , real , real(dp) , complex , and complex(dp) can also accept one and two dimensional arrays as input arguments. An element-wise check is performed in these cases.","tags":"","loc":"page/AssertMethods/index.html"},{"title":"Deprecated methods â€“ naturalFRUIT","text":"The following methods have been deprecated or replaced to maintain consistency and/or accuracy. Deprecated Replaced by addFail add_fail addSuccess add_success assert_equals assert_equal assertEquals assert_equal assert_not_equals assert_not_equal assertNotEquals assert_not_equal assertTrue assert_true getFailedCount get_failed_count getTestSummary testsuite_summary getTotalCount get_total_count isAllSuccessful is_all_successful init_fruit testsuite_initialize initializeFruit testsuite_initialize fruit_finalize testsuite_finalize fruit_initialize testsuite_initialize fruit_summary testsuite_summary fruit_summary_table testsuite_summary_table fruit_summary_xml testsuite_summary_xml runTestCase removed run_test_case removed","tags":"","loc":"page/DeprecatedMethods/index.html"},{"title":"Major changes â€“ naturalFRUIT","text":"The following are the major changes incorporated in naturalFRUIT with regard to FRUIT. This list is helpful if you are already familiar with FRUIT or are trying to port your testing framework to naturalFRUIT from FRUIT. Single module : FRUIT consisted of two modules packaged into a single file. Now, the fruit_util module has been removed and necessary subroutines have been included inside the naturalfruit module contained in the file naturalfruit.f90 . Deprecated procedures : A few procedures have been replaced to maintain consistency in naming convention. Refer the page Deprecated Methods in the documentation for more details. Status specifier : All assert subroutines now accept a status specifier that suppresses general test case behaviour like printing of success or failure messages. The boolean variable provided to the specifier returns .true. or .false. depending on assert success or failure. This allows standalone calls of the assert methods without defining a test case environment. Exception handling : A primitive type of exception handling is incorporated in naturalFRUIT by returning the number of failed cases as an exit code. This may be used in testing using continous integration frameworks like Travis. Test suite functionality : The test suite functionality has been revamped to an intialize - finalize workflow for both testsuites and testcases. The methods are named similar to those used by popular unit testing framework in other languages like python and jUnit. This also avoids pointers to testcase methods and better brevity.","tags":"","loc":"page/MajorChanges/index.html"},{"title":"Tutorials â€“ naturalFRUIT","text":"Before we dive into unit testing using naturalFRUIT, here are a few concepts that we will be using throughout the tutorials. A basic idea of these should be sufficient to breeze through the tutorials. assert statements The assert statement is the fundamental building block for unit testing in naturalFRUIT. Everything else is just decoration . \n  The assert statement acccepts two arguments- an expected value and a test value. Once the test value is obtained from the function being tested, the assert statement compares it against the expected value. If they match, the assert is a succes, implying the function works as expected. If not, the assert is deemed a failure and the test function is assumed to not work as expected. test case A test case is the individual unit of testing. It checks for a specific response to a particular set of inputs by using one or more assert statements. Success of all asserts inside a test case implies the test case is successful. Typically, each subroutine/function in a module is tested using a dedicated test case. test suite A test suite is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together. In naturalFRUIT, the test cases contained in a test suite are defined together as subroutines of a module. test fixture A test fixture represents the preparation needed to perform one or more tests, and any associated cleanup actions. This may involve, for example, allocating variables, creating temporary directories or initializing data sets for testing. test runner A test runner is the component which orchestrates the execution of tests and provides the outcome to the user. For naturalFRUIT, a separate Fortran program performs the duties of a test runner. This test runner program invokes testcases from the test suite module. Contents: Tutorial 0 :\n  Basic tutorial that introduces the assert subroutine. Tutorial 1 :\n  Basic tutorial that introduces assert subroutines and testrunner. Tutorial 2 : \n  Tutorial that introduces testcases and testrunner.","tags":"","loc":"page/Tutorials/index.html"},{"title":"Tutorial 0 â€“ naturalFRUIT","text":"Testing the matmul intrinsic function In order to understand the basic workflow of unit testing, let's try verifying the matmul intrinsic function that performs matrix multiplication in Fortran.\nLet's start with integer multiplication for 2 x 2 matrices.\nWe shall take two example matrices and use the assert_equal statement to compare the expected matrix result with the one matmul outputs.\nLet's also deliberately add a wrong case that results in a failed assert statement. program matmul_test use naturalfruit integer , dimension ( 2 , 2 ) :: a , b integer , dimension ( 2 , 2 ) :: expectedMat , obtainedMat a ( 1 , :) = ( / 1 , 2 / ) a ( 2 , :) = ( / 3 , 4 / ) b ( 1 , :) = ( / 5 , 6 / ) b ( 2 , :) = ( / 7 , 8 / ) expectedMat ( 1 , :) = ( / 19 , 22 / ) expectedMat ( 2 , :) = ( / 43 , 50 / ) obtainedMat = matmul ( a , b ) call assert_equal ( expectedMat , obtainedMat ) ! <--- Assert statement call assert_equal ( expectedMat , obtainedMat + 1 ) ! <--- Assert statement end program matmul_test Ensure the module naturalfruit.f90 is available for use and available for linking. Our example program may then be compiled and executed using: $ gfortran -c naturalfruit.f90\n$ gfortran matmul_test.f90 naturalfruit.o\n$ ./a.out Executing this program will print a .F to the screen. The . indicates a successful assert while the F a failed assert. This is a concise indication common to other testing frameworks too. \nFor a clearer outline of the results, we leverage nauralFRUIT's testsuite_summary method. We shall also supply assert_equal an optional message argument to print out a message in case of a failed assert. This would allow us to better identify the failed assert.\nMaking these changes in the program, program matmul_test use naturalfruit integer , dimension ( 2 , 2 ) :: a , b integer , dimension ( 2 , 2 ) :: expectedMat , obtainedMat a ( 1 , :) = ( / 1 , 2 / ) a ( 2 , :) = ( / 3 , 4 / ) b ( 1 , :) = ( / 5 , 6 / ) b ( 2 , :) = ( / 7 , 8 / ) expectedMat ( 1 , :) = ( / 19 , 22 / ) expectedMat ( 2 , :) = ( / 43 , 50 / ) obtainedMat = matmul ( a , b ) call assert_equal ( expectedMat , obtainedMat , 'Fail 1' ) ! <--- Assert statement call assert_equal ( expectedMat , obtainedMat + 1 , 'Fail 2' ) ! <--- Assert statement call testsuite_summary () ! <--- Print results summary end program matmul_test and executing it will provide: .F\n\n     Start of FRUIT summary:\n\n Some tests failed!\n\n   -- Failed assertion messages: [ _not_set_ ] : Expected [ 19 ] , Got [ 20 ] ; User message: [ 2d array has difference, Fail 2 ] -- end of failed assertion messages.\n\n Total asserts : 2 Successful    : 1 Failed        : 1 Successful rate: 50 .00%\n\n Successful asserts / total asserts : [ 1 / 2 ] Successful cases   / total cases   : [ 0 / 1 ] -- end of FRUIT summary Although naturalFRUIT is currently working with set defaults, it requires to be properly initialized to prevent unexpected beahviour. For this, we shall utilize the testsuite_initialize and the testsuite_finalize statements. We will also provide an optional integer argument exit_code to testsuite_finalize to obtain an exit code for our test program. This will indicate whether program as a whole was successfully executed and be helpful when integrating with other frameworks including those with continuous integration testing capabilities. program matmul_test use naturalfruit integer , dimension ( 2 , 2 ) :: a , b integer , dimension ( 2 , 2 ) :: expectedMat , obtainedMat integer :: exit_code ! <--- Declare exit_code call testsuite_initialize () ! <--- Initialize testsuite a ( 1 , :) = ( / 1 , 2 / ) a ( 2 , :) = ( / 3 , 4 / ) b ( 1 , :) = ( / 5 , 6 / ) b ( 2 , :) = ( / 7 , 8 / ) expectedMat ( 1 , :) = ( / 19 , 22 / ) expectedMat ( 2 , :) = ( / 43 , 50 / ) obtainedMat = matmul ( a , b ) call assert_equal ( expectedMat , obtainedMat , 'Fail 1' ) ! <--- Assert statement call assert_equal ( expectedMat , obtainedMat + 1 , 'Fail 2' ) ! <--- Assert statement call testsuite_summary () ! <--- Print results summary call testsuite_finalize ( exit_code ) ! <--- Finalize testsuite call exit ( exit_code ) ! <--- Exit using exit_code end program matmul_test We have now realized the bare minimum to perform unit testing with naturalFRUIT. \nThis program may be easily extended to testing  other data types like real and real*8 too. \nHowever, for maintaining a testsuite with a large number of complex testcases, we cannot rely only on a simple testrunner program like the above. A better organization of things is essential. Continue to the next tutorial to find how this may be achieved. Next Tutorial","tags":"","loc":"page/Tutorials/tutorial0/index.html"},{"title":"Tutorial 1 â€“ naturalFRUIT","text":"Using a module to organize testcases Note Documentation under construction Prev Tutorial ---------------------------------------- Next Tutorial","tags":"","loc":"page/Tutorials/tutorial1/index.html"}]}